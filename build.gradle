import java.nio.charset.StandardCharsets

plugins {
  id 'org.checkerframework' version '0.6.10' apply false
  id 'net.ltgt.errorprone' version '2.0.2' apply false
  id 'net.ltgt.nullaway' version '1.3.0' apply false
  id 'jacoco'
  id 'com.github.kt3k.coveralls' version '2.12.0'
  id 'com.github.ben-manes.versions' version '0.42.0'
  id 'io.github.gradle-nexus.publish-plugin' version '1.1.0'
}

ext {
  isJavaProject = { project ->
    !(project.name in ['methanol-parent', 'brotli-jni'])
  }

  isPublished = { project ->
    project.name in [
        'methanol',
        'methanol-benchmarks',
        'methanol-brotli',
        'methanol-gson',
        'methanol-jackson',
        'methanol-jackson-flux',
        'methanol-jaxb',
        'methanol-protobuf',
        'methanol-redis',
        'methanol-testing'
    ]
  }

  // Project has tests that contribute to coverage?
  contributesToTests = { project ->
    project.name in [
        'methanol',
        'methanol-blackbox',
        'methanol-brotli',
        'methanol-gson',
        'methanol-jackson',
        'methanol-jackson-flux',
        'methanol-jaxb',
        'methanol-protobuf',
        // TODO uncomment when redis-specific tests are added 'methanol-redis'
    ]
  }

  // Project is included in coverage report?
  isIncludedInCoverageReport = { project ->
    isPublished(project) && project.name != 'methanol-benchmarks'
  }

  getArtifactId = { project ->
    if (!isPublished(project)) return null

    return project.name == 'methanol-benchmarks' ? 'benchmarks' : project.name
  }
}

allprojects {
  group = 'com.github.mizosoft.methanol'
  ext.artifactId = getArtifactId(project)
  version = '1.7.1-SNAPSHOT'

  repositories {
    mavenCentral()
  }
}

subprojects { subproject ->
  if (!isJavaProject(subproject)) return

  apply plugin: 'java-library'
  apply plugin: 'org.checkerframework'
  apply plugin: 'net.ltgt.errorprone'
  apply plugin: 'net.ltgt.nullaway'
  apply plugin: 'idea'
  apply plugin: 'jacoco'
  apply plugin: 'module-name-extension'

  sourceCompatibility = JavaVersion.VERSION_11

  dependencies {
    compileOnly libs.checkerframework.qual
    compileOnly libs.errorprone.annotations

    checkerFramework libs.checkerframework
    errorprone libs.errorprone
    errorprone libs.nullaway

    testImplementation platform(libs.junit.bom)
    testImplementation libs.junit.jupiter

    testImplementation libs.assertj
    testImplementation libs.awaitility
    testImplementation libs.hamcrest
  }

  checkerFramework {
    excludeTests = true
    if (project.hasProperty('enableCheckerframework')) {
      checkers = [
          'org.checkerframework.checker.nullness.NullnessChecker'
      ]
    }
  }

  tasks.withType(JavaCompile) {
    options.encoding = StandardCharsets.UTF_8.name()
  }

  compileJava {
    configure(options) {
      javaModuleVersion = provider { project.version }

      errorprone {
        enabled = project.hasProperty('enableErrorprone')

        nullaway {
          annotatedPackages.add('com.github.mizosoft.methanol')
          excludedFieldAnnotations = ['org.checkerframework.checker.nullness.qual.MonotonicNonNull']
        }
      }
    }
  }

  compileTestJava {
    options.errorprone.enabled = false
  }

  javadoc {
    options {
      links 'https://docs.oracle.com/en/java/javase/17/docs/api/'
      addBooleanOption('Xdoclint:-missing', true)
    }
  }

  test {
    useJUnitPlatform()
    testLogging {
      events 'skipped', 'failed'
      exceptionFormat 'full'
      showCauses true
      showExceptions true
      showStackTraces true
      showStandardStreams true
    }
  }

  jacoco {
    toolVersion = libs.versions.jacoco.get()
  }
}

nexusPublishing {
  repositories {
    sonatype {
      username = project.findProperty('nexusUsername')
      password = project.findProperty('nexusPassword')
    }
  }
}

subprojects { subproject ->
  if (!isPublished(subproject)) return

  apply plugin: 'maven-publish'
  apply plugin: 'signing'

  publishing {
    java {
      withSourcesJar()
      withJavadocJar()
    }

    publications {
      maven(MavenPublication) {
        artifactId = project.ext.artifactId
        from components.java

        pom {
          name = project.name
          description = 'Lightweight HTTP extensions for Java'
          url = 'https://mizosoft.github.io/methanol/'
          inceptionYear = '2019'

          scm {
            url = 'https://github.com/mizosoft/methanol'
            connection = 'scm:git:https://github.com/mizosoft/methanol.git'
            developerConnection = 'scm:git:ssh://git@github.com/mizosoft/methanol.git'
          }

          developers {
            developer {
              id = 'mizosoft'
              name = 'Moataz Abdelnasser'
              email = 'moataz.nasser20@gmail.com'
              url = 'https://github.com/mizosoft'
            }
          }

          licenses {
            license {
              name = 'MIT license'
              url = 'https://opensource.org/licenses/MIT'
            }
          }
        }
      }
    }
  }

  signing {
    required { !project.version.endsWith("SNAPSHOT") }

    def signingKeyId = project.findProperty("signingKeyId")
    def signingKey = project.findProperty("signingKey")?.with {
      new String(it.decodeBase64(), StandardCharsets.UTF_8)
    }
    def signingPassword = project.findProperty("signingPassword")
    useInMemoryPgpKeys(signingKeyId, signingKey, signingPassword)
    sign publishing.publications.maven
  }
}

task jacocoMerge(type: JacocoMerge) {
  subprojects.each { subproject ->
    if (contributesToTests(subproject)) {
      executionData subproject.tasks.withType(Test)
    }
  }
}

task jacocoRootReport(type: JacocoReport) {
  dependsOn jacocoMerge
  executionData jacocoMerge.destinationFile
  subprojects.each { subproject ->
    if (isIncludedInCoverageReport(subproject)) {
      additionalSourceDirs.from subproject.sourceSets.main.allSource.srcDirs
      sourceDirectories.from subproject.sourceSets.main.allSource.srcDirs
      classDirectories.from subproject.sourceSets.main.output
    }
  }
  reports {
    xml.required = true
    html.required = true
    csv.required = false
  }
}

coveralls {
  jacocoReportPath = jacocoRootReport.reports.xml.outputLocation
  subprojects.each { subproject ->
    if (isIncludedInCoverageReport(subproject)) {
      sourceDirs += subproject.sourceSets.main.allSource.srcDirs.flatten()
    }
  }
}

tasks.coveralls {
  dependsOn jacocoRootReport
  onlyIf { System.getenv().GITHUB_ACTIONS }
}

/** This task generates an aggregate Javadoc for all published modules (except benchmarks). */
task rootJavadoc(type: Javadoc) {
  def lazyModulePath = files() // --module-path
  def moduleSrcPaths = [:] // --module-source-path for multi-module compilation
  subprojects { Project subproject ->
    if (isPublished(subproject) && subproject != project(':methanol-benchmarks')) {
      source subproject.sourceSets.main.allJava
      afterEvaluate {
        lazyModulePath.from subproject.sourceSets.main.compileClasspath
        def moduleName = subproject.extensions.findByName('javaModuleName')
        if (moduleName) {
          moduleSrcPaths[moduleName] = subproject.file('src/main/java')
        }
      }
    }
  }

  options {
    links 'https://docs.oracle.com/en/java/javase/17/docs/api/'
    addBooleanOption('Xdoclint:-missing', true)
    addStringOption('doctitle', "Methanol ${project.version} API")
    addStringOption('windowtitle', "Methanol ${project.version} API")
  }

  destinationDir = file("${rootProject.buildDir}/docs/javadoc")

  doFirst {
    // Must be run in JDK12+ as the specific form of --module-source-path
    // is used because module names don't match containing directory names
    // https://bugs.java.com/bugdatabase/view_bug.do?bug_id=8208608
    if (!JavaVersion.current().isJava12Compatible()) {
      throw new GradleException('JDK 12 or later is required for multimodule Javadoc');
    }

    // these would otherwise be in gradlew.projectsEvaluated {} but it complains
    options {
      modulePath lazyModulePath.files.toList()
      addMultilineStringsOption('-module-source-path').with {
        value = moduleSrcPaths.collect { entry ->
          "${entry.key}=${entry.value}" as String
        }
      }
    }
  }
}

task clean(type: Delete) {
  delete rootProject.buildDir
}
