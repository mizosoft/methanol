package com.github.mizosoft.methanol.internal.cache;

import static com.github.mizosoft.methanol.internal.cache.DateUtils.max;
import static com.github.mizosoft.methanol.internal.cache.DateUtils.toUtcDateTime;
import static java.time.ZoneOffset.UTC;

import com.github.mizosoft.methanol.TrackedResponse;
import java.time.Duration;
import java.time.Instant;
import java.time.LocalDateTime;
import java.util.Optional;

/** Policy for computing freshness and age values as defined by RFC 7234 4.2. */
@SuppressWarnings("OptionalUsedAsFieldOrParameterType")
final class FreshnessPolicy {
  private final Optional<Duration> maxAge;
  private final Instant timeRequestSent;
  private final Instant timeResponseReceived;
  private final Duration age;

  /**
   * The time the response was generated by the server as identified by the {@code Date} header. If
   * the header is not present, the time the response was received is used instead (rfc7231
   * 7.1.1.2).
   */
  private final LocalDateTime date;

  /**
   * Response expiration date as specified by the {@code Expires} header. {@link #maxAge} has a
   * higher precedence in calculating freshness lifetime.
   */
  private final Optional<LocalDateTime> expires;

  /**
   * Either the value of the {@code Last-Modified} header or {@link #date} if the header is not
   * present.
   */
  private final LocalDateTime effectiveLastModified;

  FreshnessPolicy(Optional<Duration> maxAge, TrackedResponse<?> response) {
    this.timeRequestSent = response.timeRequestSent();
    this.timeResponseReceived = response.timeResponseReceived();
    this.maxAge = maxAge;

    var dateServed = response.headers().firstValue("Date").map(DateUtils::toHttpDate);
    date = dateServed.orElseGet(() -> toUtcDateTime(timeResponseReceived));
    expires = response.headers().firstValue("Expires").map(DateUtils::toHttpDate);
    effectiveLastModified =
        response.headers().firstValue("Last-Modified").map(DateUtils::toHttpDate).orElse(date);
    // Assume age is zero if there's no Age header or such header can't be parsed
    age =
        response
            .headers()
            .firstValue("Age")
            .map(DateUtils::toDeltaSecondsOrNull)
            .orElse(Duration.ZERO);
  }

  LocalDateTime effectiveLastModified() {
    return effectiveLastModified;
  }

  /** Computes response freshness lifetime as defined by rfc7324 4.2.1. */
  Duration computeFreshnessLifetime() {
    return maxAge
        .or(() -> expires.map(expires -> Duration.between(date, expires)))
        .orElseGet(this::computeHeuristicFreshnessLifetime);
  }

  private Duration computeHeuristicFreshnessLifetime() {
    // As encouraged by rfc7234 4.2.2 & implemented by browsers, use 10% of the time the response
    // hasn't been modified. If the server doesn't specify a Last-Modified, the resulting value
    // becomes 0 (effectiveLastModified defaults to date).
    return Duration.between(effectiveLastModified, date).dividedBy(10);
  }

  boolean usesHeuristics() {
    return maxAge.isEmpty() && expires.isEmpty();
  }

  /** Computes response's age relative to {@code now} as defined by rfc7324 4.2.3. */
  Duration computeAge(Instant now) {
    var apparentAge =
        max(Duration.between(date.toInstant(UTC), timeResponseReceived), Duration.ZERO);
    var responseDelay = Duration.between(timeRequestSent, timeResponseReceived);
    var correctedAge = age.plus(responseDelay);
    var correctedInitialAge = max(apparentAge, correctedAge);
    var residentTime = Duration.between(timeResponseReceived, now);
    return correctedInitialAge.plus(residentTime);
  }
}
