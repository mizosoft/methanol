{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Methanol","text":"<p>Java enjoys a neat, built-in HTTP client. However, it lacks key HTTP features like multipart uploads, caching and response decompression. Methanol comes in to fill these gaps. The library comprises a set of lightweight, yet powerful extensions aimed at making it much easier &amp; more productive to work with <code>java.net.http</code>. You can say it's an <code>HttpClient</code> wrapper, but you'll see it almost seamlessly integrates with the standard API you might already know.</p> <p>Methanol isn't invasive. The core library has zero runtime dependencies. However, special attention is given to object mapping, so integration with libraries like Jackson or Gson becomes a breeze.</p> <p>There's also a Kotlin DSL!</p>"},{"location":"#installation","title":"Installation","text":""},{"location":"#gradle","title":"Gradle","text":"<pre><code>implementation(\"com.github.mizosoft.methanol:methanol:1.8.3\")\n</code></pre>"},{"location":"#maven","title":"Maven","text":"<pre><code>&lt;dependency&gt;\n    &lt;groupId&gt;com.github.mizosoft.methanol&lt;/groupId&gt;\n    &lt;artifactId&gt;methanol&lt;/artifactId&gt;\n    &lt;version&gt;1.8.3&lt;/version&gt;\n&lt;/dependency&gt;\n</code></pre>"},{"location":"#contributing","title":"Contributing","text":"<p>See CONTRIBUTING</p>"},{"location":"#license","title":"License","text":"<p>MIT</p>"},{"location":"CHANGELOG/","title":"Change Log","text":""},{"location":"CHANGELOG/#version-183","title":"Version 1.8.3","text":"<ul> <li> <p>Fixed #121, where the response body was retained throughout the   entire read timeout, resulting in a \"timed\" memory leak. This happened as the previously used JVM-wide scheduler   retained   references to timeout tasks (which retained references to the response body through a reference chain starting from   <code>TimeoutBodySubscriber</code>).   Methanol now uses a library-wide scheduler that loses references to timeout tasks when invalidated.</p> </li> <li> <p>Fixed #125, where exception causes where swallowed in sync calls.</p> </li> </ul>"},{"location":"CHANGELOG/#version-182","title":"Version 1.8.2","text":"<p>Fix regression caused by #118.</p>"},{"location":"CHANGELOG/#version-181","title":"Version 1.8.1","text":"<p>Fixed #117, where decompressing the response could potentially hang.</p>"},{"location":"CHANGELOG/#version-180","title":"Version 1.8.0","text":"<p>Ok, here we go. That took a while.</p> <p>There's been a number of unreleased features brewing in the last two and a half years (!). Guess I could say I've been cooking some Meth\u2014anol, and now it's ready to serve. What's\u2014my\u2014name? Please don't say Heisenbug.</p> <p>Anyhow, here's what's new:</p> <ul> <li>Added a Redis storage backend for the HTTP cache, which supports Standalone &amp; Cluster setups.</li> <li>Added the ability to chain caches with different storage backends, expectedly in the order of decreasing locality.   This will work well with the Redis cache. Consider the case where you have multiple instances of your service all sharing   a Redis setup, you can have a chain of (JVM memory -&gt; Redis) or even (JVM memory -&gt; disk -&gt; Redis) caches, so each node can have a local cache to consult first, and the shared Redis cache after.</li> <li>The object mapping mechanism has been reworked to stay away from <code>ServiceLoader</code> &amp; static state.    We now have an <code>AdapterCodec</code> that is registered per-client.   <pre><code>var mapper = new JsonMapper();\nvar adapterCodec =\n    AdapterCodec.newBuilder()\n        .encoder(JacksonAdapterFactory.createJsonEncoder(mapper))\n        .decoder(JacksonAdapterFactory.createJsonDecoder(mapper))\n        .build();\nvar client =\n    Methanol.newBuilder()\n        .adapterCodec(adapterCodec)\n        .build();\n\nrecord Person(String name) {}\n\nHttpResponse&lt;Person&gt; response = client.send(\n      MutableRequest.GET(\".../echo\", new Person(\"Jack Reacher\"), MediaType.APPLICATION_JSON),\n      Person.class);\n</code></pre></li> <li>Added hip Kotlin extensions. These were enjoyable to work on. Check them out!.</li> <li>Added adapters for Moshi. This is mainly intended for Kotlin.</li> <li>Added hints API for adapters. This allows carrying arbitrary parameters to customize encoders &amp; decoders. Currently, supported   adapters expose no customization. If you think there's a useful, generalizable customization that can be passed to any of the supported adapters, feel free to create an issue.</li> <li>Added <code>MoreBodyPublishers::ofOutputStream</code> &amp; <code>MoreBodyPublishers::ofByteChannel</code> to be used in favor of <code>WritableBodyPublisher</code>.</li> <li>Added adapters for basic types in the core module.</li> <li>Added the ability to conditionally handle responses with <code>ResponsePayload</code> using the basic adapter.</li> <li>Disk cache writes became considerably faster by avoiding <code>fsync</code> on entry writes/updates, which was used to provide durability in a manner that later turned out   to be unnecessary for caches. Now CRC checks are used. Reads however became slightly slower.</li> <li>Added adapters for JAXB Jakarta. They're practically the same as JAXB JavaEE, but use the newer namespaces.</li> <li>New <code>HttpClient</code> APIs for closure &amp; for setting a local socket address have been implemented.</li> <li>As of Java 16, <code>sendAsync(...).cancel(true)</code>, or an interruption for the thread calling <code>send</code> can cancel the underlying   exchange. This is made sure to continue being the case even after the Methanol seasoning.</li> <li>Made <code>ResponseBuilder</code> part of public API.</li> </ul> <p>There are other incremental improvements here and there that I may have missed. I promise though your code won't break after the update. If that happens, please file an issue.</p> <p>Later!</p>"},{"location":"CHANGELOG/#version-170","title":"Version 1.7.0","text":"<p>9-5-2022</p> <p>A full year has passed since the last Methanol release! Time truly flies. It's been difficult to find the time to cut this release due to my senior college year &amp; other life circumstances, but here we are!</p> <ul> <li>The Jackson adapter has been reworked to support the multitude of formats supported by Jackson, not    only JSON (#45). That means you can now pass arbitrary   <code>ObjectMapper</code> instances along with one or more <code>MediaTypes</code> describing their formats. For instance,   here's a provider for a Jackson-based XML decoder.</li> </ul> <pre><code>public class JacksonXmlDecoderProvider {\n  private JacksonXmlDecoderProvider() {}\n\n  public static BodyAdapter.Decoder provider() {\n    return JacksonAdapterFactory.createDecoder(new XmlMapper(), MediaType.TEXT_XML);\n  }\n}\n</code></pre> <p>Binary formats (e.g. protocol buffers) usually require applying a schema for each type. <code>ObjectReaderFacotry</code>    &amp; <code>ObjectWriterFactory</code> have been added for this purpose. For instance, here's a provider for a protocol-buffers   decoder. You'll need to know which types to expect beforehand.</p> <pre><code>public class JacksonProtobufDecoderProvider {\n  private JacksonProtobufDecoderProvider() {}\n\n  public record Point(int x, int y) {}\n\n  public static BodyAdapter.Decoder provider() throws IOException {\n    var schemas = Map.of(\n        TypeRef.from(Point.class),\n        ProtobufSchemaLoader.std.parse(\n            \"\"\"\n            message Point {\n              required int32 x = 1;\n              required int32 y = 2;\n            }\n            \"\"\"), ...);\n\n    // Apply the corresponding schema for each created ObjectReader\n    ObjectReaderFactory readerFactory = \n        (mapper, type) -&gt; mapper.readerFor(type.rawType()).with(schemas.get(type));\n    return JacksonAdapterFactory.createDecoder(\n        new ProtobufMapper(), readerFactory, MediaType.APPLICATION_X_PROTOBUF);\n  }\n}\n</code></pre> <ul> <li> <p>To avoid ambiguity, <code>JacksonAdapterFactory::createDecoder</code> &amp; <code>JacksonAdapterFactory::createEncoder</code>   that don't take an explicit <code>MediaType</code> have been deprecated and replaced with <code>JacksonAdapterFactory::createJsonDecoder</code>   &amp; <code>JacksonAdapterFactory::createJsonEncoder</code> respectively.</p> </li> <li> <p>Added timeouts for receiving all response headers (#49).   You can use these along with read timeouts to set more granular timing constraints for your requests   when request timeouts are too strict.</p> </li> </ul> <pre><code>var client = Methanol.newBuilder()\n    .headersTimeout(Duration.ofSeconds(30))\n    .readTimeout(Duration.ofSeconds(30))\n    ...\n    .build()\n</code></pre> <ul> <li>Fix (#40): Methanol had a long-lived issue that made it   difficult for service providers to work with custom JAR formats, particularly the one used by Spring Boot's   executable JARs.   Instead of the system classloader, Methanol now relies on the classloader that loaded the library itself   for locating providers. This is not necessarily the system classloader as in the case with Spring Boot.</li> <li>Fix (46): <code>ProgressTracker</code> now returns <code>MimeBodyPublisher</code>   if the body being tracked is itself a <code>MimeBodyPublisher</code>. This prevents \"swallowing\" the <code>MediaType</code> of such bodies.</li> <li>Upgraded Jackson to <code>2.13.2</code>.</li> <li>Upgraded Gson to <code>2.9.0</code>.</li> <li>Upgraded Reactor to <code>3.4.17</code>.</li> </ul>"},{"location":"CHANGELOG/#version-160","title":"Version 1.6.0","text":"<p>30-5-2021</p> <ul> <li>Added <code>HttpCache.Listener</code>.</li> <li>Added <code>TaggableRequest</code>. This facilitates carrying application-specific data throughout interceptors &amp; listeners.</li> </ul> <pre><code>var interceptor = Interceptor.create(request -&gt; {\n    var taggableRequest = TaggableRequest.from(request);\n    var context = taggableRequest.tag(MyContext.class).orElseGet(MyContext::empty);\n    ...\n});\nvar client = Methanol.newBuilder()\n    .interceptor(interceptor)\n    .build();\n\nvar context = ...\nvar request = MutableRequest.GET(\"https://example.com\")\n    .tag(MyContext.class, context);\nvar response = client.send(request, BodyHandlers.ofString());\n</code></pre> <ul> <li>Fixed disk cache possibly manipulating the disk index concurrently. This could happen if an index   update is delayed, as the scheduler mistakenly ran the index write immediately after the delay evaluates instead   of queuing it with the sequential index executor.</li> <li>Fixed <code>TimeoutSubscriber</code> (used in <code>MoreBodySubscribers::withReadTimeout</code>) possibly calling   downstream's <code>onNext</code> &amp; <code>onError</code> concurrently. This could happen if timeout evaluates while downstream's   <code>onNext</code> is still executing.</li> <li>Made <code>AsyncBodyDecoder</code> ignore upstream signals after decoding in <code>onNext</code> fails and the error is   reported to <code>onError</code>. This prevents receiving further <code>onXXXX</code> by upstream if it doesn't immediately   detect cancellation.</li> <li>Made the disk cache catch and log <code>StoreCorruptionException</code> thrown when opening an entry. This is   done instead of rethrowing.</li> <li><code>Methanol</code> now always validates request's <code>URI</code> after being resolved with the optional base <code>URI</code>.   Previously, the <code>URI</code> was only validated if there was a base <code>URI</code>.</li> <li>Upgraded gson to 2.8.7.</li> </ul>"},{"location":"CHANGELOG/#version-150","title":"Version 1.5.0","text":"<p>14-5-2021</p> <ul> <li> <p>Methanol now has an RFC-compliant HTTP cache! It can store entries on disk or   in memory. Give it a try!   <pre><code>void cache() throws InterruptedException, IOException {\n  var cache = HttpCache.newBuilder()\n      .cacheOnDisk(Path.of(\"cache-dir\"), 100 * 1024 * 1024)\n      .build();\n  var client = Methanol.newBuilder()\n      .cache(cache)\n      .build();\n\n  var request = MutableRequest.GET(\"https://i.imgur.com/NYvl8Sy.mp4\");\n  var response = (CacheAwareResponse&lt;Path&gt;) client.send(\n      request, BodyHandlers.ofFile(Path.of(\"banana_cat.mp4\")));\n\n  System.out.printf(\n      \"%s (CacheStatus: %s, elapsed: %s)%n\",\n      response,\n      response.cacheStatus(),\n      Duration.between(response.timeRequestSent(), response.timeResponseReceived()));\n\n  cache.close();\n}\n</code></pre></p> </li> <li> <p>Added <code>CacheControl</code> to model the <code>Cache-Control</code> header and its directives. This is complementary   to the new cache as all configuration is communicated through <code>Cache-Control</code>.</p> </li> <li>Interceptors have been reworked. The old naming convention is deprecated. An interceptor is now either    a client or a backend interceptor instead of a pre/post decoration interceptor, where 'backend' refers   to <code>Methanol</code>'s backing <code>HttpClient</code>. The cache intercepts requests after client but before backend   interceptors. It was tempting to name the latter 'network interceptors', but that seemed rather confusing   as not all 'network' requests can be intercepted (<code>HttpClient</code> can make its own intermediate requests   like redirects &amp; retries).</li> <li>Added <code>HttpStatus</code>, which contains functions for checking response codes.</li> <li>Added <code>ForwardingEncoder</code> &amp; <code>ForwardingDecoder</code>. These are meant for easier installation of adapters   from the classpath.</li> <li><code>System.Logger</code> API is now used instead of <code>java.util.logging</code>.</li> <li>Fix: Don't attempt to decompress responses to HEADs. This fixed failures like <code>unexpected end of gzip stream</code>.</li> <li>Fix: Decompressed responses now have their stale <code>Content-Encoding</code> &amp; <code>Content-Length</code> headers removed.  </li> <li>Changed reactor dependency to API scope in the <code>methanol-jackson-flux</code> adapter.</li> <li>Upgraded Jackson to 2.12.3.</li> <li>Upgraded Reactor to 3.4.6.</li> <li>New project website!</li> </ul>"},{"location":"CHANGELOG/#version-141","title":"Version 1.4.1","text":"<p>26-9-2020</p> <ul> <li>Updated dependencies.</li> <li>Fix: Autodetect if a deflated stream is zlib-wrapped or not to not crash when some servers    incorrectly send raw deflated bytes for the <code>deflate</code> encoding.</li> </ul>"},{"location":"CHANGELOG/#version-140","title":"Version 1.4.0","text":"<p>27-7-2020</p> <ul> <li>Multipart progress tracking.</li> </ul>"},{"location":"CHANGELOG/#version-130","title":"Version 1.3.0","text":"<p>22-6-2020</p> <ul> <li>Default read timeout in <code>Methanol</code> client.</li> <li>API for tracking upload/download progress.</li> <li>High-level client interceptors.</li> </ul>"},{"location":"CHANGELOG/#version-120","title":"Version 1.2.0","text":"<p>1-5-2020</p> <ul> <li>Reactive JSON adapters with Jackson and Reactor.</li> <li>Common <code>MediaType</code> constants.</li> <li>XML adapters with JAXB.</li> </ul>"},{"location":"CHANGELOG/#version-110","title":"Version 1.1.0","text":"<p>17-4-2020 </p> <ul> <li>First \"main-stream\" release.</li> </ul>"},{"location":"CHANGELOG/#version-100","title":"Version 1.0.0","text":"<p>25-3-2020</p> <ul> <li>Dummy release.</li> </ul>"},{"location":"CONTRIBUTING/","title":"Contributing","text":"<p>Contributions are welcome! It is often a good idea to first discuss changes before submitting them. If you're considering small changes (e.g. in documentation), you can open a PR directly.</p> <p>You are more than welcome to:</p> <ul> <li>Report a bug</li> <li>Ask a question</li> <li>Propose a feature</li> <li>Submit a fix</li> <li>Improve documentation</li> </ul>"},{"location":"CONTRIBUTING/#prerequisites","title":"Prerequisites","text":"<p>It is recommended to set the <code>JAVA_HOME</code> environment variable to a JDK 11 (or later) directory in order to properly work with Gradle.</p>"},{"location":"CONTRIBUTING/#building","title":"Building","text":"<p>Before submitting a change, make sure to first run tests and code analysis. </p> <p><code>./gradlew clean check -PenableErrorprone</code></p> <p>Error-prone checks are included but disabled by default for build speed. It is desirable to make errorprone happy (maybe via reasonable suppressions). Checker Framework is optionally used but mainly for informative reasons (its acts weird and crashes, patches regarding this are welcome). Similarly, it can be run with <code>enableCheckerframework</code> project property.</p> <p><code>methanol-brotli</code> uses JNI and contains a <code>c/c++</code> subproject for the brotli decoder. The native project is not included in the build by default. You can do so with project property <code>includeBrotliJni</code> or running the <code>installBrotli</code> task if you have a proper tool chain. Note that brotli isn't yet supported for macOS, so make sure to exclude brotli tests when running from a Mac:</p> <p><code>./gradlew check -PenableErrorprone -x methanol-brotli:test</code></p>"},{"location":"CONTRIBUTING/#dependencies","title":"Dependencies","text":"<p>Methanol makes it easier to use third-party libraries with the HTTP client. However, it does so  without making users pay for what they don't need. The core module currently has zero runtime  dependencies, and it is important it remains so. Features that require dependencies should be in separate modules, possibly with <code>ServideLoader</code> abstractions introduced in the core  (e.g. <code>BodyAdapter</code>,<code>BodyDecoder</code>).</p>"},{"location":"CONTRIBUTING/#style","title":"Style","text":"<p>The project mostly adheres to the Google Style Guide. Changes are expected to be consistent regarding key style aspects (2 space indentation, 4 for continuation, etc). It is preferable to use google-java-format for new code.</p>"},{"location":"adapters/","title":"Adapters","text":"<p>HTTP bodies are often mappable to high-level types that your code understands. Java's HttpClient was designed with that in mind. However, available <code>BodyPublisher</code> &amp; <code>BodySubscriber</code> implementations are too basic, and implementing your own can be tricky. Methanol builds upon these APIs with an extensible object mapping mechanism that treats your objects as first-citizen HTTP bodies.</p>"},{"location":"adapters/#usage","title":"Usage","text":"<p>A serialization library can be integrated with Methanol through a corresponding adapter. Adapters for the most popular serialization libraries are provided by separate modules.</p> <ul> <li><code>methanol-gson</code>: JSON with Gson</li> <li><code>methanol-jackson</code>: JSON with Jackson (but also XML, Protocol Buffers, and other formats support by Jackson)</li> <li><code>methanol-jackson-flux</code>: Streaming JSON with Jackson and Reactor</li> <li><code>methanol-jaxb</code>: XML with JAXB</li> <li><code>methanol-jaxb-jakarta</code>: XML with JAXB (Jakarta version)</li> <li><code>methanol-protobuf</code>: Protocol Buffers</li> <li><code>methanol-moshi</code>: JSON with Moshi, intended for Kotlin</li> </ul> <p>We'll pick <code>methanol-jackson</code> for some of the examples presented here, which interact with GitHub's REST API.</p> <pre><code>var mapper = new JsonMapper();\nvar adapterCodec =\n    AdapterCodec.newBuilder()\n        .basic()\n        .encoder(JacksonAdapterFactory.createEncoder(mapper, MediaType.APPLICATION_JSON))\n        .decoder(JacksonAdapterFactory.createDecoder(mapper, MediaType.APPLICATION_JSON))\n        .build();\nvar client =\n    Methanol.newBuilder()\n        .adapterCodec(adapterCodec)\n        .baseUri(\"https://api.github.com/\")\n        .defaultHeader(\"Accept\", \"application/vnd.github.v3+json\")\n        .build();\n</code></pre> <p>An <code>AdapterCodec</code> groups together one or more adapters, possibly targeting different mapping schemes. It helps <code>Methanol</code> to select the correct adapter based on the request's or response's <code>MediaType</code>.</p> <p><code>basic()</code> adds the basic adapter, which encodes &amp; decodes basic types like <code>String</code> &amp; <code>InputStream</code>. Trace through the Javadoc for all supported basic types.</p>"},{"location":"adapters/#receiving-objects","title":"Receiving Objects","text":"<p>To get an <code>HttpResponse&lt;T&gt;</code>, give <code>Methanol::send</code> a <code>T.class</code>.</p> <pre><code> @JsonIgnoreProperties(ignoreUnknown = true) // We'll ignore most fields for brevity.\npublic record GitHubUser(String login, long id, String url) {}\n\nGitHubUser getUser(String username) throws IOException, InterruptedException {\n  return client.send(MutableRequest.GET(\"users/\" + username), GitHubUser.class).body();\n}\n</code></pre> <p>If you want to get fancier with generics, pass a <code>TypeRef&lt;T&gt;</code>.</p> <pre><code>@JsonIgnoreProperties(ignoreUnknown = true) // We'll ignore most fields for brevity.\npublic record GitHubIssue(String title, GitHubUser user, String body) {}\n\nList&lt;GitHubIssue&gt; getIssues(String owner, String repo) throws IOException, InterruptedException {\n  return client.send(\n      MutableRequest.GET(\"repos/\" + owner + \"/\" + repo + \"/issues\"),\n      new TypeRef&lt;List&lt;GitHubIssue&gt;&gt;() {}).body();\n}\n</code></pre>"},{"location":"adapters/#sending-objects","title":"Sending Objects","text":"<p>Each <code>MutableRequest</code> can have a payload as its body. A payload is an arbitrary object that is not yet resolved into a <code>BodyPublisher</code>. When the request is sent, the payload will be resolved with the client's <code>AdapterCodec</code>.</p> <pre><code>public record Markdown(String text, String context, String mode) {}\n\nString markdownToHtml(String text, String contextRepo) throws IOException, InterruptedException {\n  return client.send(\n      MutableRequest.POST(\"markdown\", new Markdown(text, contextRepo, \"gfm\"), MediaType.APPLICATION_JSON),\n      String.class).body();\n}\n</code></pre> <p>A payload must be given along with a <code>MediaType</code> specifying the format with which it will be resolved.</p>"},{"location":"adapters/#adapter-api","title":"Adapter API","text":"<p>An adapter provides an <code>Encoder</code> and/or a <code>Decoder</code> implementation. An <code>Encoder</code> creates <code>BodyPublisher</code> instances that stream a given object's serialized form. Similarly, a <code>Decoder</code> creates <code>BodySubscriber&lt;T&gt;</code> instances that convert the response body into <code>T</code>. Encoders &amp; decoders are given <code>Hints</code> to customize their behavior. One notable hint is the <code>MediaType</code>, which can be used to further describe the desired mapping format (e.g. specify a charset).</p>"},{"location":"adapters/#example-an-html-adapter","title":"Example - An HTML Adapter","text":"<p>Here's an adapter that uses Jsoup to convert HTML bodies to <code>Document</code> objects and vise versa. When you're writing adapters, it's a good idea to extend from <code>AbstractBodyAdapter</code>.</p> <pre><code>public abstract class JsoupAdapter extends AbstractBodyAdapter {\n  JsoupAdapter() {\n    super(MediaType.TEXT_HTML);\n  }\n\n  @Override\n  public boolean supportsType(TypeRef&lt;?&gt; type) {\n    return type.rawType() == Document.class;\n  }\n\n  public static final class Decoder extends JsoupAdapter implements BaseDecoder {\n    @Override\n    public &lt;T&gt; BodySubscriber&lt;T&gt; toObject(TypeRef&lt;T&gt; typeRef, Hints hints) {\n      requireSupport(typeRef, hints);\n      var charset = hints.mediaTypeOrAny().charsetOrUtf8();\n      var subscriber = BodySubscribers.mapping(BodySubscribers.ofString(charset), Jsoup::parse);\n      return BodySubscribers.mapping(subscriber, typeRef.exactRawType()::cast); // Safely cast Document to T.\n    }\n  }\n\n  public static final class Encoder extends JsoupAdapter implements BaseEncoder {\n    @Override\n    public &lt;T&gt; BodyPublisher toBody(T value, TypeRef&lt;T&gt; typeRef, Hints hints) {\n      requireSupport(typeRef, hints);\n      var charset = hints.mediaTypeOrAny().charsetOrUtf8();\n      var publisher = BodyPublishers.ofString(((Document) value).outerHtml(), charset);\n      return attachMediaType(publisher, hints.mediaTypeOrAny());\n    }\n  }\n}\n</code></pre> <p>Tip</p> <p>Make sure your encoders call <code>AbstractBodyAdapter::attachMediaType</code>, so the created <code>BodyPublisher</code> can be converted to a <code>MimeBodyPublisher</code>. That way, requests get the correct <code>Content-Type</code> header added by <code>Methanol</code>.</p>"},{"location":"adapters/#buffering-vs-streaming","title":"Buffering vs Streaming","text":"<p>Decoders typically load the whole response body into memory before deserialization. If your responses tend to have large bodies, or you'd prefer the memory efficiency afforded by streaming sources, you can ask to get a <code>Supplier&lt;T&gt;</code> instead.</p> <pre><code>@JsonIgnoreProperties(ignoreUnknown = true) // We'll ignore most fields for brevity.\npublic record GitHubUser(String login, long id, String url) {}\n\nGitHubUser getUser(String username) throws IOException, InterruptedException {\n  return client.send(\n          MutableRequest.GET(\"user/\" + username), \n          new TypeRef&lt;Supplier&lt;GitHubUser&gt;&gt;() {}).body().get();\n}\n</code></pre> <p>In such case, the response is completed as soon as all headers are read. If he decoder supports streaming, the supplier will deserialize from a streaming source, typically an <code>InputStream</code> or a <code>Reader</code>.</p> <p>The way a <code>Decoder</code> implements streaming is by overriding <code>toDeferredObject</code> to return a <code>BodySubscriber&lt;Supplier&lt;T&gt;&gt;</code>. Here's how it'd be properly implemented for our HTML adapter's decoder.</p> <pre><code>@Override\npublic &lt;T&gt; BodySubscriber&lt;Supplier&lt;T&gt;&gt; toDeferredObject(TypeRef&lt;T&gt; typeRef, Hints hints) {\n  requireSupport(typeRef, hints);\n  return BodySubscribers.mapping(\n      MoreBodySubscribers.ofReader(hints.mediaTypeOrAny().charsetOrUtf8()),\n      reader -&gt;\n          () -&gt;\n              typeRef\n                  .exactRawType() // Get Class&lt;Document&gt; as Class&lt;T&gt;\n                  .cast(\n                      Parser.htmlParser()\n                          .parseInput(\n                              new BufferedReader(reader), \"\"))); // Note the deferred parsing\n}\n</code></pre>"},{"location":"adapters/#legacy-adapters","title":"Legacy Adapters","text":"<p>See Legacy Adapter.</p>"},{"location":"benchmarks/","title":"methanol-benchmarks","text":"<p>JMH tests for Methanol's performance.</p>"},{"location":"benchmarks/#running-benchmarks","title":"Running Benchmarks","text":"<p>Benchmarks are available as a runnable Jar in Maven. You run them as following:</p> <pre><code>java -jar benchmarks-1.8.3-all.jar\n</code></pre>"},{"location":"benchmarks/#results","title":"Results","text":""},{"location":"benchmarks/#bodydecoder-vs-inputstream","title":"BodyDecoder vs InputStream","text":"<p>Compare Methanol's non-blocking decoders with available <code>InputStream</code> ones:</p> Decoder Mode Cnt Score Error Units Gzip <code>BodyDecoder</code> thrpt 5 4170.501 50.458 ops/s <code>GZIPInputStream</code> thrpt 5 4108.730 70.605 ops/s Deflate <code>BodyDecoder</code> thrpt 5 4037.943 51.947 ops/s <code>InflaterInputStream</code> thrpt 5 4035.100 162.641 ops/s Brotli <code>BodyDecoder</code> thrpt 5 4186.791 213.283 ops/s <code>BrotliInputStream</code> thrpt 5 2631.312 136.291 ops/s <p>Results show that <code>BodyDecoder</code> implementations are on par with available <code>InputStream</code> based decoders. Note that the brotli benchmark is biased as it also compares native C vs pure Java implementations.</p>"},{"location":"brotli/","title":"methanol-brotli","text":"<p>Provides brotli decompression.</p>"},{"location":"brotli/#installation","title":"Installation","text":""},{"location":"brotli/#gradle","title":"Gradle","text":"<pre><code>implementation(\"com.github.mizosoft.methanol:methanol-brotli:1.8.3\")\n</code></pre>"},{"location":"brotli/#maven","title":"Maven","text":"<pre><code>&lt;dependency&gt;\n  &lt;groupId&gt;com.github.mizosoft.methanol&lt;/groupId&gt;\n  &lt;artifactId&gt;methanol-brotli&lt;/artifactId&gt;\n    &lt;version&gt;1.8.3&lt;/version&gt;\n&lt;/dependency&gt;\n</code></pre>"},{"location":"brotli/#implementation-notes","title":"Implementation notes","text":"<p>The Java brotli decoder provided by Google only exposes <code>InputStream</code> APIs. It cannot be used to implement a non-blocking <code>BodyDecoder</code>. The C implementation is used instead through JNI bindings (also provided by Google). To allow multi-platform support, native libraries for each supported OS X Architecture are bundled with the JAR and extracted to a temp directory on use.</p>"},{"location":"brotli/#supported-platforms","title":"Supported platforms","text":"OS x86 x64 Tool Chain Tested Machines Windows \u2714 \u2714 Visual C++ Windows 10 &amp; CI Linux \u2714 \u2714 GCC 9.2.1 Ubuntu 19.10 &amp; CI Mac OS \u274c \u274c"},{"location":"brotli/#building-from-source","title":"Building from source","text":"<p>You can build from source if your platform is not supported. The build routine uses Gradle's native software plugin. You need to have a tool chain that's supported by gradle for your OS.</p>"},{"location":"brotli/#steps","title":"Steps","text":"<p>After cloning this repo, run gradle with the <code>installBrotli</code> and <code>assemble</code> tasks:</p> <p><code>gradlew installBrotli :methanol-brotli:assemble</code></p> <p>This builds the native libraries and copies them to <code>src/main/resources</code> for inclusion in the JAR. You will find the assembled ready-to-use Jar in the <code>build/libs/</code> directory.</p>"},{"location":"caching/","title":"Caching","text":"<p>Methanol comes with an RFC-compliant HTTP cache that supports disk &amp; memory storage backends. There's also an extension for Redis.</p>"},{"location":"caching/#setup","title":"Setup","text":"<p>An <code>HttpCache</code> is utilized by injecting it into a <code>Methanol</code> client.</p> DiskMemory <pre><code>// Select a size limit thats suitable for your application.\nlong maxSizeInBytes = 100 * 1024 * 1024; // 100 MBs\nvar cache = HttpCache.newBuilder()\n    .cacheOnDisk(Path.of(\".cache\"), maxSizeInBytes)\n    .build();\n\n// The cache intercepts requests you send through this client.\nvar client = Methanol.newBuilder()\n    .cache(cache)\n    .build();\n\n// Don't forget to close the cache when you're done!\ncache.close();\n</code></pre> <pre><code>// Select a size limit thats suitable for your application.\nlong maxSizeInBytes = 50 * 1024 * 1024; // 50 MBs\nvar cache = HttpCache.newBuilder()\n    .cacheOnMemory(maxSizeInBytes)\n    .build();\n\n// The cache intercepts requests you send through this client.\nvar client = Methanol.newBuilder()\n    .cache(cache)\n    .build();\n\n// Don't forget to close the cache when you're done!\ncache.close();\n</code></pre> <p>Hint</p> <p>You can pass the builder a custom <code>Executor</code> for launching asynchronous tasks needed by the cache. By default, an unbounded thread pool of daemon threads is used.</p> <p>Caution</p> <p>To avoid surprises, make sure the disk directory is exclusively owned by a single cache instance as long as it's open and nothing else. The cache enforces that to some degree by complaining with an <code>IOException</code> if it's initialized with a directory that's already in use by another instance in the same or a different JVM. Note that you can use the same <code>HttpCache</code> with multiple clients.</p> <p>An HTTP client can also be configured with a chain of caches, typically in the order of decreasing locality. The chain is invoked in the given order, and a cache either returns the response if it has a suitable one, or forwards to the next cache (or finally to the network) otherwise.</p> <pre><code>var memoryCache = HttpCache.newBuilder()\n    .cacheOnMemory(100 * 1024 * 1024)\n    .build();\nvar diskCache = HttpCache.newBuilder()\n    .cacheOnDisk(Path.of(\".cache\"), 500 * 1024 * 1024)\n    .build();\nvar client = Methanol.newBuilder()\n    .cacheChain(List.of(memoryCache, diskCache))\n    .build();\n</code></pre>"},{"location":"caching/#usage","title":"Usage","text":"<p>An HTTP cache is a transparent layer between you and the origin server. Its main goal is to save time &amp; bandwidth by avoiding network if requested resources are locally retrievable. It does so while preserving the typical HTTP client-server semantics. Thus, applications can start using a cache-configured HTTP client instance as a drop-in replacement without further setup.</p>"},{"location":"caching/#cachecontrol","title":"CacheControl","text":"<p>Requests override default cache behaviour using <code>CacheControl</code>.</p> CacheControlCache-Control header <pre><code>// Specify your cache directives\nvar cacheControl = CacheControl.newBuilder()\n    .maxAge(Duration.ofMinutes(30))\n    .staleIfError(Duration.ofSeconds(60))\n    .build();\n\n// Apply the directives to your request\nvar request = MutableRequest.GET(\"...\")\n    .cacheControl(cacheControl);\n</code></pre> <pre><code>// Cache-Control headers work as well\nvar request = MutableRequest.GET(\"...\")\n    .header(\"Cache-Control\", \"max-age=1800, stale-if-error=60\");\n</code></pre> <p>To properly use <code>CacheControl</code>, it is good to understand the key attributes of a cached response.</p>"},{"location":"caching/#age","title":"Age","text":"<p>The age of a stored response is the time it has been resident in your cache or any other cache along the route to the origin. In other words, a response's age is the time evaluated since it was last generated by the server.</p>"},{"location":"caching/#freshness","title":"Freshness","text":"<p>A fresh response is one that is servable by the cache without contacting the origin. A server specifies how long a stored response stays fresh. This is known as the response's freshness lifetime. The freshness value of a response is its age subtracted from its freshness lifetime. A response is fresh if its freshness value is <code>&gt;= 0</code>.</p> <p><code>CacheControl</code> lets you override a response's freshness lifetime by setting the <code>max-age</code> directive.</p> <pre><code>var cacheControl = CacheControl.newBuilder() \n    .maxAge(Duration.ofSeconds(10)) // Override the lifetime set by the server, if any\n    .build();\n</code></pre> <p>You can specify how fresh you'd like the response to be by putting a lower bound on its freshness value.</p> <pre><code>var cacheControl = CacheControl.newBuilder()\n    .minFresh(Duration.ofSeconds(30)) // Accept a response that stays fresh for at least the next 30 seconds\n    .build();\n</code></pre> <p>Info</p> <p>Sometimes, a response lacks an explicit freshness lifetime. As encouraged by the standard &amp; followed by browsers, Methanol uses a heuristic of 10% of the time between a response's generation &amp; last modification times in such cases.</p>"},{"location":"caching/#staleness","title":"Staleness","text":"<p>Responses with negative freshness values are said to be stale. The staleness value of a stored response is simply its freshness value negated. Normally, the cache won't serve a stale response until it's revalidated with the server. Revalidation causes the cache to ask the server, using special headers like <code>If-None-Match</code> &amp; <code>If-Modified-Since</code>, if it can serve the stale response at its disposal.  If the server doesn't mind, the cache serves said response without re-downloading its payload. Otherwise, the response is re-fetched.</p> <p>You can let the cache tolerate some staleness so it doesn't trigger revalidation.</p> Bounded StalenessArbitrary Staleness <pre><code>var cacheControl = CacheControl.newBuilder() \n    .maxStale(Duration.ofSeconds(30)) // Allow at most 30 seconds of staleness\n    .build();\n</code></pre> <pre><code>var cacheControl = CacheControl.newBuilder() \n    .anyMaxStale() // Allow any staleness\n    .build();\n</code></pre> <p><code>stale-if-error</code> makes the cache recover from network or server failures if there's a stored response. In such occasions, the cache falls back to the stored response if it satisfies the specified staleness.</p> <pre><code>var cacheControl = CacheControl.newBuilder() \n    .staleIfError(Duration.ofSeconds(30))\n    .build();\n</code></pre>"},{"location":"caching/#no-cache","title":"No Cache","text":"<p>You might want the cache to forward your request to origin even if there's a fresh stored response (e.g. refreshing a page). That's what <code>no-cache</code> is meant for.</p> <pre><code>var cacheControl = CacheControl.newBuilder() \n    .noCache()\n    .build();\n</code></pre> <p>The cache will use network efficiently. If there's a stored response, its presence is communicated to the server, so it can decide to let the cache serve said response if nothing has changed.</p>"},{"location":"caching/#only-if-cached","title":"Only If Cached","text":"<p>Use <code>only-if-cached</code> to avoid network in all cases. As usual, a stored response is served if it's suitable. Otherwise, however, the cache immediately serves a locally generated <code>504 Gateway Timeout</code> response.</p> <pre><code>var cacheControl = CacheControl.newBuilder() \n    .onlyIfCached()\n    .build();\n</code></pre> <p>A perfect use-case is when network is down. You may want to get a cached response if it's there or otherwise nothing.</p>"},{"location":"caching/#prohibiting-storage","title":"Prohibiting Storage","text":"<p>Use <code>no-store</code> if you don't want the cache to store anything about the response.</p> <pre><code>var cacheControl =  CacheControl.newBuilder() \n    .noStore()\n    .build();\n</code></pre> <p>Note that this, however, doesn't prohibit the cache from serving an already stored response.</p>"},{"location":"caching/#asynchronous-revalidation","title":"Asynchronous Revalidation","text":"<p>Sometimes you need a balance between responsiveness &amp; freshness. You are willing to get a response immediately even if it's stale, but ensure it is freshened for later access. That's exactly what <code>stale-while-revalidate</code> does.</p> <p>If the directive is found on a stale response, the cache serves it immediately provided it satisfies allowed staleness. Meanwhile, an asynchronous revalidation is triggered and the response is updated in background, keeping things fresh.</p>"},{"location":"caching/#invalidation","title":"Invalidation","text":"<p><code>HttpCache</code> has APIs that give you more control over what's stored.</p> <pre><code>var cache = HttpCache.newBuilder()\n    .cacheOnDisk(Path.of(\".cache\"), 500 * 1024 * 1024)\n    .build();\n\n// Remove the entry mapped to a particular URI.\ncache.remove(URI.create(\"https://i.imgur.com/NYvl8Sy.mp4\"));\n\n// Remove the response variant matching a particular request.\ncache.remove(\n    MutableRequest.GET(URI.create(\"https://i.imgur.com/NYvl8Sy.mp4\"))\n        .header(\"Accept-Encoding\", \"gzip\"));\n\n// Remove specific entries by examining their URIs.\nvar iterator = cache.uris();\nwhile (iterator.hasNext()) {\n  var uri = iterator.next();  \n  if (uri.getHost().equals(\"i.imgur.com\")) {\n    iterator.remove();  \n  }\n}\n\n// Remove all entries.\ncache.clear();\n\n// Dispose of the cache by deleting its entries then closing it in an atomic fashion.\n// The cache is rendered unusable after this call. This is meant for applications that\n// use a temporary directory for caching in case persistence isn't needed.\ncache.dispose();\n</code></pre>"},{"location":"caching/#cache-operation-statistics","title":"Cache Operation &amp; Statistics","text":"<p>Cache operation typically involves 3 scenarios.</p> <ul> <li>Cache Hit: The desired scenario; everything was entirely served from cache and no network was    used.</li> <li>Conditional Cache Hit: The cache had to contact the origin to revalidate its copy of the    response and the server decided it was valid. The cache uses server's response to update some     metadata in background. Response payload isn't downloaded so network is used efficiently.</li> <li>Cache Miss: Either the cache had no matching response or the server decided such response is    too stale to be server. In both cases, the whole response is fetched from network.    This is when the cache populates or updates its entries if appropriate.</li> </ul>"},{"location":"caching/#cacheawareresponse","title":"CacheAwareResponse","text":"<p><code>CacheAwareResponse</code> complements <code>HttpResponse</code> to better reflect cache interference. If a cache is installed, any <code>HttpResponse&lt;T&gt;</code> returned by <code>Methanol</code> is also a <code>CacheAwareResponse&lt;T&gt;</code>, which you can use to know which of the previous scenarios was the case.</p> <pre><code>var cache = HttpCache.newBuilder()\n    .cacheOnDisk(Path.of(\".cache\"), 500 * 1024 * 1024)\n    .build();\nvar client = Methanol.newBuilder()\n    .cache(cache)\n    .build();\n\nvar response = (CacheAwareResponse&lt;Path&gt;) client.send(\n    MutableRequest.GET(\"https://i.imgur.com/NYvl8Sy.mp4\"), BodyHandlers.ofFile(Path.of(\"banana_cat.mp4\")));\n\nvar timeElapsed  = Duration.between(response.timeRequestSent(), response.timeResponseReceived());\nSystem.out.println(\"Time elapsed: \" + timeElapsed);\n\n// networkResponse &amp; cacheResponse are optional HttpResponses that you can further investigate\nvar networkResponse = response.networkResponse();\nvar cacheResponse = response.cacheResponse();\nswitch (response.cacheStatus()) {\n  case HIT:\n    assert networkResponse.isEmpty();\n    assert cacheResponse.isPresent();\n    break;\n\n  case CONDITIONAL_HIT:\n    assert networkResponse.isPresent();\n    assert cacheResponse.isPresent();\n    break;\n\n  case MISS:\n    assert networkResponse.isPresent();\n    // cacheResponse can be absent or present\n    break;\n\n  case UNSATISFIABLE:\n    // Network was forbidden by only-if-cached but there was no valid cache response\n    assert response.statusCode() == HttpURLConnection.HTTP_GATEWAY_TIMEOUT;\n    assert networkResponse.isEmpty();\n    // cacheResponse can be absent or present\n    break;\n}\n\ncache.close();\n</code></pre>"},{"location":"caching/#httpcachestats","title":"HttpCache.Stats","text":"<p>You can examine cache statistics to measure its effectiveness. Statistics are either global or correspond to a specific <code>URI</code>.</p> Global StatsURI-specific Stats <pre><code>var cache = HttpCache.newBuilder()\n    .cacheOnDisk(Path.of(\".cache\"), 500 * 1024 * 1024)\n    .build();\n\nvar stats = cache.stats();\nSystem.out.println(stats.hitRate());\nSystem.out.println(stats.missRate());\n</code></pre> <pre><code>// Per URI statistics aren't recoded by default\nvar cache = HttpCache.newBuilder()\n    .cacheOnDisk(Path.of(\".cache\"), 500 * 1024 * 1024)\n    .statsRecorder(StatsRecorder.createConcurrentPerUriRecorder())\n    .build();\n\nvar stats = cache.stats(URI.create(\"https://i.imgur.com/NYvl8Sy.mp4\"));\nSystem.out.println(stats.hitRate());\nSystem.out.println(stats.missRate());\n</code></pre> <p>See <code>HttpCache.Stats</code> for all recorded statistics.</p>"},{"location":"caching/#limitations","title":"Limitations","text":"<ul> <li>The cache only stores responses to GETs. This is typical for most caches.</li> <li>The cache never stores partial responses.  </li> <li>Only the most recent response variant can be stored.</li> <li>The cache doesn't store responses that have a <code>Vary</code> header with any of the values: <code>Cookie</code>,   <code>Cookie2</code>, <code>Authorization</code>, <code>Proxy-Authroization</code>. The first two if the client has a configured   <code>CookieHandler</code>, the latter two if the client has a configured <code>Authentciator</code>. That's because   <code>HttpClient</code> can implicitly add these to requests, so Methanol won't be able to access their   values to match requests against.</li> </ul>"},{"location":"decompression/","title":"Response Decompression","text":"<p>One caveat concerning Java's HTTP client is the lack of support for automatic response decompression. A workaround is to use an available <code>InputStream</code> decompressor (e.g. <code>GZIPInputStream</code>) that matches response's <code>Content-Encoding</code>. However, such approach is invasive as it forces you to deal with <code>InputStreams</code>.</p> <p>The straightforward and recommended solution is to use Methanol's HTTP client, which gives you transparent response decompression for <code>gzip</code> &amp; <code>deflate</code> out of the box.</p> <pre><code>final Methanol client = Methanol.create();\n\n&lt;T&gt; HttpResponse&lt;T&gt; get(String url, BodyHandler&lt;T&gt; bodyHandler) throws IOException, InterruptedException {\n  // No need to worry about adding Accept-Encoding and decompressing the response, the client does that for you!\n  return client.send(MutableRequest.GET(url), bodyHandler);\n}\n</code></pre> <p>Read on if you're interested in knowing how that's accomplished, or you want to extend decompression support.</p>"},{"location":"decompression/#decoding-bodyhandler","title":"Decoding BodyHandler","text":"<p>The entry point to response body decompression is <code>MoreBodyHandlers::decoding</code>. This method takes your desired <code>BodyHandler</code> and gives you one that decompresses the response body as your handler's <code>BodySubscriber</code> receives it.</p> <pre><code>var response = client.send(request, MoreBodyHandlers.decoding(BodyHandlers.ofString()));\n</code></pre> <p>It doesn't matter which <code>BodyHandler</code> you're using; you can have whatever response body type you want.</p>"},{"location":"decompression/#bodydecoder","title":"BodyDecoder","text":"<p>A <code>BodyDecoder</code> is a <code>BodySubscriber</code> with the added semantics of a <code>Flow.Processor</code>. It intercepts the flow of bytes on its way down from the HTTP client, decoding each <code>List&lt;ByteBuffer&gt;</code> individually. The decoded bytes are forwarded to a downstream <code>BodySubscriber</code>, which converts them into the desired response body.</p>"},{"location":"decompression/#bodydecoderfactory","title":"BodyDecoder.Factory","text":"<p>A <code>BodyDecoder.Factory</code> associates itself with a defined encoding that's suitable as a <code>Content-Encoding</code> directive. It creates <code>BodyDecoder</code> instances that forward the decompressed response body to a downstream <code>BodySubscriber</code>.</p> <p>Factories are installed as service-providers in the manner specified by Java's <code>ServiceLoader</code>. The handler returned by <code>MoreBodyHandlers::decoding</code> looks up a factory matching the response's <code>Content-Encoding</code> to wrap user's <code>BodySubscriber</code>. If no such factory is found, an <code>UnsupportedOperationException</code> is thrown.</p>"},{"location":"decompression/#supported-encodings","title":"Supported Encodings","text":"<p>The core module has support for <code>gzip</code> &amp; <code>deflate</code> out of the box. There's also a separate module for brotli.</p>"},{"location":"decompression/#extending-decompression-support","title":"Extending decompression support","text":"<p>Adding support for more encodings or overriding supported ones is a matter of writing a <code>BodyDecoder</code> implementation and providing a corresponding factory. However, implementing the decoder's <code>Flow.Publisher</code> semantics can be tricky. Instead, implement an <code>AsyncDecoder</code> and wrap it in an <code>AsyncBodyDecoder</code>, so you're only concerned with the decompression logic.</p>"},{"location":"decompression/#writing-an-asyncdecoder","title":"Writing an AsyncDecoder","text":"<p>Decoding is done as a number of <code>decode(source, sink)</code> rounds finalized by one final round, each with the currently available input. After the final round, your <code>AsyncDecoder</code> must've completely exhausted its source. Here's a decoder implementation that uses jzlib for <code>gzip</code> &amp; <code>deflate</code> decompression.</p> <pre><code>class JZlibDecoder implements AsyncDecoder {\n  private static final int BUFFER_SIZE = 8096;\n\n  private final String encoding;\n  private final com.jcraft.jzlib.Inflater inflater;\n  private final ByteBuffer input = ByteBuffer.allocate(BUFFER_SIZE);\n  private final ByteBuffer output = ByteBuffer.allocate(BUFFER_SIZE);\n\n  JZlibDecoder(String encoding, com.jcraft.jzlib.JZlib.WrapperType wrapperType) {\n    try {\n      this.encoding = encoding;\n      inflater = new com.jcraft.jzlib.Inflater(wrapperType);\n      inflater.setInput(input.array());\n      inflater.setOutput(output.array());\n    } catch (com.jcraft.jzlib.GZIPException e) {\n      throw new RuntimeException(e);\n    }\n  }\n\n  @Override\n  public String encoding() {\n    return encoding;\n  }\n\n  @Override\n  public void decode(ByteSource source, ByteSink sink) throws IOException {\n    synchronized (inflater) {\n      while (source.hasRemaining()) {\n        // Prepare input for this iteration\n        refillInput(source);\n        inflater.setNextInIndex(0);\n        inflater.setAvailIn(input.limit());\n\n        // Continue inflating as long as there's more input or there's pending output\n\n        boolean mightHavePendingOutput = false;\n\n        inflateLoop:\n        while (inflater.getAvailIn() &gt; 0 || mightHavePendingOutput) {\n          // Prepare for new output\n          inflater.setNextOutIndex(0);\n          inflater.setAvailOut(output.capacity());\n\n          int status = inflater.inflate(com.jcraft.jzlib.JZlib.Z_SYNC_FLUSH);\n          int outputCount = inflater.getNextOutIndex();\n          sink.pushBytes(output.position(0).limit(outputCount));\n\n          switch (status) {\n            case com.jcraft.jzlib.JZlib.Z_OK:\n              mightHavePendingOutput = inflater.getAvailOut() == 0;\n              break;\n\n            case com.jcraft.jzlib.JZlib.Z_STREAM_END:\n              // The compressed stream has ended\n              break inflateLoop;\n\n            default:\n              throw new IOException(\"problem with zlib: \" + Integer.toHexString(status));\n          }\n        }\n      }\n    }\n  }\n\n  private void refillInput(ByteSource source) {\n    input.clear();\n    source.pullBytes(input);\n    input.flip();\n  }\n\n  @Override\n  public synchronized void close() {\n    synchronized (inflater) {\n      inflater.end();\n    }\n  }\n}\n</code></pre>"},{"location":"decompression/#registering-a-factory","title":"Registering a Factory","text":"<p>Here's a <code>BodyDecoder.Factory</code> for <code>gzip</code> using our jzlib decoder.</p> <pre><code>public static final class MyDecoderFactory implements BodyDecoder.Factory {\n  @Override\n  public String encoding() {\n    return \"gzip\";\n  }\n\n  @Override\n  public &lt;T&gt; BodyDecoder&lt;T&gt; create(BodySubscriber&lt;T&gt; downstream) {\n    return new AsyncBodyDecoder&lt;&gt;(\n        new JZlibDecoder(\"gzip\", com.jcraft.jzlib.JZlib.WrapperType.GZIP), downstream);\n  }\n\n  @Override\n  public &lt;T&gt; BodyDecoder&lt;T&gt; create(BodySubscriber&lt;T&gt; downstream, Executor executor) {\n    return new AsyncBodyDecoder&lt;&gt;(\n        new JZlibDecoder(\"gzip\", com.jcraft.jzlib.JZlib.WrapperType.GZIP), downstream);\n  }\n}\n</code></pre> <p>The next step is to declare your factory as a service-provider. If your application uses Java modules, you'd have a declaration like the following in your <code>module-info.java</code>.</p> <pre><code>module my.module {\n  ...\n\n  provides BodyDecoder.Factory with MyDecoderFactory;\n}\n</code></pre>"},{"location":"interceptors/","title":"Interceptors","text":"<p>Interceptors allow you to inspect, mutate, retry and short-circuit HTTP calls. Together, interceptors build an invocation chain that's capable of applying powerful transformations to requests moving forward and to responses in their way back.</p>"},{"location":"interceptors/#writing-interceptors","title":"Writing Interceptors","text":"<p>Interceptors sit between a <code>Methanol</code> client and its underlying <code>HttpClient</code>, referred to as its backend. When registered, an interceptor is invoked each <code>send</code> or <code>sendAsync</code> call. Here's an interceptor that logs requests and their responses.</p> <pre><code>public final class LoggingInterceptor implements Methanol.Interceptor {\n  private static final Logger logger = Logger.getLogger(LoggingInterceptor.class.getName());\n\n  @Override\n  public &lt;T&gt; HttpResponse&lt;T&gt; intercept(HttpRequest request, Chain&lt;T&gt; chain)\n      throws IOException, InterruptedException {\n    logRequest(request);\n    return toLoggingChain(request, chain).forward(request);\n  }\n\n  @Override\n  public &lt;T&gt; CompletableFuture&lt;HttpResponse&lt;T&gt;&gt; interceptAsync(\n      HttpRequest request, Chain&lt;T&gt; chain) {\n    logRequest(request);\n    return toLoggingChain(request, chain).forwardAsync(request);\n  }\n\n  private static void logRequest(HttpRequest request) {\n    logger.info(() -&gt; String.format(\"Sending %s%n%s\", request, headersToString(request.headers())));\n  }\n\n  private static &lt;T&gt; Chain&lt;T&gt; toLoggingChain(HttpRequest request, Chain&lt;T&gt; chain) {\n    var sentAt = Instant.now();\n    return chain.withBodyHandler(responseInfo -&gt; {\n        logger.info(() -&gt; String.format(\n            \"Completed %s %s with %d in %sms%n%s\",\n            request.method(),\n            request.uri(),\n            responseInfo.statusCode(),\n            Duration.between(sentAt, Instant.now()).toMillis(),\n            headersToString(responseInfo.headers())));\n\n        // Apply the original BodyHandler\n        return chain.bodyHandler().apply(responseInfo);\n    });\n  }\n\n  private static String headersToString(HttpHeaders headers) {\n    return headers.map().entrySet().stream()\n        .map(entry -&gt; entry.getKey() + \": \" + String.join(\", \", entry.getValue()))\n        .collect(Collectors.joining(System.lineSeparator()));\n  }\n}\n</code></pre> <p><code>HttpClient</code> has blocking and asynchronous APIs, so interceptors must implement two methods matching each. An interceptor is given a <code>Chain&lt;T&gt;</code> so it can forward requests to its next sibling, or to the backend in case there are no more interceptors in the chain. The backend is where requests finally get sent. Typically, an interceptor calls its chain's <code>forward</code> or <code>forwardAsync</code> after it has done its job.</p> <p>If your interceptor only modifies requests, prefer passing a lambda to <code>Interceptor::create</code>.</p> <pre><code>// Enable 'Expect: Continue' for all POSTs to a particular host\nvar expectContinueInterceptor = Interceptor.create(request -&gt;\n    request.method().equalsIgnoreCase(\"POST\") &amp;&amp; request.uri().getHost().equals(\"api.imgur.com\")\n        ? MutableRequest.copyOf(request).expectContinue(true)\n        : request);\n</code></pre>"},{"location":"interceptors/#intercepting-bodies","title":"Intercepting Bodies","text":"<p>A powerful property of interceptors is their control over how responses are received by their caller. An interceptor can transform its chain's <code>BodyHandler</code> before it forwards requests. A transformed <code>BodyHandler</code> typically applies the handler the chain previously had, then wraps the resulted <code>BodySubscriber</code>, so it intercepts the response body as it's being received by the caller. This is how <code>Methanol</code> does transparent decompression &amp; cache writes.</p> <p>Note that this applies to requests too. You can transform a request body by wrapping its <code>BodyPublisher</code>. <code>BodyPublisher</code> &amp; <code>BodySubscriber</code> APIs can be nicely layered to apply different transformations.</p>"},{"location":"interceptors/#invocation-order","title":"Invocation Order","text":"<p>An interceptor can be either a client or a backend interceptor. Client interceptors sit between the application and <code>Methanol</code>'s internal interceptors. They are called as soon as the client receives a request. Backend interceptors sit between <code>Methanol</code> and its backend <code>HttpClient</code>. They get invoked right before the request gets sent. This has a number of implications.</p>"},{"location":"interceptors/#client-interceptors","title":"Client Interceptors","text":"<ul> <li>See the request just as received from the application.</li> <li>Their transformed <code>BodyHandler</code> receives the response body after the client applies its    decompressing &amp; cache writing handlers.</li> </ul>"},{"location":"interceptors/#backend-interceptors","title":"Backend Interceptors","text":"<ul> <li>Observe the request after the client applies things like the base URI and default headers.   Additionally, they see intermediate headers added by the client or the cache like <code>Accept-Encoding</code> &amp; <code>If-None-Math</code>.</li> <li>Receive the response body just as transmitted by the backend. For instance, a transformed   <code>BodyHandler</code> receives a compressed body if the response comes with a <code>Content-Encoding</code> header.</li> <li>May not always be invoked. This is the case when a cache decides it doesn't need network and hence   doesn't proceed the call to the backend.</li> </ul> <p>Attention</p> <p>If a cache is installed, <code>Methanol</code> does automatic redirection by itself, which would otherwise be done by the backend. This allows redirects to be cached, increasing cache efficiency. As a consequence, backend interceptors may get invoked more than once in the presence of a cache.</p>"},{"location":"interceptors/#registration","title":"Registration","text":"<p>You can register client and backend interceptors with <code>interceptor(...)</code> and <code>backendInterceptor(...)</code> respectively. Interceptors in each group get invoked in registration order.</p> Client InterceptorsBackend Interceptors <pre><code>var client = Methanol.newBuilder()\n    .interceptor(new LoggingInterceptor())\n    .build();\n</code></pre> <pre><code>var client = Methanol.newBuilder()\n    .backendInterceptor(new LoggingInterceptor())\n    .build();\n</code></pre>"},{"location":"interceptors/#short-circuiting","title":"Short-circuiting","text":"<p>Both client &amp; backend interceptors can refrain from forwarding a request. They're allowed to short-circuit a request's path by returning a fabricated response. This makes them good candidates for testing. You can mock responses with client interceptors to investigate requests just as sent by your application. Moreover, responses can be mocked with backend interceptors to explore requests as they get sent. This makes backend interceptors suitable for testing how your application interacts with the cache.</p>"},{"location":"interceptors/#limitations","title":"Limitations","text":"<p>Remember that <code>Methanol</code> is built atop a standard <code>HttpClient</code>, which can perform its own redirects, retries and other intermediate requests like authentications. These aren't interceptable. That's because <code>HttpClient</code> exports no API to do so.</p>"},{"location":"kotlin/","title":"methanol-kotlin","text":"<p>Kotlin extensions for Methanol, which include:</p> <ul> <li>A DSL for HTTP requests.</li> <li>Adapters for Kotlin Serialization.</li> </ul>"},{"location":"kotlin/#installation","title":"Installation","text":""},{"location":"kotlin/#gradle","title":"Gradle","text":"<pre><code>implementation(\"com.github.mizosoft.methanol:methanol-kotlin:1.8.3\")\n</code></pre>"},{"location":"kotlin/#usage","title":"Usage","text":"<p>Most types and functions in this module are defined as type aliases and extension functions to core Methanol &amp; JDK HTTP client libraries. They have a different, more Kotlin-like feel, however. The best way to get familiar is to go through the examples. There's also the KDocs for a comprehensive list of what is provided. For advanced usage, it's a good idea to be familiar with the Java libraries this module extends.</p> <p>Almost everything in this module is configured with lambda expressions that are resolved against a particular Spec. Look up the KDocs/source of a spec to know all what it can configure.</p> <p>Runnable code examples are linked at the end of each section. If you're going to copy from the snippets, add these imports:</p> <pre><code>import com.github.mizosoft.methanol.*\nimport com.github.mizosoft.methanol.kotlin.*\n</code></pre>"},{"location":"kotlin/#get-post-string","title":"Get &amp; Post String","text":"<p>Let's get started by creating our client.</p> <pre><code>val client = Client {\n  adapterCodec {\n    basic()\n  }\n}\n</code></pre> <p>Here, we're configuring a ClientSpec. The only thing we'll configure for now is the client's <code>AdapterCodec</code>, which tells it how to map high level types to &amp; from HTTP bodies. <code>basic()</code> is good enough for, well, basic types, like <code>String</code> &amp; <code>InputStream</code>. Trace through <code>basicEncoder</code> &amp; <code>basicDecoder</code> for all the supported basic types.</p>"},{"location":"kotlin/#get-string","title":"Get String","text":"<p>Now let's GET a string from a URL.</p> <pre><code>suspend fun runGet() {\n  val response = client.get&lt;String&gt;(\"https://www.cl.cam.ac.uk/~mgk25/ucs/examples/UTF-8-demo.txt\")\n  require(response.isSuccessful()) { \"Unsuccessful response: $response - ${response.body()}\" }\n  println(response.body())\n}\n</code></pre> <p>Known HTTP verbs have corresponding client-defined functions, like the <code>client::get</code> above. Each HTTP verb function returns a <code>Response</code> whose <code>Response::body</code> is already converted into the specified type. These functions are suspending, meaning they run as part of a coroutine.</p>"},{"location":"kotlin/#post-string","title":"Post String","text":"<p>HTTP verb functions take an optional request configuration block next to the URI. We can use it to specify the body of body-bearing requests.</p> <pre><code>suspend fun runPost() {\n  val response: Response&lt;String&gt; = client.post(\"https://api.github.com/markdown/raw\") {\n    body(\n      \"\"\"\n        &gt; He who has a ***why*** can bear almost any ***how***.\n        &gt;  - Friedrich Nietzsche\n      \"\"\".trimIndent(),\n      MediaType.TEXT_MARKDOWN\n    )\n  }\n  require(response.isSuccessful()) { \"Unsuccessful response: $response - ${response.body()}\" }\n  println(response.body())\n}\n</code></pre> <p>Next to what we want to send, we pass <code>body</code> a <code>MediaType</code> signifying the desired mapping format. This <code>MediaType</code> becomes the request's <code>Content-Type</code>.</p> <p>Note that we specified the response body type on the left of <code>client.post(...)</code>. We could have written <code>val response = client.post&lt;String&gt;(...)</code>, but that can hurt readability since <code>String</code> in this expression is what we're getting, not what we're posting; the latter is defined by <code>body</code>. You can use either way, though.</p> <p>Runnable Example.</p>"},{"location":"kotlin/#get-post-json","title":"Get &amp; Post JSON","text":"<p>Let's get more sophisticated. The basic adapter is nice, but it ain't much. We can make the client understand JSON through Kotlin Serialization. You'll first need to apply the serialization plugin in your build script &amp; pull in <code>kotlinx-serialization-json</code> as specified here.</p> <p>Now we redefine our client.</p> <pre><code>val client = Client {\n  baseUri(\"https://api.github.com/\")\n  defaultHeaders {\n    \"Accept\" to \"application/vnd.github+json\"\n    \"X-GitHub-Api-Version\" to \"2022-11-28\"\n  }\n  adapterCodec {\n    basic()\n    +KotlinAdapter.Encoder(\n      Json, MediaType.APPLICATION_JSON\n    )\n    +KotlinAdapter.Decoder(Json {\n      ignoreUnknownKeys = true // For brevity, we'll skip most fields.\n    }, MediaType.APPLICATION_JSON)\n  }\n}\n</code></pre> <p>This time our client has more configuration, most of which is self-descriptive. The interesting part is how we configure the <code>AdapterCodec</code>. We add (hence the <code>+</code>) an encoder &amp; a decoder that use <code>kotlinx-serialization-json</code>'s <code>Json</code>. <code>KotlinAdapter.Encoder</code> &amp; <code>KotlinAdapter.Decoder</code> are pluggable, and hence can work with all the supported formats. You'll just need to pass the desired SerialFormat, and one or more <code>MediaType</code>s signifying that format.</p> <p>Note that we keep the basic adapter to still be able to send &amp; receive basic types. <code>AdapterCodec</code> will figure out which adapter to use. You can also add adapters for other formats, say <code>application/protobuf</code>. The first adapter (in addition order) that can handle the object type based on the given <code>MediaType</code> is selected.</p>"},{"location":"kotlin/#get-json","title":"Get JSON","text":"<p>Now it's a matter of type specification.</p> <pre><code>@Serializable\ndata class Repository(\n  val description: String,\n  @SerialName(\"full_name\") val fullName: String\n)\n\nsuspend fun runGet() {\n  val response = client.get&lt;List&lt;Repository&gt;&gt;(\"users/mizosoft/starred?per_page=10\")\n  response.body().forEach { repo -&gt;\n    println(\"${repo.fullName}\\n\\t${repo.description}\")\n  }\n}\n</code></pre>"},{"location":"kotlin/#post-json","title":"Post JSON","text":"<p>For posts, specify the <code>MediaType</code> next to your payload.</p> <pre><code>@Serializable\ndata class Markdown(\n  val text: String,\n  val context: String,\n  val mode: String\n)\n\nsuspend fun runPost() {\n  val response: Response&lt;String&gt; = client.post(\"markdown\") {\n    body(\n      Markdown(\n        \"this code very fast: #437\",\n        \"torvalds/linux\",\n        \"gfm\"\n      ),\n      MediaType.APPLICATION_JSON\n    )\n  }\n  println(response.body())\n}\n</code></pre> <p>[Runnable Example](Runnable Example.</p>"},{"location":"kotlin/#multipart-forms","title":"Multipart &amp; Forms","text":"<p>Now let's say we want to upload some cat memes to Imgur using their API.</p>"},{"location":"kotlin/#multipart-bodies","title":"Multipart Bodies","text":"<p><code>multipart/format-data</code> bodies are perfect for that task. We'll be making use of the JSON decoder from above to extract the image link.</p> <pre><code>// You can get your own clien ID here: https://api.imgur.com/oauth2/addclient.\nval imgurClientId = System.getProperty(\"imgur.client.id\")\n\nval client = Client {\n  baseUri(\"https://api.imgur.com/3/\")\n  defaultHeaders {\n    \"Authorization\" to \"Client-ID $imgurClientId\"\n  }\n\n  adapterCodec {\n    basic()\n    +KotlinAdapter.Decoder(Json {\n      ignoreUnknownKeys = true\n    }, MediaType.APPLICATION_JSON)\n  }\n}\n\n@Serializable\ndata class ImgurResponse&lt;T&gt;(val status: Int, val success: Boolean, val data: T?)\n\n@Serializable\ndata class Image(val link: String)\n\nsuspend fun multipartUpload() {\n  val response: Response&lt;ImgurResponse&lt;Image&gt;&gt; = client.post(\"image\") {\n    multipartBody {\n      \"image\" to Path.of(\"images/popcat.gif\") // File's Content-Type will be looked-up automatically.\n      \"title\" to \"PopCat\"\n      \"description\" to \"A cat that pops\"\n    }\n  }\n  require(response.body().success) {\n    \"Unsuccessful response: $response - ${response.body()}\"\n  }\n  println(\"Uploaded: ${response.body().data!!.link}\")\n}\n</code></pre> <p>The <code>multipartBody</code> block makes it easy to configure <code>multipart/form-data</code> bodies as key-value pairs. It can also be used to configure any kind of <code>multipart/*</code> body.</p>"},{"location":"kotlin/#form-bodies","title":"Form Bodies","text":"<p>It turns out that Imgur's upload API also accepts <code>application/x-www-form-urlencoded</code> submissions, which may result in more efficient uploads if we have the image bytes in memory. <code>formBody</code> is here to help.</p> <pre><code>@OptIn(ExperimentalEncodingApi::class) // In order to use Kotlin's Base64.\nsuspend fun formUpload() {\n  val response: Response&lt;ImgurResponse&lt;Image&gt;&gt; = client.post(\"image\") {\n    formBody {\n      \"image\" to Base64.Default.encode(Path.of(\"images/popcat.gif\").readBytes())\n      \"type\" to \"base64\"\n      \"title\" to \"PopCat\"\n      \"description\" to \"A cat that pops\"\n    }\n  }\n  require(response.body().success) {\n    \"Unsuccessful response: $response - ${response.body()}\"\n  }\n  println(\"Uploaded: ${response.body().data!!.link}\")\n}\n</code></pre> <p>When using <code>multipartBody</code> or <code>formBody</code>, the request's <code>Content-Type</code> will be set for you.</p> <p>Runnable Example.</p>"},{"location":"kotlin/#caching","title":"Caching","text":"<p>Methanol provides an HTTP caching solution, which supports disk, memory &amp; redis storage backends.</p> <pre><code>val client = Client {\n  userAgent(\"Chuck Norris\")\n  cache {\n    onDisk(Path.of(\".cache\"), 500 * 1024 * 1024) // Occupy at most 500Mb on disk.\n  }\n}\n</code></pre> <p>The cache will be used automatically as you use the client. You can communicate with it using request's <code>Cache-Control</code>.</p> <pre><code>suspend fun run() {\n  val response =\n    client.get(\"https://i.imgur.com/V79ulbT.gif\", BodyHandlers.ofFile(Path.of(\"popcat.gif\"))) {\n      cacheControl {\n        maxAge(5.seconds) // Override server's max-age.\n      }\n    } as CacheAwareResponse&lt;Path&gt;\n  println(\n    \"$response - ${response.cacheStatus()} (Cached for ${response.headers()[\"Age\"].firstOrNull() ?: -1} seconds)\"\n  )\n}\n</code></pre> <p>Run this example multiple times within 5 seconds and then apart.</p> <p>You can also set up a chain of caches, typically in the order of decreasing locality.</p> <pre><code>val redisUrl = System.getProperty(\"redis.url\")\n\nval client = Client {\n  userAgent(\"Chuck Norris\")\n  cacheChain {\n    +Cache {\n      inMemory(100 * 1024 * 1024) // Occupy at most 100Mb in memory.\n    }\n    +Cache {\n      onDisk(500 * 1024 * 204) // Occupy at most 500Mb on disk.\n    }\n  }\n}\n</code></pre> <p>Here, we're calling the <code>Cache</code> constructor, and prepend a <code>+</code> to add it to the chain. The chain is invoked in the order of addition.</p> <p>In case of a single cache or a cache chain, it's always a good practice to close it when you're done.</p> <pre><code>client.caches().close()\n</code></pre> <p>You can learn more about caching here.</p> <p>Runnable Example.</p>"},{"location":"kotlin/#interceptors","title":"Interceptors","text":"<p>So far, if we wanted to validate the response, we had to do so each time we get it. We may also want to log the request/response exchange, or send some metrics to a monitoring framework. This is a perfect usage for interceptors.</p> <pre><code>object LoggingInterceptor : Interceptor {\n  val logger: System.Logger = System.getLogger(LoggingInterceptor::class.simpleName)\n  val requestIdGenerator = AtomicInteger()\n\n  override suspend fun &lt;T&gt; intercept(\n    request: Request,\n    chain: Interceptor.Chain&lt;T&gt;\n  ): Response&lt;T&gt; {\n    val requestId = requestIdGenerator.getAndIncrement()\n    val start = System.currentTimeMillis()\n    logger.log(Level.INFO) {\n      \"$requestId: sending $request \\n${request.headers().toHttpString()}\"\n    }\n\n    return chain.forward(request).also { response -&gt;\n      logger.log(Level.INFO) {\n        \"$requestId: received $response in ${(System.currentTimeMillis() - start).milliseconds} \\n\" +\n            request.headers().toHttpString()\n      }\n      require(response.isSuccessful()) { \"Unsuccessful response: $response\" }\n    }\n  }\n}\n\nval client = Client {\n  interceptors {\n    +LoggingInterceptor\n  }\n\n  userAgent(\"Dave Bautista\")\n  adapterCodec {\n    basic()\n  }\n}\n\nsuspend fun run() {\n  client.get&lt;Unit&gt;(\"https://httpbin.org/gzip\") {\n    headers {\n      \"Accept\" to MediaType.APPLICATION_OCTET_STREAM.toString()\n    }\n  }\n}\n</code></pre> <p>More than one interceptor can be added. Together, they form a chain that is invoked in the order of addition.</p> <p>Running this code gives:</p> <pre><code>Dec 06, 2024 1:10:47 PM com.github.mizosoft.methanol.samples.kotlin.ClientInterceptor$LoggingInterceptor intercept\nINFO: 0: sending https://httpbin.org/gzip GET\nAccept: application/octet-stream\n\nDec 06, 2024 1:10:48 PM com.github.mizosoft.methanol.samples.kotlin.ClientInterceptor$LoggingInterceptor intercept\nINFO: 0: received (GET https://httpbin.org/gzip) 200 in 1.631s\n:status: 200\naccess-control-allow-credentials: true\naccess-control-allow-origin: *\ncontent-type: application/json\ndate: Fri, 06 Dec 2024 11:10:48 GMT\nserver: gunicorn/19.9.0\n</code></pre> <p>If you squint, you'll notice that the request headers don't contain a <code>User-Agent</code>, although we've configured the client with one. Additionally, the response lacks typical headers like <code>Content-Length</code> &amp; <code>Content-Encoding</code>.</p> <p>Let's instead add <code>LoggingInterceptor</code> as what we'll call a backend interceptor.</p> <pre><code>val client = Client {\n  backendInterceptors {\n    +LoggingInterceptor\n  }\n\n  userAgent(\"Arnold Schwarzenegger\")\n  adapterCodec {\n    basic()\n  }\n}\n</code></pre> <p>Running this code gives:</p> <pre><code>Dec 06, 2024 2:02:55 PM com.github.mizosoft.methanol.samples.kotlin.ClientInterceptor$LoggingInterceptor intercept\nINFO: 0: sending https://httpbin.org/gzip GET\nAccept: application/octet-stream\nAccept-Encoding: deflate, gzip\nUser-Agent: Dave Bautista\n\nDec 06, 2024 2:02:56 PM com.github.mizosoft.methanol.samples.kotlin.ClientInterceptor$LoggingInterceptor intercept\nINFO: 0: received (GET https://httpbin.org/gzip) 200 in 1.602s\n:status: 200\naccess-control-allow-credentials: true\naccess-control-allow-origin: *\ncontent-encoding: gzip\ncontent-length: 241\ncontent-type: application/json\ndate: Fri, 06 Dec 2024 12:02:56 GMT\nserver: gunicorn/19.9.0\n</code></pre> <p>Now we can see a <code>User-Agent</code>, an <code>Accept-Encoding</code> added implicitly by the client, and the typical response headers.</p> <p>Client interceptors (which we added first within the <code>interceptors</code> block) see the request just as given to the client, and the response after the client does some changes (e.g. decompression). Backend interceptors see the request just before sending it, and the response just as received.</p> <p>Note that Kotlin's <code>Interceptor</code> is a different interface from core library's <code>Methanol.Interceptor</code>. This is so that Kotlin's interceptors can support coroutines; they are functionally the same, however. You can learn more about interceptors here.</p> <p>Runnable Example.</p>"},{"location":"kotlin/#coroutines","title":"Coroutines","text":"<p>HTTP verb functions are suspending, which is also the case with <code>Interceptor::intercept</code>. In fact, the entire interceptor chain along with the ultimate HTTP call all share the same coroutine context. This implies that cancelling the HTTP call also cancels whatever some interceptor is doing.</p> <pre><code>val client = Client {\n  interceptors {\n    +object : Interceptor {\n      override suspend fun &lt;T&gt; intercept(\n        request: Request,\n        chain: Interceptor.Chain&lt;T&gt;\n      ): Response&lt;T&gt; {\n        println(\"Invoking interceptor with ${coroutineContext[CoroutineName]}\")\n        return try {\n          delay(1000L)\n          chain.forward(request)\n        } catch (e: CancellationException) {\n          println(\"Cancelled interceptor\")\n          throw e\n        }\n      }\n    }\n  }\n\n  adapterCodec {\n    basic()\n  }\n}\n\nfun run() {\n  runBlocking(CoroutineName(\"MyCoroutine\")) {\n    val job = launch {\n      client.get&lt;String&gt;(\"https://httpbin.org/get\")\n    }\n    delay(500)\n    job.cancel()\n  }\n}\n</code></pre> <p>Running the code gives the following output.</p> <pre><code>Calling interceptor with CoroutineName(MyCoroutine)\nCancelled interceptor\n</code></pre>"},{"location":"legacy_adapters/","title":"Legacy Adapters","text":"<p>Before version 1.8.0, adapters were required to be registered as service providers and used through static methods, instead of being bundled in a per-client <code>AdapterCodec</code>. The latter is the recommended way to use adapters. The legacy way is not deprecated but might be in the future.</p>"},{"location":"legacy_adapters/#compatibility","title":"Compatibility","text":"<p>If you have adapters installed as service providers, they can still be used with the newer, non-static APIs.</p> <pre><code>record Person(String name) {}\n\n// The client will fall back to an AdapterCodec of installed adapters, if any.\nvar client = Methanol.create();\nvar response = client.send(\n    MutableRequest.POST(\".../echo\", new Person(\"Bruce Lee\"), MediaType.APPLICATION_JSON),\n    Person.class);\nassertThat(response.body()).isEqualTo(new Person(\"Bruce Lee\"));\n</code></pre>"},{"location":"legacy_adapters/#installation","title":"Installation","text":"<p>The legacy way to register adapters is through service providers. How this is done depends on your project setup. We'll use <code>methanol-jackson</code> as an example.</p>"},{"location":"legacy_adapters/#module-path","title":"Module Path","text":"<p>Follow these steps if your project uses the Java module system.</p> <ol> <li> <p>Add this class to your module:</p> <pre><code>public class JacksonJsonProviders {\n  private static final ObjectMapper mapper = new ObjectMapper();\n\n  public static class EncoderProvider {\n    public static BodyAdapter.Encoder provider() {\n      return JacksonAdapterFactory.createJsonEncoder(mapper);\n    }\n  }\n\n  public static class DecoderProvider {\n    public static BodyAdapter.Decoder provider() {\n      return JacksonAdapterFactory.createJsonDecoder(mapper);\n    }\n  }\n}\n</code></pre> </li> <li> <p>Add the corresponding provider declarations in your <code>module-info.java</code> file.</p> <pre><code>requires methanol.adapter.jackson;\n\nprovides BodyAdapter.Encoder with JacksonJsonProviders.EncoderProvider;\nprovides BodyAdapter.Decoder with JacksonJsonProviders.DecoderProvider;\n</code></pre> </li> </ol>"},{"location":"legacy_adapters/#classpath","title":"Classpath","text":"<p>Registering adapters from the classpath requires declaring the implementation classes in provider-configuration files that are bundled with your JAR. You'll first need to implement delegating <code>Encoder</code> &amp; <code>Decoder</code> that forward to the instances created by <code>JacksonAdapterFactory</code>. Extending from <code>ForwardingEncoder</code> &amp; <code>ForwardingDecoder</code> makes this easier.</p> <p>You can use Google's AutoService to generate the provider-configuration files automatically.</p>"},{"location":"legacy_adapters/#using-autoservice","title":"Using AutoService","text":"<p>First, install AutoService.</p>"},{"location":"legacy_adapters/#gradle","title":"Gradle","text":"<pre><code>implementation \"com.google.auto.service:auto-service-annotations:$autoServiceVersion\"\nannotationProcessor \"com.google.auto.service:auto-service:$autoServiceVersion\"\n</code></pre>"},{"location":"legacy_adapters/#maven","title":"Maven","text":"<pre><code>&lt;dependency&gt;\n  &lt;groupId&gt;com.google.auto.service&lt;/groupId&gt;\n  &lt;artifactId&gt;auto-service-annotations&lt;/artifactId&gt;\n  &lt;version&gt;${autoServiceVersion}&lt;/version&gt;\n&lt;/dependency&gt;\n</code></pre> <p>Configure the annotation processor with the compiler plugin.</p> <p>```xml Person(String name) { }  maven-compiler-plugin com.google.auto.service auto-service ${autoServiceVersion} <pre><code>Next, add this class to your project:\n\n```java\npublic class JacksonJsonAdapters {\n  private static final ObjectMapper mapper = new ObjectMapper();\n\n  @AutoService(BodyAdapter.Encoder.class)\n  public static class Encoder extends ForwardingEncoder {\n    public Encoder() {\n      super(JacksonAdapterFactory.createJsonEncoder(mapper));\n    }\n  }\n\n  @AutoService(BodyAdapter.Decoder.class)\n  public static class Decoder extends ForwardingDecoder {\n    public Decoder() {\n      super(JacksonAdapterFactory.createJsonDecoder(mapper));\n    }\n  }\n}\n</code></pre></p>"},{"location":"legacy_adapters/#manual-configuration","title":"Manual Configuration","text":"<p>You can also write the configuration files manually. First, add this class to your project:</p> <pre><code>public class JacksonJsonAdapters {\n  private static final ObjectMapper mapper = new ObjectMapper();\n\n  public static class Encoder extends ForwardingEncoder {\n    public Encoder() {\n      super(JacksonAdapterFactory.createJsonEncoder(mapper));\n    }\n  }\n\n  public static class Decoder extends ForwardingDecoder {\n    public Decoder() {\n      super(JacksonAdapterFactory.createJsonDecoder(mapper));\n    }\n  }\n}\n</code></pre> <p>Next, create two provider-configuration files in the resource directory: <code>META-INF/services</code>, one for  Person(String name) { }the encoder and the other for the decoder. Each file must contain the fully qualified name of the implementation class.</p> <p>Let's say the above class is in a package named <code>com.example</code>. You'll want to have one file for the encoder named:</p> <pre><code>META-INF/services/com.github.mizosoft.methanol.BodyAdapter$Encoder\n</code></pre> <p>and contains the following line:</p> <pre><code>com.example.JacksonJsonAdapters$Encoder\n</code></pre> <p>Similarly, the decoder's file is named:</p> <pre><code>META-INF/services/com.github.mizosoft.methanol.BodyAdapter$Decoder\n</code></pre> <p>and contains:</p> <pre><code>com.example.JacksonJsonAdapters$Decoder\n</code></pre>"},{"location":"media_types/","title":"Mime","text":"<p>Media types are the web's notion for file extensions. They're present in requests and responses as <code>Content-Type</code> directives. Methanol's <code>MediaType</code> facilitates the representation and manipulation of media types.</p>"},{"location":"media_types/#mediatype","title":"MediaType","text":"<p>You can create a <code>MediaType</code> from its individual components or parse one from a <code>Content-Type</code> string.</p> MediaType::ofMediaType::parse <pre><code>var applicationJsonUtf8 = MediaType.of(\"application\", \"json\", Map.of(\"charset\", \"UTF-8\")); \n\nassertEquals(\"application\", applicationJsonUtf8.type());\nassertEquals(\"json\", applicationJsonUtf8.subtype());\nassertEquals(\"utf-8\", applicationJsonUtf8.parameters().get(\"charset\"));\nassertEquals(Optional.of(StandardCharsets.UTF_8), applicationJsonUtf8.charset());\n</code></pre> <pre><code>var applicationJsonUtf8 = MediaType.parse(\"application/json; charset=UTF-8\");\n\nassertEquals(\"application\", applicationJsonUtf8.type());\nassertEquals(\"json\", applicationJsonUtf8.subtype());\nassertEquals(\"utf-8\", applicationJsonUtf8.parameters().get(\"charset\"));\nassertEquals(Optional.of(StandardCharsets.UTF_8), applicationJsonUtf8.charset());\n</code></pre>"},{"location":"media_types/#media-ranges","title":"Media Ranges","text":"<p>A <code>MediaType</code> also defines a media range to which one or more media types belong, including itself.</p> <pre><code>var anyTextType = MediaType.parse(\"text/*\");\nvar textHtml = MediaType.parse(\"text/html\");\nvar applicationJson = MediaType.parse(\"application/json\");\n\nassertTrue(anyTextType.hasWildcard());\nassertTrue(anyTextType.includes(textHtml));\nassertFalse(anyTextType.includes(applicationJson));\nassertTrue(anyTextType.isCompatibleWith(textHtml));\nassertTrue(textHtml.isCompatibleWith(anyTextType));\n</code></pre> <p>Tip</p> <p><code>MediaType</code> has static definitions for the most popular media types &amp; ranges. None of them, however, defines a <code>charset</code> parameter. You can use <code>MediaType::withCharset</code> to derive media types with charsets from the statically defined ones.</p> <pre><code>static final MediaType APPLICATION_JSON_UTF8 = \n    MediaType.APPLICATION_JSON.withCharset(StandardCharsets.UTF_8);\n</code></pre>"},{"location":"media_types/#mimebodypublisher","title":"MimeBodyPublisher","text":"<p><code>MimeBodyPublisher</code> is a mixin-style interface that associates a <code>MediaType</code> with a <code>BodyPublisher</code>. It's recognized by <code>Methanol</code> and multipart bodies in that it gets the appropriate <code>Content-Type</code> header implicitly added.</p> <p>You can adapt an arbitrary <code>BodyPublisher</code> into a <code>MimeBodyPublisher</code>. Here's a factory method that creates <code>MimeBodyPublihers</code> for files. The file's media type is probed from the system, falling back to <code>application/octet-stream</code> if that doesn't work.</p> <pre><code>static MimeBodyPublisher ofMimeFile(Path file) throws FileNotFoundException {\n  MediaType mediaType = null;\n  try {\n    var contentType = Files.probeContentType(file);\n    if (contentType != null) {\n      mediaType = MediaType.parse(contentType);\n    }\n  } catch (IOException ignored) {\n  }\n\n  return MoreBodyPublishers.ofMediaType(\n      BodyPublishers.ofFile(file),\n      requireNonNullElse(mediaType, MediaType.APPLICATION_OCTET_STREAM));\n}\n\nfinal Methanol client = Methanol.create();\n\n&lt;T&gt; HttpResponse&lt;T&gt; post(String url, Path file, BodyHandler&lt;T&gt; handler)\n    throws IOException, InterruptedException {\n  // Request's Content-Type is implicitly added\n  return client.send(MutableRequest.POST(url, ofMimeFile(file)), handler);\n}\n</code></pre>"},{"location":"methanol_httpclient/","title":"Enhanced HttpClient","text":"<p>Methanol has a special <code>HttpClient</code> that extends the standard one with interesting features. Unsurprisingly, the client is named <code>Methanol</code>.</p>"},{"location":"methanol_httpclient/#usage","title":"Usage","text":"<p>In addition to interceptors and caching, <code>Methanol</code> can apply default properties to your requests. Think resolving with a base URI, adding default request headers, default timeouts, etc.</p> <pre><code>var builder = Methanol.newBuilder()\n    .userAgent(\"Will Smith\")                     // Custom User-Agent\n    .baseUri(\"https://api.github.com\")           // Base URI to resolve requests' URI against\n    .defaultHeader(\"Accept\",\"application/json\")  // Default request headers\n    .requestTimeout(Duration.ofSeconds(20))      // Default request timeout\n    .headersTimeout(Duration.ofSeconds(5))       // Timeout for receiving response headers\n    .readTimeout(Duration.ofSeconds(5))          // Timeout for single reads\n    .autoAcceptEncoding(true);                   // Transparent response compression, this is true by default\n\n// Continue using as a standard HttpClient.Builder.\nvar client = builder.connectTimeout(Duration.ofSeconds(30)).build();\n</code></pre> <p>You can also build from an existing <code>HttpClient</code> instance. However, you can't install an <code>HttpCache</code> in such case.</p> <pre><code>var prebuiltClient = HttpClient.newHttpClient();\nvar client = Methanol.newBuilder(prebuiltClient).build();\n</code></pre> <p>Note</p> <p>Default properties don't override those the request already has. For instance, a client with a default <code>Accept: text/html</code> will not override a request's <code>Accept: application/json</code>.</p>"},{"location":"methanol_httpclient/#transparent-compression","title":"Transparent Compression","text":"<p>If <code>autoAcceptEncoding</code> is enabled, the client complements requests with an <code>Accept-Encoding</code> header which accepts all supported encodings (i.e. available <code>BodyDecoder</code> providers). Additionally, the response is transparently decompressed.</p> <p>Since <code>deflate</code> &amp; <code>gzip</code> are supported out of the box, they're always included in <code>Accept-Encoding</code>. For instance, if brotli is installed, requests will typically have: <code>Accept-Encoding: gzip, deflate, br</code>. If you want specific encodings to be applied, add <code>Accept-Encoding</code> as a default header or explicitly set one in your request.</p> Default HeaderRequest Header <pre><code>// Advertise brotli decompression\nvar client = Methanol.newBuilder()\n    .defaultHeader(\"Accept-Encoding\", \"br\")\n    .build();\n</code></pre> <pre><code>// Advertise brotli decompression\nvar request = MutableRequest.GET(uri)\n    .header(\"Accept-Encoding\", \"br\");\n</code></pre>"},{"location":"methanol_httpclient/#mimebodypublisher","title":"MimeBodyPublisher","text":"<p><code>Methanol</code> automatically sets a request's <code>Content-Type</code> if it has a <code>MimeBodyPublisher</code>. If the request already has a <code>Content-Type</code>, it's overwritten. This makes sense as a body knows its media type better than the containing request.</p>"},{"location":"methanol_httpclient/#reactive-dispatching","title":"Reactive Dispatching","text":"<p>If you like reactive streams, use <code>Methanol::exchange</code>, which is like <code>sendAsync</code> but returns <code>Publisher&lt;HttpResponse&lt;T&gt;&gt;</code> sources instead.</p> Without HTTP/2 PushWith HTTP/2 Push <pre><code>var client = Methanol.create();\n\nvar request = MutableRequest.GET(\"https://http2-push.appspot.com/?nopush\");\nvar publisher = client.exchange(request, BodyHandlers.ofFile(Path.of(\"page.html\")));\n\nJdkFlowAdapter.flowPublisherToFlux(publisher)\n    .doOnNext(response -&gt; System.out.printf(\"%s: %s\", response, response.body()))\n    .blockLast();\n</code></pre> <pre><code>var client = Methanol.create();\n\nvar request = MutableRequest.GET(\"https://http2-push.appspot.com\");\nvar publisher = client.exchange(\n    request, \n    BodyHandlers.ofFile(Path.of(\"page.html\")), \n    pushPromise -&gt; BodyHandlers.ofFile(Path.of(pushPromise.uri().getPath()).getFileName()));\n\nJdkFlowAdapter.flowPublisherToFlux(publisher)\n    .doOnNext(response -&gt; System.out.printf(\"%s: %s%n\", response, response.body()))\n    .blockLast();\n</code></pre>"},{"location":"methanol_httpclient/#mutablerequest","title":"MutableRequest","text":"<p><code>MutableRequest</code> is an <code>HttpRequest</code> with additional properties. It implements <code>HttpRequest.Builder</code> for settings request's fields.</p> <pre><code>var response = client.send(\n    MutableReqeust.GET(uri).header(\"Accept\", \"application/json\"),\n    BodyHandlers.ofString());\n</code></pre> <p><code>MutableRequest</code> accepts relative URIs (standard <code>HttpRequest.Builder</code> doesn't). This complements <code>Methanol</code>'s base URIs, against which relative ones are resolved.</p> <p>Tip</p> <p>Use <code>MutableRequest::toImmutableRequest</code> to get an immutable <code>HttpRequest</code> snapshot.</p>"},{"location":"multipart_and_forms/","title":"Multipart &amp; Forms","text":"<p>Methanol has special <code>BodyPublisher</code> implementations for multipart uploads &amp; form submission.</p>"},{"location":"multipart_and_forms/#multipart-bodies","title":"Multipart Bodies","text":"<p><code>MultipartBodyPublisher</code> implements the multipart format. A multipart body has one or more parts. Each part has a <code>BodyPublisher</code> for its content and <code>HttpHeaders</code> that describe it. <code>MultipartBodyPublisher.Builder</code>defaults to <code>multipart/form-data</code> if a multipart <code>MediaType</code> isn't explicitly specified. There are special methods for adding parts with a <code>Content-Disposition: form-data</code> header generated from a field name and an optional file name. These are referred to as form parts.</p> <pre><code>// Substitute with your client ID. Visit https://api.imgur.com/oauth2/addclient to get one.\nstatic final String CLIENT_ID = System.getenv(\"imgur.client.id\"); \n\nfinal Methanol client = Methanol.create();\n\nHttpResponse&lt;String&gt; uploadGif() throws IOException, InterruptedException {\n  var multipartBody = MultipartBodyPublisher.newBuilder()\n      .textPart(\"title\", \"Dancing stick bug\")\n      .filePart(\"image\", Path.of(\"dancing-stick-bug.gif\"), MediaType.IMAGE_GIF)\n      .build();\n  return client.send(\n      MutableRequest.POST(\"https://api.imgur.com/3/image\", multipartBody)\n          .header(\"Authorization\", \"Client-ID \" + CLIENT_ID), \n      BodyHandlers.ofString());\n}\n</code></pre> <p>If <code>filePart</code> isn't given a <code>MediaType</code>, it asks the system for one using the given <code>Path</code>, falling back to <code>application/octet-stream</code> if that doesn't work.</p> <p>Hint</p> <p>A part's <code>Content-Type</code> is automatically added if it's created with a <code>MimeBodyPublisher</code>.</p>"},{"location":"multipart_and_forms/#generic-form-parts","title":"Generic Form Parts","text":"<p>Use builder's <code>formPart</code> to add a form part from an arbitrary <code>BodyPublisher</code>. It takes a field name and an optional file name.</p> <pre><code>// Substitute with your client ID. Visit https://api.imgur.com/oauth2/addclient to get one.\nstatic final String CLIENT_ID = System.getenv(\"imgur.client.id\");\n\nfinal Methanol client = Methanol.create();\n\nHttpResponse&lt;String&gt; uploadGif() throws IOException, InterruptedException {\n  var multipartBody = MultipartBodyPublisher.newBuilder()\n      .textPart(\"title\", \"Dancing stick bug\")\n      .formPart(\n          \"image\", title + \".png\", MoreBodyPublishers.ofMediaType(imagePart, MediaType.IMAGE_PNG))\n      .build();\n  return client.send(\n      MutableRequest.POST(\"https://api.imgur.com/3/image\", multipartBody)\n          .header(\"Authorization\", \"Client-ID \" + CLIENT_ID),\n      BodyHandlers.ofString());\n}\n</code></pre> <p>Tip</p> <p>Use <code>MoreBodyPublishers::ofMediaType</code> to pair an arbitrary <code>BodyPublisher</code> with its proper <code>MediaType</code> if you want a <code>Content-Type</code> header to be specified by the part.</p>"},{"location":"multipart_and_forms/#form-bodies","title":"Form Bodies","text":"<p>Use <code>FormBodyPublisher</code> to send form data as a set of URL-encoded queries. Data is added as string name-value pairs.</p> <pre><code>final Methanol client = Methanol.create();\n\nHttpResponse&lt;String&gt; sendQueries(String url, Map&lt;String, String&gt; queries)\n    throws IOException, InterruptedException {\n  var builder = FormBodyPublisher.newBuilder();\n  queries.forEach(builder::query);\n  return client.send(MutableRequest.POST(url, builder.build()), BodyHandlers.ofString());\n}\n</code></pre> <p>Hint</p> <p>Requests with <code>MultipartBodyPublisher</code> or <code>FormBodyPublisher</code> will have their <code>Content-Type</code> header added automatically if sent on a <code>Methanol</code> client.</p>"},{"location":"progress_tracking/","title":"Progress Tracking","text":"<p>You can track download &amp; upload progress using Methanol's <code>ProgressTracker</code>.</p>"},{"location":"progress_tracking/#setup","title":"Setup","text":"<p>A <code>ProgressTracker</code> controls the rate at which progress events are propagated using two thresholds: bytes transferred &amp; time passed, both calculated since the last event. </p> Byte count thresholdTime passed threshold <pre><code>// Receive a progress event at least each 50 kBs of data\nvar tracker = ProgressTracker.newBuilder()\n    .bytesTransferredThreshold(50 * 1024)\n    .build();\n</code></pre> <pre><code>// Receive a progress event at least each half a second\nvar tracker = ProgressTracker.newBuilder()\n    .timePassedThreshold(Duration.ofSeconds(1).dividedBy(2))\n    .build();\n</code></pre> <p>Tip</p> <p>You can use the builder to set an <code>Executor</code> that's used for dispatching progress events to  your listener. That's useful in case your listener does something like GUI updates.</p> <p>You'd want it to be invoked in the GUI thread rather than an arbitrary HTTP client thread.</p> <pre><code>    ```java hl_lines=\"3\"\n    var tracker = ProgressTracker.newBuilder()\n        .bytesTransferredThreshold(50 * 1024)\n        .executor(javafx.application.Platform::runLater)\n        .build();\n    ```\n</code></pre>"},{"location":"progress_tracking/#usage","title":"Usage","text":"<p>You track download progress by attaching a <code>Listener</code> to a response's <code>BodyHandler</code>. Similarly, upload progress is tracked by registering a <code>Listener</code> with a request's <code>BodyPublisher</code>.</p> Track downloadsTrack uploads <pre><code>final Methanol client = Methanol.create();\n\nfinal ProgressTracker tracker = ProgressTracker.newBuilder()\n    .bytesTransferredThreshold(60 * 1024) // 60 kB\n    .build();\n\nHttpResponse&lt;Path&gt; downloadVeryInterestingVideo() throws IOException, InterruptedException {\n  var request = MutableRequest.GET(\"https://i.imgur.com/NYvl8Sy.mp4\");\n\n  var downloadingBodyHandler = BodyHandlers.ofFile(\n      Path.of(\"interesting-video.mp4\"), CREATE, WRITE);\n  var trackingBodyHandler = tracker.tracking(downloadingBodyHandler, this::onProgress);\n\n  return client.send(request, trackingBodyHandler);\n}\n\nvoid onProgress(Progress progress) {\n  if (progress.determinate()) { // Overall progress can be measured\n    var percent = 100 * progress.value();\n    System.out.printf(\n        \"Downloaded %d from %d bytes (%.2f%%)%n\", \n        progress.totalBytesTransferred(), progress.contentLength(), percent);\n  } else {\n    System.out.println(\"Downloaded \" + progress.totalBytesTransferred());\n  }\n\n  if (progress.done()) {\n    System.out.println(\"Done!\");\n  }\n}\n</code></pre> <pre><code>final Methanol client = Methanol.create();\n\nfinal ProgressTracker tracker = ProgressTracker.newBuilder()\n    .bytesTransferredThreshold(60 * 1024) // 60 kB\n    .build();\n\n&lt;T&gt; HttpResponse&lt;T&gt; upload(Path file, BodyHandler&lt;T&gt; bodyHandler)\n    throws IOException, InterruptedException {\n  var trackingRequestBody = tracker.tracking(BodyPublishers.ofFile(file), this::onProgress);\n  var request = MutableRequest.POST(\"https://httpbin.org/post\", trackingRequestBody);\n\n  return client.send(request, bodyHandler);\n}\n\nvoid onProgress(Progress progress) {\n  if (progress.determinate()) { // Overall progress can be measured\n    var percent = 100 * progress.value();\n    System.out.printf(\n        \"Uploaded %d from %d bytes (%.2f%%)%n\", \n        progress.totalBytesTransferred(), progress.contentLength(), percent);\n  } else {\n    System.out.println(\"Uploaded \" + progress.totalBytesTransferred());\n  }\n\n  if (progress.done()) {\n    System.out.println(\"Done!\");\n  }\n}\n</code></pre>"},{"location":"redis/","title":"methanol-redis","text":"<p>Redis storage extension for the HTTP cache, built on lettuce. The extension supports Redis Standalone &amp; Redis Cluster setups.</p>"},{"location":"redis/#installation","title":"Installation","text":""},{"location":"redis/#gradle","title":"Gradle","text":"<pre><code>implementation(\"com.github.mizosoft.methanol:methanol-redis:1.8.3\")\n</code></pre>"},{"location":"redis/#maven","title":"Maven","text":"<pre><code>&lt;dependency&gt;\n  &lt;groupId&gt;com.github.mizosoft.methanol&lt;/groupId&gt;\n  &lt;artifactId&gt;methanol-redis&lt;/artifactId&gt;\n  &lt;version&gt;1.8.3&lt;/version&gt;\n&lt;/dependency&gt;\n</code></pre>"},{"location":"redis/#usage","title":"Usage","text":"<p>Plug in a RedisStorageExtension instance. The easiest way is to create one from a <code>RedisURI</code>.</p>"},{"location":"redis/#redis-standalone","title":"Redis Standalone","text":"<pre><code>var redisUrl = RedisURI.create(\"redis://localhost:6379\");\nvar cache =\n    HttpCache.newBuilder()\n        .cacheOn(\n            RedisStorageExtension.newBuilder()\n                .standalone(redisUri)\n                .build())\n        .build();\nvar client = Methanol.newBuilder().cache(cache).build();\n</code></pre>"},{"location":"redis/#redis-cluster","title":"Redis Cluster","text":"<pre><code>var redisUris = List.of(\n    RedisURI.create(\"redis://localhost:6379\"),\n    RedisURI.create(\"redis://localhost:6380\"),\n    ...);\nvar cache =\n    HttpCache.newBuilder()\n        .cacheOn(\n            RedisStorageExtension.newBuilder()\n                .cluster(redisUris)\n                .build())\n        .build();\nvar client = Methanol.newBuilder().cache(cache).build();\n</code></pre> <p>Don't forget to close the cache!</p> <p>You can also pass your own <code>Redis[Cluster]Client</code>, but then you'll be responsible for its closure.</p>"},{"location":"redis/#redisconnectionprovider","title":"<code>RedisConnectionProvider</code>","text":"<p>Another way to create a <code>RedisStorageExtension</code> is to provide your implementation of <code>RedisConnectionProvider</code>, which is an abstraction for the provision and release of redis connections. Currently, the implementation relies on a single connection during lifetime of the cache, and releases it when the cache is closed. <code>RedisConnectionProvider::close</code> is also invoked when the cache is closed.</p>"},{"location":"redis/#timeouts","title":"Timeouts","text":"<p>For better memory efficiency, the extension implements stream semantics upon Redis. This means that whatever read or written is seen as a stream of bytes that is acquired progressively as chunks, rather than first loaded entirely in memory. As the program utilizing the cache can fail at any time, this requires having timeouts so that temporary streams that are not utilized anymore are deleted. There are two:</p> <ul> <li><code>editorLockInactiveTtlSeconds</code>: The number of seconds an uncommitted entry that is still being edited can live during   an editor's inactivity. Default is <code>5</code> seconds.</li> <li><code>staleEntryInactiveTtlSeconds</code>: the number of seconds a deleted entry is allowed to live during an inactivity from   a potential concurrent reader. Default is <code>3</code> seconds.</li> </ul> <p>You can customize these with <code>RedisStorageExtension.Builder</code>.</p>"},{"location":"streaming_requests/","title":"Streaming Requests","text":"<p><code>MoreBodyPublishers</code> provides publishers for asynchronously streaming the request body into an <code>OutputStream</code> or a <code>WritableByteChannel</code>.</p> <p>Let's say your sever supports compressed requests. If you're sending a large file, you'd want to send it in gzip.</p> <pre><code>final Methanol client = Methanol.create();\nfinal Executor executor = Executors.newVirtualThreadPerTaskExecutor();\n\nHttpResponse&lt;Void&gt; postGzipped(Path file) {\n  return client.send(\n      MutableRequest.POST(\n              \"https://example.com\",\n              MoreBodyPublishers.ofOutputStream(\n                  out -&gt; Files.copy(file, out), executor))\n          .header(\"Content-Encoding\", \"gzip\"),\n      BodyHandlers.discarding());\n}\n</code></pre> <p><code>MoreBodyPublishers::ofOutputStream</code> accepts a callback that takes the <code>OutputStream</code> to stream to. The callback is invoked on the given executor. The stream may buffer content temporarily in case the consumer can't keep up with the producer, or till an inner buffer becomes full. You can use <code>OutputStream::flush</code>to make any buffered content available for consumption. The stream is closed automatically after the callback. If the callback fails, the request is completed exceptionally.</p> <p>As of 1.8.0, this is the recommended way for streaming requests rather than using <code>WritableBodyPublisher</code> directly.</p>"},{"location":"adapters/gson/","title":"methanol-gson","text":"<p>Adapters for JSON using Gson.</p>"},{"location":"adapters/gson/#installation","title":"Installation","text":""},{"location":"adapters/gson/#gradle","title":"Gradle","text":"<pre><code>implementation(\"com.github.mizosoft.methanol:methanol-gson:1.8.3\")\n</code></pre>"},{"location":"adapters/gson/#maven","title":"Maven","text":"<pre><code>&lt;dependency&gt;\n  &lt;groupId&gt;com.github.mizosoft.methanol&lt;/groupId&gt;\n   &lt;artifactId&gt;methanol-gson&lt;/artifactId&gt;\n    &lt;version&gt;1.8.3&lt;/version&gt;\n&lt;/dependency&gt;\n</code></pre>"},{"location":"adapters/gson/#usage","title":"Usage","text":"<pre><code>var gson = new Gson();\nvar adapterCodec =\n    AdapterCodec.newBuilder()\n        .encoder(GsonAdapterFactory.createEncoder(gson))\n        .decoder(GsonAdapterFactory.createDecoder(gson))\n        .build();\nvar client =\n    Methanol.newBuilder()\n        .adapterCodec(adapterCodec)\n        .build();\n\nrecord Person(String name) {}\n\nvar bruceLee = new Person(\"Bruce Lee\");\nvar response = client.send(\n    MutableRequest.POST(\".../echo\", bruceLee, MediaType.APPLICATION_JSON),\n    Person.class);\nassertThat(response.body()).isEqualTo(bruceLee);\n</code></pre>"},{"location":"adapters/gson/#legacy-adapters","title":"Legacy Adapters","text":"<p>See Legacy Adapters</p>"},{"location":"adapters/jackson/","title":"methanol-jackson","text":"<p>Adapters for Jackson.</p>"},{"location":"adapters/jackson/#installation","title":"Installation","text":""},{"location":"adapters/jackson/#gradle","title":"Gradle","text":"<pre><code>implementation(\"com.github.mizosoft.methanol:methanol-jackson:1.8.3\")\n</code></pre>"},{"location":"adapters/jackson/#maven","title":"Maven","text":"<pre><code>&lt;dependency&gt;\n  &lt;groupId&gt;com.github.mizosoft.methanol&lt;/groupId&gt;\n   &lt;artifactId&gt;methanol-jackson&lt;/artifactId&gt;\n    &lt;version&gt;1.8.3&lt;/version&gt;\n&lt;/dependency&gt;\n</code></pre>"},{"location":"adapters/jackson/#usage","title":"Usage","text":"<pre><code>var mapper = new JsonMapper();\nvar adapterCodec =\n    AdapterCodec.newBuilder()\n        .encoder(JacksonAdapterFactory.createJsonEncoder(mapper))\n        .decoder(JacksonAdapterFactory.createJsonDecoder(mapper))\n        .build();\nvar client =\n    Methanol.newBuilder()\n        .adapterCodec(adapterCodec)\n        .build();\n\nrecord Person(String name) {}\n\nvar bruceLee = new Person(\"Bruce Lee\");\nvar response = client.send(\n    MutableRequest.POST(\".../echo\", bruceLee, MediaType.APPLICATION_JSON),\n    Person.class);\nassertThat(response.body()).isEqualTo(bruceLee);\n</code></pre>"},{"location":"adapters/jackson/#formats","title":"Formats","text":"<p><code>ObjectMapper</code> implementations can be paired with one or more <code>MediaTypes</code> to create adapters for any format supported by Jackson. For instance, here's an adapter for XML that uses <code>jackson-dataformat-xml</code>.</p> <pre><code> var mapper = new XmlMapper();\nvar adapterCodec =\n    AdapterCodec.newBuilder()\n        .encoder(\n            JacksonAdapterFactory.createEncoder(\n                mapper, MediaType.APPLICATION_XML, MediaType.TEXT_XML))\n        .decoder(\n            JacksonAdapterFactory.createDecoder(\n                mapper, MediaType.APPLICATION_XML, MediaType.TEXT_XML))\n        .build();\n</code></pre> <p>For binary formats, you usually can't just plug in an <code>ObjectMapper</code> as a schema must be applied for each type. Thus, you would use a custom <code>ObjectReaderFactory</code> and/or <code>ObjectWriterFactory</code>. Here's an adapter for Protocol Buffers. You'll need to know what types are expected beforehand.</p> <pre><code>record Point(int x, int y) {}\n\nvar schemas =\n    Map.of(\n        TypeRef.of(Point.class),\n        ProtobufSchemaLoader.std.parse(\n            \"\"\"\n                message Point {\n                  required int32 x = 1;\n                  required int32 y = 2;\n                }\n                \"\"\"));\nvar mapper = new ProtobufMapper();\nvar adapterCodec =\n    AdapterCodec.newBuilder()\n        .encoder(\n            JacksonAdapterFactory.createEncoder(\n                mapper,\n                (localMapper, typeRef) -&gt; localMapper.writer(schemas.get(typeRef)),\n                MediaType.APPLICATION_X_PROTOBUF))\n        .decoder(\n            JacksonAdapterFactory.createDecoder(\n                mapper,\n                (localMapper, typeRef) -&gt;\n                    mapper.readerFor(typeRef.rawType()).with(schemas.get(typeRef)),\n                MediaType.APPLICATION_X_PROTOBUF));\n</code></pre>"},{"location":"adapters/jackson/#legacy-adapters","title":"Legacy Adapters","text":"<p>See Legacy Adapters</p>"},{"location":"adapters/jackson_flux/","title":"methanol-jackson-flux","text":"<p>Adapters for JSON &amp; Reactive Streams using Jackson &amp; Reactor.</p>"},{"location":"adapters/jackson_flux/#decoding","title":"Decoding","text":"<p>This adapter converts response bodies into publisher-based sources. Supported types are <code>Mono</code>, <code>Flux</code>, <code>org.reactivestreams.Publisher</code> and <code>java.util.concurrent.Flow.Publisher</code>. For all these types except <code>Mono</code>, the response body is expected to be a JSON array. The array is tokenized into its individual elements, each mapped to the publisher's element type.</p> <p>Note that an <code>HttpResponse</code> handled with this adapter is completed immediately after the response headers are received. Body completion is handled by the returned publisher source. Additionally, the decoder always uses Jackson's non-blocking parser.</p>"},{"location":"adapters/jackson_flux/#encoding","title":"Encoding","text":"<p>With the exception of <code>Mono</code>, any subtype of <code>org.reactivestreams.Publisher</code> or <code>java.util.concurrent.Flow.Publisher</code> is encoded to a JSON array containing zero or more elements, each mapped from each published object. <code>Mono</code> sources are encoded to a single JSON object (if completed with any).</p>"},{"location":"adapters/jackson_flux/#installation","title":"Installation","text":""},{"location":"adapters/jackson_flux/#gradle","title":"Gradle","text":"<pre><code>implementation(\"com.github.mizosoft.methanol:methanol-jackson-flux:1.8.3\")\n</code></pre>"},{"location":"adapters/jackson_flux/#maven","title":"Maven","text":"<pre><code>&lt;dependency&gt;\n  &lt;groupId&gt;com.github.mizosoft.methanol&lt;/groupId&gt;\n   &lt;artifactId&gt;methanol-jackson-flux&lt;/artifactId&gt;\n    &lt;version&gt;1.8.3&lt;/version&gt;\n&lt;/dependency&gt;\n</code></pre>"},{"location":"adapters/jackson_flux/#usage","title":"Usage","text":"<pre><code>var mapper = new JsonMapper();\nvar adapterCodec =\n    AdapterCodec.newBuilder()\n        .encoder(JacksonFluxAdapterFactory.createEncoder(mapper))\n        .decoder(JacksonFluxAdapterFactory.createDecoder(mapper))\n        .build();\nvar client = Methanol.newBuilder().adapterCodec(adapterCodec).build();\n\nrecord Person(String name) {\n}\n\nvar bruceLee = new Person(\"Bruce Lee\");\nvar jackieChan = new Person(\"Jacki Chan\");\nvar response =\n    client.send(\n        MutableRequest.POST(\n            \".../echo\",\n            Flux.just(bruceLee, jackieChan),\n            MediaType.APPLICATION_JSON), \n        new TypeRef&lt;Flux&lt;Person&gt;&gt;() {});\nassertThat(response.body().toIterable()).containsExactly(bruceLee, jackieChan);\n</code></pre>"},{"location":"adapters/jackson_flux/#legacy-adapters","title":"Legacy Adapters","text":"<p>See Legacy Adapters</p>"},{"location":"adapters/jaxb/","title":"methanol-jaxb","text":"<p>Adapters for XML using Java EE's JAXB.</p>"},{"location":"adapters/jaxb/#installation","title":"Installation","text":""},{"location":"adapters/jaxb/#gradle","title":"Gradle","text":"<pre><code>implementation(\"com.github.mizosoft.methanol:methanol-jaxb:1.8.3\")\n</code></pre>"},{"location":"adapters/jaxb/#maven","title":"Maven","text":"<pre><code>&lt;dependency&gt;\n  &lt;groupId&gt;com.github.mizosoft.methanol&lt;/groupId&gt;\n   &lt;artifactId&gt;methanol-jaxb&lt;/artifactId&gt;\n    &lt;version&gt;1.8.3&lt;/version&gt;\n&lt;/dependency&gt;\n</code></pre>"},{"location":"adapters/jaxb/#usage","title":"Usage","text":"<pre><code>var adapterCodec =\n    AdapterCodec.newBuilder()\n        .encoder(JaxbAdapterFactory.createEncoder())\n        .decoder(JaxbAdapterFactory.createDecoder())\n        .build();\nvar client =\n    Methanol.newBuilder()\n        .adapterCodec(adapterCodec)\n        .build();\n\nrecord Person(String name) {}\n\nvar bruceLee = new Person(\"Bruce Lee\");\nvar response = client.send(\n    MutableRequest.POST(\".../echo\", bruceLee, MediaType.APPLICATION_XML),\n    Person.class);\nassertThat(response.body()).isEqualTo(bruceLee);\n</code></pre>"},{"location":"adapters/jaxb/#legacy-adapters","title":"Legacy Adapters","text":"<p>See Legacy Adapters</p>"},{"location":"adapters/jaxb_jakarta/","title":"methanol-jaxb-jakarta","text":"<p>Adapters for XML using Jakarta EE's JAXB.</p>"},{"location":"adapters/jaxb_jakarta/#installation","title":"Installation","text":""},{"location":"adapters/jaxb_jakarta/#gradle","title":"Gradle","text":"<pre><code>implementation(\"com.github.mizosoft.methanol:methanol-jaxb-jakarta:1.8.3\")\n</code></pre>"},{"location":"adapters/jaxb_jakarta/#maven","title":"Maven","text":"<pre><code>&lt;dependency&gt;\n  &lt;groupId&gt;com.github.mizosoft.methanol&lt;/groupId&gt;\n   &lt;artifactId&gt;methanol-jaxb-jakarta&lt;/artifactId&gt;\n    &lt;version&gt;1.8.3&lt;/version&gt;\n&lt;/dependency&gt;\n</code></pre>"},{"location":"adapters/jaxb_jakarta/#usage","title":"Usage","text":"<pre><code>var adapterCodec =\n    AdapterCodec.newBuilder()\n        .encoder(JaxbAdapterFactory.createEncoder())\n        .decoder(JaxbAdapterFactory.createDecoder())\n        .build();\nvar client =\n    Methanol.newBuilder()\n        .adapterCodec(adapterCodec)\n        .build();\n\nrecord Person(String name) {}\n\nvar bruceLee = new Person(\"Bruce Lee\");\nvar response = client.send(\n    MutableRequest.POST(\".../echo\", bruceLee, MediaType.APPLICATION_XML),\n    Person.class);\nassertThat(response.body()).isEqualTo(bruceLee);\n</code></pre>"},{"location":"adapters/jaxb_jakarta/#legacy-adapters","title":"Legacy Adapters","text":"<p>See Legacy Adapters</p>"},{"location":"adapters/moshi/","title":"methanol-moshi","text":"<p>Adapters for JSON using moshi.</p>"},{"location":"adapters/moshi/#installation","title":"Installation","text":""},{"location":"adapters/moshi/#gradle","title":"Gradle","text":"<pre><code>implementation(\"com.github.mizosoft.methanol:methanol-moshi:1.8.3\")\n</code></pre>"},{"location":"adapters/moshi/#maven","title":"Maven","text":"<pre><code>&lt;dependency&gt;\n  &lt;groupId&gt;com.github.mizosoft.methanol&lt;/groupId&gt;\n   &lt;artifactId&gt;methanol-moshi&lt;/artifactId&gt;\n    &lt;version&gt;1.8.3&lt;/version&gt;\n&lt;/dependency&gt;\n</code></pre>"},{"location":"adapters/moshi/#usage","title":"Usage","text":"<pre><code>val moshi: Moshi = Moshi.Builder().build()\nval client = Client {\n  adapterCodec {\n    +MoshiAdapter.Encoder(moshi, MediaType.APPLICATION_JSON)\n    +MoshiAdapter.Decoder(moshi, MediaType.APPLICATION_JSON)\n  }\n}\n\ndata class Person(val name: String)\n\nvar bruceLee = Person(\"Bruce Lee\")\nval response: Response&lt;Person&gt; = client.post(\".../echo\") {\n  body(bruceLee, MediaType.APPLICATION_JSON)\n}\nassertThat(response.body()).isEqualTo(bruceLee)\n</code></pre>"},{"location":"adapters/moshi/#legacy-adapters","title":"Legacy Adapters","text":"<p>See Legacy Adapters</p>"},{"location":"adapters/protobuf/","title":"methanol-protobuf","text":"<p>Adapters for Google's Protocol Buffers.</p>"},{"location":"adapters/protobuf/#encoding-decoding","title":"Encoding &amp; Decoding","text":"<p>Any subtype of <code>MessageLite</code> is supported by encoders &amp; decoders. Decoders can optionally have an <code>ExtensionRegistryLite</code> or an <code>ExtensionRegistry</code> to enable message extensions.</p>"},{"location":"adapters/protobuf/#installation","title":"Installation","text":""},{"location":"adapters/protobuf/#gradle","title":"Gradle","text":"<pre><code>implementation(\"com.github.mizosoft.methanol:methanol-protobuf:1.8.3\")\n</code></pre>"},{"location":"adapters/protobuf/#maven","title":"Maven","text":"<pre><code>&lt;dependency&gt;\n  &lt;groupId&gt;com.github.mizosoft.methanol&lt;/groupId&gt;\n   &lt;artifactId&gt;methanol-protobuf&lt;/artifactId&gt;\n    &lt;version&gt;1.8.3&lt;/version&gt;\n&lt;/dependency&gt;\n</code></pre>"},{"location":"adapters/protobuf/#usage","title":"Usage","text":"<pre><code>var adapterCodec =\n    AdapterCodec.newBuilder()\n        .encoder(ProtobufAdapterFactory.createEncoder())\n        .decoder(ProtobufAdapterFactory.createDecoder())\n        .build();\nvar client =\n    Methanol.newBuilder()\n        .adapterCodec(adapterCodec)\n        .build();\n\nvar bruceLee = Person.newBuilder().setName(\"Bruce Lee\").build();\nvar response = client.send(\n    MutableRequest.POST(\".../echo\", bruceLee, MediaType.APPLICATION_XML),\n    MyMessage.class);\nassertThat(response.body()).isEqualTo(bruceLee);\n</code></pre>"}]}