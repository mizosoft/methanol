{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Methanol \u00b6 Java enjoys a neat, built-in HTTP client . However, it lacks key HTTP features like multipart uploads, caching and response decompression. Methanol comes in to fill these gaps. The library comprises a set of lightweight, yet powerful extensions aimed at making it much easier & more productive to work with java.net.http . You can say it's an HttpClient wrapper, but you'll see it almost seamlessly integrates with the standard API you might already know. Methanol isn't invasive. The core library has zero runtime dependencies. However, special attention is given to object mapping, so integration with libraries like Jackson or Gson becomes a breeze. Installation \u00b6 Gradle \u00b6 implementation 'com.github.mizosoft.methanol:methanol:1.7.0' Maven \u00b6 <dependency> <groupId> com.github.mizosoft.methanol </groupId> <artifactId> methanol </artifactId> <version> 1.7.0 </version> </dependency> Contributing \u00b6 See CONTRIBUTING License \u00b6 MIT","title":"Overview"},{"location":"#methanol","text":"Java enjoys a neat, built-in HTTP client . However, it lacks key HTTP features like multipart uploads, caching and response decompression. Methanol comes in to fill these gaps. The library comprises a set of lightweight, yet powerful extensions aimed at making it much easier & more productive to work with java.net.http . You can say it's an HttpClient wrapper, but you'll see it almost seamlessly integrates with the standard API you might already know. Methanol isn't invasive. The core library has zero runtime dependencies. However, special attention is given to object mapping, so integration with libraries like Jackson or Gson becomes a breeze.","title":"Methanol"},{"location":"#installation","text":"","title":"Installation"},{"location":"#gradle","text":"implementation 'com.github.mizosoft.methanol:methanol:1.7.0'","title":"Gradle"},{"location":"#maven","text":"<dependency> <groupId> com.github.mizosoft.methanol </groupId> <artifactId> methanol </artifactId> <version> 1.7.0 </version> </dependency>","title":"Maven"},{"location":"#contributing","text":"See CONTRIBUTING","title":"Contributing"},{"location":"#license","text":"MIT","title":"License"},{"location":"CHANGELOG/","text":"Change Log \u00b6 Version 1.7.0 \u00b6 9-5-2022 A full year has passed since the last Methanol release! Time truly flies. It's been difficult to find the time to cut this release due to my senior college year & other life circumstances, but here we are! The Jackson adapter has been reworked to support the multitude of formats supported by Jackson, not only JSON ( #45 ). That means you can now pass arbitrary ObjectMapper instances along with one or more MediaTypes describing their formats. For instance, here's a provider for a Jackson-based XML decoder. public class JacksonXmlDecoderProvider { private JacksonXmlDecoderProvider () {} public static BodyAdapter . Decoder provider () { return JacksonAdapterFactory . createDecoder ( new XmlMapper (), MediaType . TEXT_XML ); } } Binary formats (e.g. protocol buffers) usually require applying a schema for each type. ObjectReaderFacotry & ObjectWriterFactory have been added for this purpose. For instance, here's a provider for a protocol-buffers decoder. You'll need to know which types to expect beforehand. public class JacksonProtobufDecoderProvider { private JacksonProtobufDecoderProvider () {} public record Point ( int x , int y ) {} public static BodyAdapter . Decoder provider () throws IOException { var schemas = Map . of ( Point . class , ProtobufSchemaLoader . std . parse ( \"\"\" message Point { required int32 x = 1; required int32 y = 2; } \"\"\" ), ...); // Apply the corresponding schema for each created ObjectReader ObjectReaderFactory readerFactory = ( mapper , type ) -> mapper . readerFor ( type . rawType ()). with ( schemas . get ( type . rawType ())); return JacksonAdapterFactory . createDecoder ( new ProtobufMapper (), readerFactory , MediaType . APPLICATION_X_PROTOBUF ); } } To avoid ambiguity, JacksonAdapterFactory::createDecoder & JacksonAdapterFactory::createEncoder that don't take an explicit MediaType have been deprecated and replaced with JacksonAdapterFactory::createJsonDecoder & JacksonAdapterFactory::createJsonEncoder respectively. Added timeouts for receiving all response headers ( #49 ). You can use these along with read timeouts to set more granular timing constraints for your requests when request timeouts are too strict. var client = Methanol . newBuilder () . headersTimeout ( Duration . ofSeconds ( 30 )) . readTimeout ( Duration . ofSeconds ( 30 )) ... . build () Fix ( #40 ): Methanol had a long-lived issue that made it difficult for service providers to work with custom JAR formats, particularly the one used by Spring Boot's executable JARs . Instead of the system classloader, Methanol now relies on the classloader that loaded the library itself for locating providers. This is not necessarily the system classloader as in the case with Spring Boot. Fix ( 46 ): ProgressTracker now returns MimeBodyPublisher if the body being tracked is itself a MimeBodyPublisher . This prevents \"swallowing\" the MediaType of such bodies. Upgraded Jackson to 2.13.2 . Upgraded Gson to 2.9.0 . Upgraded Reactor to 3.4.17 . Version 1.6.0 \u00b6 30-5-2021 Added HttpCache.Listener . Added TaggableRequest . This facilitates carrying application-specific data throughout interceptors & listeners. var interceptor = Interceptor . create ( request -> { var taggableRequest = TaggableRequest . from ( request ); var context = taggableRequest . tag ( MyContext . class ). orElseGet ( MyContext :: empty ); ... }); var client = Methanol . newBuilder () . interceptor ( interceptor ) . build (); var context = ... var request = MutableRequest . GET ( \"https://example.com\" ) . tag ( MyContext . class , context ); var response = client . send ( request , BodyHandlers . ofString ()); Fixed disk cache possibly manipulating the disk index concurrently. This could happen if an index update is delayed, as the scheduler mistakenly ran the index write immediately after the delay evaluates instead of queuing it with the sequential index executor. Fixed TimeoutSubscriber (used in MoreBodySubscribers::withReadTimeout ) possibly calling downstream's onNext & onError concurrently. This could happen if timeout evaluates while downstream's onNext is still executing. Made AsyncBodyDecoder ignore upstream signals after decoding in onNext fails and the error is reported to onError . This prevents receiving further onXXXX by upstream if it doesn't immediately detect cancellation. Made the disk cache catch and log StoreCorruptionException thrown when opening an entry. This is done instead of rethrowing. Methanol now always validates request's URI after being resolved with the optional base URI . Previously, the URI was only validated if there was a base URI . Upgraded gson to 2.8.7 . Version 1.5.0 \u00b6 14-5-2021 Methanol now has an RFC-compliant HTTP cache! It can store entries on disk or in memory. Give it a try! void cache () throws InterruptedException , IOException { var cache = HttpCache . newBuilder () . cacheOnDisk ( Path . of ( \"cache-dir\" ), 100 * 1024 * 1024 ) . build (); var client = Methanol . newBuilder () . cache ( cache ) . build (); var request = MutableRequest . GET ( \"https://i.imgur.com/NYvl8Sy.mp4\" ); var response = ( CacheAwareResponse < Path > ) client . send ( request , BodyHandlers . ofFile ( Path . of ( \"banana_cat.mp4\" ))); System . out . printf ( \"%s (CacheStatus: %s, elapsed: %s)%n\" , response , response . cacheStatus (), Duration . between ( response . timeRequestSent (), response . timeResponseReceived ())); cache . close (); } Added CacheControl to model the Cache-Control header and its directives. This is complementary to the new cache as all configuration is communicated through Cache-Control . Interceptors have been reworked. The old naming convention is deprecated. An interceptor is now either a client or a backend interceptor instead of a pre/post decoration interceptor, where 'backend' refers to Methanol 's backing HttpClient . The cache intercepts requests after client but before backend interceptors. It was tempting to name the latter 'network interceptors', but that seemed rather confusing as not all 'network' requests can be intercepted ( HttpClient can make its own intermediate requests like redirects & retries). Added HttpStatus , which contains functions for checking response codes. Added ForwardingEncoder & ForwardingDecoder . These are meant for easier installation of adapters from the classpath. System.Logger API is now used instead of java.util.logging . Fix: Don't attempt to decompress responses to HEADs. This fixed failures like unexpected end of gzip stream . Fix: Decompressed responses now have their stale Content-Encoding & Content-Length headers removed. Changed reactor dependency to API scope in the methanol-jackson-flux adapter. Upgraded Jackson to 2.12.3 . Upgraded Reactor to 3.4.6 . New project website ! Version 1.4.1 \u00b6 26-9-2020 Updated dependencies. Fix: Autodetect if a deflated stream is zlib-wrapped or not to not crash when some servers incorrectly send raw deflated bytes for the deflate encoding. Version 1.4.0 \u00b6 27-7-2020 Multipart progress tracking. Version 1.3.0 \u00b6 22-6-2020 Default read timeout in Methanol client. API for tracking upload/download progress. High-level client interceptors. Version 1.2.0 \u00b6 1-5-2020 Reactive JSON adapters with Jackson and Reactor. Common MediaType constants. XML adapters with JAXB. Version 1.1.0 \u00b6 17-4-2020 First \"main-stream\" release. Version 1.0.0 \u00b6 25-3-2020 Dummy release.","title":"Change Log"},{"location":"CHANGELOG/#change-log","text":"","title":"Change Log"},{"location":"CHANGELOG/#version-170","text":"9-5-2022 A full year has passed since the last Methanol release! Time truly flies. It's been difficult to find the time to cut this release due to my senior college year & other life circumstances, but here we are! The Jackson adapter has been reworked to support the multitude of formats supported by Jackson, not only JSON ( #45 ). That means you can now pass arbitrary ObjectMapper instances along with one or more MediaTypes describing their formats. For instance, here's a provider for a Jackson-based XML decoder. public class JacksonXmlDecoderProvider { private JacksonXmlDecoderProvider () {} public static BodyAdapter . Decoder provider () { return JacksonAdapterFactory . createDecoder ( new XmlMapper (), MediaType . TEXT_XML ); } } Binary formats (e.g. protocol buffers) usually require applying a schema for each type. ObjectReaderFacotry & ObjectWriterFactory have been added for this purpose. For instance, here's a provider for a protocol-buffers decoder. You'll need to know which types to expect beforehand. public class JacksonProtobufDecoderProvider { private JacksonProtobufDecoderProvider () {} public record Point ( int x , int y ) {} public static BodyAdapter . Decoder provider () throws IOException { var schemas = Map . of ( Point . class , ProtobufSchemaLoader . std . parse ( \"\"\" message Point { required int32 x = 1; required int32 y = 2; } \"\"\" ), ...); // Apply the corresponding schema for each created ObjectReader ObjectReaderFactory readerFactory = ( mapper , type ) -> mapper . readerFor ( type . rawType ()). with ( schemas . get ( type . rawType ())); return JacksonAdapterFactory . createDecoder ( new ProtobufMapper (), readerFactory , MediaType . APPLICATION_X_PROTOBUF ); } } To avoid ambiguity, JacksonAdapterFactory::createDecoder & JacksonAdapterFactory::createEncoder that don't take an explicit MediaType have been deprecated and replaced with JacksonAdapterFactory::createJsonDecoder & JacksonAdapterFactory::createJsonEncoder respectively. Added timeouts for receiving all response headers ( #49 ). You can use these along with read timeouts to set more granular timing constraints for your requests when request timeouts are too strict. var client = Methanol . newBuilder () . headersTimeout ( Duration . ofSeconds ( 30 )) . readTimeout ( Duration . ofSeconds ( 30 )) ... . build () Fix ( #40 ): Methanol had a long-lived issue that made it difficult for service providers to work with custom JAR formats, particularly the one used by Spring Boot's executable JARs . Instead of the system classloader, Methanol now relies on the classloader that loaded the library itself for locating providers. This is not necessarily the system classloader as in the case with Spring Boot. Fix ( 46 ): ProgressTracker now returns MimeBodyPublisher if the body being tracked is itself a MimeBodyPublisher . This prevents \"swallowing\" the MediaType of such bodies. Upgraded Jackson to 2.13.2 . Upgraded Gson to 2.9.0 . Upgraded Reactor to 3.4.17 .","title":"Version 1.7.0"},{"location":"CHANGELOG/#version-160","text":"30-5-2021 Added HttpCache.Listener . Added TaggableRequest . This facilitates carrying application-specific data throughout interceptors & listeners. var interceptor = Interceptor . create ( request -> { var taggableRequest = TaggableRequest . from ( request ); var context = taggableRequest . tag ( MyContext . class ). orElseGet ( MyContext :: empty ); ... }); var client = Methanol . newBuilder () . interceptor ( interceptor ) . build (); var context = ... var request = MutableRequest . GET ( \"https://example.com\" ) . tag ( MyContext . class , context ); var response = client . send ( request , BodyHandlers . ofString ()); Fixed disk cache possibly manipulating the disk index concurrently. This could happen if an index update is delayed, as the scheduler mistakenly ran the index write immediately after the delay evaluates instead of queuing it with the sequential index executor. Fixed TimeoutSubscriber (used in MoreBodySubscribers::withReadTimeout ) possibly calling downstream's onNext & onError concurrently. This could happen if timeout evaluates while downstream's onNext is still executing. Made AsyncBodyDecoder ignore upstream signals after decoding in onNext fails and the error is reported to onError . This prevents receiving further onXXXX by upstream if it doesn't immediately detect cancellation. Made the disk cache catch and log StoreCorruptionException thrown when opening an entry. This is done instead of rethrowing. Methanol now always validates request's URI after being resolved with the optional base URI . Previously, the URI was only validated if there was a base URI . Upgraded gson to 2.8.7 .","title":"Version 1.6.0"},{"location":"CHANGELOG/#version-150","text":"14-5-2021 Methanol now has an RFC-compliant HTTP cache! It can store entries on disk or in memory. Give it a try! void cache () throws InterruptedException , IOException { var cache = HttpCache . newBuilder () . cacheOnDisk ( Path . of ( \"cache-dir\" ), 100 * 1024 * 1024 ) . build (); var client = Methanol . newBuilder () . cache ( cache ) . build (); var request = MutableRequest . GET ( \"https://i.imgur.com/NYvl8Sy.mp4\" ); var response = ( CacheAwareResponse < Path > ) client . send ( request , BodyHandlers . ofFile ( Path . of ( \"banana_cat.mp4\" ))); System . out . printf ( \"%s (CacheStatus: %s, elapsed: %s)%n\" , response , response . cacheStatus (), Duration . between ( response . timeRequestSent (), response . timeResponseReceived ())); cache . close (); } Added CacheControl to model the Cache-Control header and its directives. This is complementary to the new cache as all configuration is communicated through Cache-Control . Interceptors have been reworked. The old naming convention is deprecated. An interceptor is now either a client or a backend interceptor instead of a pre/post decoration interceptor, where 'backend' refers to Methanol 's backing HttpClient . The cache intercepts requests after client but before backend interceptors. It was tempting to name the latter 'network interceptors', but that seemed rather confusing as not all 'network' requests can be intercepted ( HttpClient can make its own intermediate requests like redirects & retries). Added HttpStatus , which contains functions for checking response codes. Added ForwardingEncoder & ForwardingDecoder . These are meant for easier installation of adapters from the classpath. System.Logger API is now used instead of java.util.logging . Fix: Don't attempt to decompress responses to HEADs. This fixed failures like unexpected end of gzip stream . Fix: Decompressed responses now have their stale Content-Encoding & Content-Length headers removed. Changed reactor dependency to API scope in the methanol-jackson-flux adapter. Upgraded Jackson to 2.12.3 . Upgraded Reactor to 3.4.6 . New project website !","title":"Version 1.5.0"},{"location":"CHANGELOG/#version-141","text":"26-9-2020 Updated dependencies. Fix: Autodetect if a deflated stream is zlib-wrapped or not to not crash when some servers incorrectly send raw deflated bytes for the deflate encoding.","title":"Version 1.4.1"},{"location":"CHANGELOG/#version-140","text":"27-7-2020 Multipart progress tracking.","title":"Version 1.4.0"},{"location":"CHANGELOG/#version-130","text":"22-6-2020 Default read timeout in Methanol client. API for tracking upload/download progress. High-level client interceptors.","title":"Version 1.3.0"},{"location":"CHANGELOG/#version-120","text":"1-5-2020 Reactive JSON adapters with Jackson and Reactor. Common MediaType constants. XML adapters with JAXB.","title":"Version 1.2.0"},{"location":"CHANGELOG/#version-110","text":"17-4-2020 First \"main-stream\" release.","title":"Version 1.1.0"},{"location":"CHANGELOG/#version-100","text":"25-3-2020 Dummy release.","title":"Version 1.0.0"},{"location":"CONTRIBUTING/","text":"Contributing \u00b6 Contributions are welcome! It is often a good idea to first discuss changes before submitting them. If you're considering small changes (e.g. in documentation), you can open a PR directly. You are more than welcome to: Report a bug Ask a question Propose a feature Submit a fix Improve documentation Prerequisites \u00b6 It is recommended to set the JAVA_HOME environment variable to a JDK 11 (or later) directory in order to properly work with Gradle. Building \u00b6 Before submitting a change, make sure to first run tests and code analysis. ./gradlew clean check -PenableErrorprone Error-prone checks are included but disabled by default for build speed. It is desirable to make errorprone happy (maybe via reasonable suppressions). Checker Framework is optionally used but mainly for informative reasons (its acts weird and crashes, patches regarding this are welcome). Similarly, it can be run with enableCheckerframework project property. methanol-brotli uses JNI and contains a c/c++ subproject for the brotli decoder. The native project is not included in the build by default. You can do so with project property includeBrotliJni or running the installBrotli task if you have a proper tool chain. Note that brotli isn't yet supported for macOS, so make sure to exclude brotli tests when running from a Mac: ./gradlew check -PenableErrorprone -x methanol-brotli:test Dependencies \u00b6 Methanol makes it easier to use third-party libraries with the HTTP client. However, it does so without making users pay for what they don't need. The core module currently has zero runtime dependencies, and it is important it remains so. Features that require dependencies should be in separate modules, possibly with ServideLoader abstractions introduced in the core (e.g. BodyAdapter , BodyDecoder ). Style \u00b6 The project mostly adheres to the Google Style Guide . Changes are expected to be consistent regarding key style aspects (2 space indentation, 4 for continuation, etc). It is preferable to use google-java-format for new code.","title":"Contributing"},{"location":"CONTRIBUTING/#contributing","text":"Contributions are welcome! It is often a good idea to first discuss changes before submitting them. If you're considering small changes (e.g. in documentation), you can open a PR directly. You are more than welcome to: Report a bug Ask a question Propose a feature Submit a fix Improve documentation","title":"Contributing"},{"location":"CONTRIBUTING/#prerequisites","text":"It is recommended to set the JAVA_HOME environment variable to a JDK 11 (or later) directory in order to properly work with Gradle.","title":"Prerequisites"},{"location":"CONTRIBUTING/#building","text":"Before submitting a change, make sure to first run tests and code analysis. ./gradlew clean check -PenableErrorprone Error-prone checks are included but disabled by default for build speed. It is desirable to make errorprone happy (maybe via reasonable suppressions). Checker Framework is optionally used but mainly for informative reasons (its acts weird and crashes, patches regarding this are welcome). Similarly, it can be run with enableCheckerframework project property. methanol-brotli uses JNI and contains a c/c++ subproject for the brotli decoder. The native project is not included in the build by default. You can do so with project property includeBrotliJni or running the installBrotli task if you have a proper tool chain. Note that brotli isn't yet supported for macOS, so make sure to exclude brotli tests when running from a Mac: ./gradlew check -PenableErrorprone -x methanol-brotli:test","title":"Building"},{"location":"CONTRIBUTING/#dependencies","text":"Methanol makes it easier to use third-party libraries with the HTTP client. However, it does so without making users pay for what they don't need. The core module currently has zero runtime dependencies, and it is important it remains so. Features that require dependencies should be in separate modules, possibly with ServideLoader abstractions introduced in the core (e.g. BodyAdapter , BodyDecoder ).","title":"Dependencies"},{"location":"CONTRIBUTING/#style","text":"The project mostly adheres to the Google Style Guide . Changes are expected to be consistent regarding key style aspects (2 space indentation, 4 for continuation, etc). It is preferable to use google-java-format for new code.","title":"Style"},{"location":"benchmarks/","text":"methanol-benchmarks \u00b6 JMH tests for Methanol's performance. Running Benchmarks \u00b6 Benchmarks are available as a runnable Jar in Maven . You run them as following: java -jar benchmarks-1.7.0-all.jar Results \u00b6 BodyDecoder vs InputStream \u00b6 Compare Methanol's non-blocking decoders with available InputStream ones: Decoder Mode Cnt Score Error Units Gzip BodyDecoder thrpt 5 4170.501 50.458 ops/s GZIPInputStream thrpt 5 4108.730 70.605 ops/s Deflate BodyDecoder thrpt 5 4037.943 51.947 ops/s InflaterInputStream thrpt 5 4035.100 162.641 ops/s Brotli BodyDecoder thrpt 5 4186.791 213.283 ops/s BrotliInputStream thrpt 5 2631.312 136.291 ops/s Results show that BodyDecoder implementations are on par with available InputStream based decoders. Note that the brotli benchmark is biased as it also compares native C vs pure Java implementations.","title":"Benchmarks"},{"location":"benchmarks/#methanol-benchmarks","text":"JMH tests for Methanol's performance.","title":"methanol-benchmarks"},{"location":"benchmarks/#running-benchmarks","text":"Benchmarks are available as a runnable Jar in Maven . You run them as following: java -jar benchmarks-1.7.0-all.jar","title":"Running Benchmarks"},{"location":"benchmarks/#results","text":"","title":"Results"},{"location":"benchmarks/#bodydecoder-vs-inputstream","text":"Compare Methanol's non-blocking decoders with available InputStream ones: Decoder Mode Cnt Score Error Units Gzip BodyDecoder thrpt 5 4170.501 50.458 ops/s GZIPInputStream thrpt 5 4108.730 70.605 ops/s Deflate BodyDecoder thrpt 5 4037.943 51.947 ops/s InflaterInputStream thrpt 5 4035.100 162.641 ops/s Brotli BodyDecoder thrpt 5 4186.791 213.283 ops/s BrotliInputStream thrpt 5 2631.312 136.291 ops/s Results show that BodyDecoder implementations are on par with available InputStream based decoders. Note that the brotli benchmark is biased as it also compares native C vs pure Java implementations.","title":"BodyDecoder vs InputStream"},{"location":"brotli/","text":"methanol-brotli \u00b6 Provides brotli decompression. Installation \u00b6 Gradle \u00b6 implementation 'com.github.mizosoft.methanol:methanol-brotli:1.7.0' Maven \u00b6 <dependency> <groupId> com.github.mizosoft.methanol </groupId> <artifactId> methanol-brotli </artifactId> <version> 1.7.0 </version> </dependency> Implementation notes \u00b6 The Java brotli decoder provided by Google only exposes InputStream APIs. It cannot be used to implement a non-blocking BodyDecoder . The C implementation is used instead through JNI bindings (also provided by Google). To allow multi-platform support, native libraries for each supported OS X Architecture are bundled with the JAR and extracted to a temp directory on use. Supported platforms \u00b6 OS x86 x64 Tool Chain Tested Machines Windows \u2714 \u2714 Visual C++ Windows 10 & CI Linux \u2714 \u2714 GCC 9.2.1 Ubuntu 19.10 & CI Mac OS \u274c \u274c Building from source \u00b6 You can build from source if your platform is not supported. The build routine uses Gradle's native software plugin . You need to have a tool chain that's supported by gradle for your OS. Steps \u00b6 After cloning this repo, run gradle with the installBrotli and assemble tasks: gradlew installBrotli :methanol-brotli:assemble This builds the native libraries and copies them to src/main/resources for inclusion in the JAR. You will find the assembled ready-to-use Jar in the build/libs/ directory.","title":"Brotli"},{"location":"brotli/#methanol-brotli","text":"Provides brotli decompression.","title":"methanol-brotli"},{"location":"brotli/#installation","text":"","title":"Installation"},{"location":"brotli/#gradle","text":"implementation 'com.github.mizosoft.methanol:methanol-brotli:1.7.0'","title":"Gradle"},{"location":"brotli/#maven","text":"<dependency> <groupId> com.github.mizosoft.methanol </groupId> <artifactId> methanol-brotli </artifactId> <version> 1.7.0 </version> </dependency>","title":"Maven"},{"location":"brotli/#implementation-notes","text":"The Java brotli decoder provided by Google only exposes InputStream APIs. It cannot be used to implement a non-blocking BodyDecoder . The C implementation is used instead through JNI bindings (also provided by Google). To allow multi-platform support, native libraries for each supported OS X Architecture are bundled with the JAR and extracted to a temp directory on use.","title":"Implementation notes"},{"location":"brotli/#supported-platforms","text":"OS x86 x64 Tool Chain Tested Machines Windows \u2714 \u2714 Visual C++ Windows 10 & CI Linux \u2714 \u2714 GCC 9.2.1 Ubuntu 19.10 & CI Mac OS \u274c \u274c","title":"Supported platforms"},{"location":"brotli/#building-from-source","text":"You can build from source if your platform is not supported. The build routine uses Gradle's native software plugin . You need to have a tool chain that's supported by gradle for your OS.","title":"Building from source"},{"location":"brotli/#steps","text":"After cloning this repo, run gradle with the installBrotli and assemble tasks: gradlew installBrotli :methanol-brotli:assemble This builds the native libraries and copies them to src/main/resources for inclusion in the JAR. You will find the assembled ready-to-use Jar in the build/libs/ directory.","title":"Steps"},{"location":"caching/","text":"Caching \u00b6 Methanol comes with an RFC-compliant HTTP cache that supports both disk & memory storage backends. Setup \u00b6 An HttpCache is utilized by injecting it into a Methanol client. First, it needs to know where it stores entries and how much space it can occupy. Disk Memory // Select a size limit thats suitable for your application long maxSizeInBytes = 100 * 1024 * 1024 ; // 100 MBs var cache = HttpCache . newBuilder () . cacheOnDisk ( Path . of ( \"my-cache-dir\" ), maxSizeInBytes ) . build (); // The cache intercepts requests you send through this client var client = Methanol . newBuilder () . cache ( cache ) . build (); // It's important that you close the disk cache after you're done cache . close (); // Select a size limit thats suitable for your application long maxSizeInBytes = 50 * 1024 * 1024 ; // 50 MBs var cache = HttpCache . newBuilder () . cacheOnMemory ( maxSizeInBytes ) . build (); // The cache intercepts requests you send through this client var client = Methanol . newBuilder () . cache ( cache ) . build (); // No need to close, but doing so avoids surprises if you later switch to disk cache . close (); Hint You can pass the builder a custom Executor for launching asynchronous tasks needed by the cache. By default, an unbounded thread pool of daemon threads is used. Caution To avoid surprises, make sure the disk directory is exclusively owned by a single cache instance as long as it's open and nothing else. The cache enforces that to some degree by complaining with an IOException if it's initialized with a directory that's already in use by another instance in the same or a different JVM. Note that you can use the same HttpCache with multiple clients. Usage \u00b6 An HTTP cache is a transparent layer between you and the origin server. Its main goal is to save time & bandwidth by avoiding network if requested resources are locally retrievable. It does so while preserving the typical HTTP client-server semantics. Thus, it should be OK for modules to start using a cache-configured Methanol (and hence HttpClient ) instance as a drop-in replacement without further setup. CacheControl \u00b6 Requests override default cache behaviour using CacheControl . CacheControl Cache-Control header // Specify your cache directives var cacheControl = CacheControl . newBuilder () . maxAge ( Duration . ofMinutes ( 30 )) . staleIfError ( Duration . ofSeconds ( 60 )) . build (); // Apply the directives to your request var request = MutableRequest . GET ( \"...\" ) . cacheControl ( cacheControl ); // Cache-Control headers work as well var request = MutableRequest . GET ( \"...\" ) . header ( \"Cache-Control\" , \"max-age=1800, stale-if-error=60\" ); To properly use CacheControl , it is good to understand the key attributes of a cached response. Age \u00b6 The age of a stored response is the time it has been resident in your cache or any other cache along the route to the origin. In other words, a response's age is the time evaluated since it was last generated by the server. Freshness \u00b6 A fresh response is one that is servable by the cache without contacting the origin. A server specifies how long a stored response stays fresh. This is known as the response's freshness lifetime . The freshness value of a response is its age subtracted from its freshness lifetime. A response is fresh if its freshness value is >= 0 . CacheControl lets you override a response's freshness lifetime by setting the max-age directive. var cacheControl = CacheControl . newBuilder () . maxAge ( Duration . ofSeconds ( 10 )) // Override the lifetime set by the server, if any . build (); You can specify how fresh you'd like the response to be by putting a lower bound on its freshness value. var cacheControl = CacheControl . newBuilder () . minFresh ( Duration . ofMinutes ( 10 )) // Accept a response that stays fresh for at least the next 10 minutes . build (); Info Sometimes, a response lacks an explicit freshness lifetime. As encouraged by the standard & followed by browsers, Methanol uses a heuristic of 10% of the time between a response's generation & last modification times in such cases. Staleness \u00b6 Responses with negative freshness values are said to be stale. The staleness value of a stored response is simply its freshness value negated. Normally, the cache won't serve a stale response until it's revalidated with the server. Revalidation causes the cache to ask the server, using special headers like If-None-Match & If-Modified-Since , if it can serve the stale response at its disposal. If the server doesn't mind, the cache serves said response without re-downloading its payload. Otherwise, the response is re-fetched. You can let the cache tolerate some stalness so it doesn't trigger revalidation. Bounded Staleness Arbitrary Staleness var cacheControl = CacheControl . newBuilder () . maxStale ( Duration . ofSeconds ( 30 )) // Allow at most 30 seconds of staleness . build (); var cacheControl = CacheControl . newBuilder () . anyMaxStale () // Allow any staleness . build (); stale-if-error makes the cache recover from network or server failures if there's a stored response. In such occasions, the cache falls back to the stored response if it satisfies the specified staleness. var cacheControl = CacheControl . newBuilder () . staleIfError ( Duration . ofSeconds ( 30 )) . build (); No Cache \u00b6 You might want the cache to forward your request to origin even if there's a fresh stored response (e.g. refreshing a page). That's what no-cache is meant for. var cacheControl = CacheControl . newBuilder () . noCache () . build (); The cache will use network efficiently. If there's a stored response, its presence is communicated to the server, so it can decide to let the cache serve said response if nothing has changed. Only If Cached \u00b6 Use only-if-cached to avoid network in all cases. As usual, a stored response is served if it's suitable. Otherwise, however, the cache immediately serves a locally generated 504 Gateway Timeout response. var cacheControl = CacheControl . newBuilder () . onlyIfCached () . build (); A perfect use-case is when network is down or the app is offline. You'd want to get a cached response if it's there or otherwise nothing. Prohibiting Storage \u00b6 Use no-store if you don't want the cache to store anything about the response. var cacheControl = CacheControl . newBuilder () . noStore () . build (); Note that this, however, doesn't prohibit the cache from serving an already stored response. Asynchronous Revalidation \u00b6 Sometimes you need a balance between responsiveness & freshness. You are willing to get a response immediately even if it's stale, but ensure it is freshened for later access. That's exactly what stale-while-revalidate does. If the directive is found on a stale response, the cache serves it immediately provided it satisfies allowed staleness. What's interesting is that an asynchronous revalidation is triggered and the response is updated in background, keeping things fresh. Invalidation \u00b6 HttpCache has APIs that give you more control over what's stored. var cache = HttpCache . newBuilder () . cacheOnDisk ( Path . of ( \"my-cache-dir\" ), 100 * 1024 * 1024 ) . build (); // Remove the entry mapped to a particular URI cache . remove ( URI . create ( \"https://i.imgur.com/NYvl8Sy.mp4\" )); // Remove the response variant matching a particular request cache . remove ( MutableRequest . GET ( URI . create ( \"https://i.imgur.com/NYvl8Sy.mp4\" )) . header ( \"Accept-Encoding\" , \"gzip\" )); // Remove specific entries by examining their URIs var iterator = cache . uris (); while ( iterator . hasNext ()) { var uri = iterator . next (); if ( uri . getHost (). equals ( \"i.imgur.com\" )) { iterator . remove (); } } // Remove all entries cache . clear (); // Dispose of the cache by deleting its entries then closing it in an atomic fashion. // The cache is rendered unusable after this call. This is meant for applications that // use a temporary directory for caching in case persistence isn't needed. cache . dispose (); Cache Operation & Statistics \u00b6 Cache operation typically involves 3 scenarios. Cache Hit : The blessed scenario; everything was entirely served from cache and no network was used. Conditional Cache Hit : The cache had to contact the origin to revalidate its copy of the response and the server decided it was valid. The cache uses server's response to update some metadata in background. Response payload isn't downloaded so network is used efficiently. Cache Miss : Either the cache had no matching response or the server decided such response is too stale to be server. In both cases, the whole response is fetched from network. This is when the cache populates or updates its entries if appropriate. CacheAwareResponse \u00b6 CacheAwareResponse complements HttpResponse to better reflect cache interference. If a cache is installed, any HttpResponse<T> returned by Methanol is also a CacheAwareResponse<T> , which you can use to know which of the previous scenarios was the case. var cache = HttpCache . newBuilder () . cacheOnDisk ( Path . of ( \"my-cache-dir\" ), 100 * 1024 * 1024 ) . build (); var client = Methanol . newBuilder () . cache ( cache ) . build (); var response = ( CacheAwareResponse < Path > ) client . send ( MutableRequest . GET ( \"https://i.imgur.com/NYvl8Sy.mp4\" ), BodyHandlers . ofFile ( Path . of ( \"banana_cat.mp4\" ))); var timeElapsed = Duration . between ( response . timeRequestSent (), response . timeResponseReceived ()); System . out . println ( \"Time elapsed: \" + timeElapsed ); // networkResponse & cacheResponse are optional HttpResponses that you can further investigate var networkResponse = response . networkResponse (); var cacheResponse = response . cacheResponse (); switch ( response . cacheStatus ()) { case HIT : assert networkResponse . isEmpty (); assert cacheResponse . isPresent (); break ; case CONDITIONAL_HIT : assert networkResponse . isPresent (); assert cacheResponse . isPresent (); break ; case MISS : assert networkResponse . isPresent (); // cacheResponse can be absent or present break ; case UNSATISFIABLE : // Network was forbidden by only-if-cached but there was no valid cache response assert response . statusCode () == HttpURLConnection . HTTP_GATEWAY_TIMEOUT ; assert networkResponse . isEmpty (); // cacheResponse can be absent or present break ; } cache . close (); HttpCache.Stats \u00b6 You can examine cache statistics to measure its effectiveness. Statistics are either global or correspond to a specific URI . Global Stats URI-specific Stats var cache = HttpCache . newBuilder () . cacheOnDisk ( Path . of ( \"my-cache-dir\" ), 100 * 1024 * 1024 ) . build (); var stats = cache . stats (); System . out . println ( stats . hitRate ()); System . out . println ( stats . missRate ()); // Per URI statistics aren't recorder by default var cache = HttpCache . newBuilder () . cacheOnDisk ( Path . of ( \"my-cache-dir\" ), 100 * 1024 * 1024 ) . statsRecorder ( StatsRecorder . createConcurrentPerUriRecorder ()) . build (); var stats = cache . stats ( URI . create ( \"https://i.imgur.com/NYvl8Sy.mp4\" )); System . out . println ( stats . hitRate ()); System . out . println ( stats . missRate ()); See HttpCache.Stats for all recorded statistics. Limitations \u00b6 The cache only stores responses to GETs. This is typical for most caches. The cache never stores partial responses . Only the most recent response variant can be stored. The cache doesn't store responses that have a Vary header with any of the values: Cookie , Cookie2 , Authorization , Proxy-Authroization . That's because the HttpClient can implicitly add these to requests, so Methanol won't be able to access their values to match responses against.","title":"Caching"},{"location":"caching/#caching","text":"Methanol comes with an RFC-compliant HTTP cache that supports both disk & memory storage backends.","title":"Caching"},{"location":"caching/#setup","text":"An HttpCache is utilized by injecting it into a Methanol client. First, it needs to know where it stores entries and how much space it can occupy. Disk Memory // Select a size limit thats suitable for your application long maxSizeInBytes = 100 * 1024 * 1024 ; // 100 MBs var cache = HttpCache . newBuilder () . cacheOnDisk ( Path . of ( \"my-cache-dir\" ), maxSizeInBytes ) . build (); // The cache intercepts requests you send through this client var client = Methanol . newBuilder () . cache ( cache ) . build (); // It's important that you close the disk cache after you're done cache . close (); // Select a size limit thats suitable for your application long maxSizeInBytes = 50 * 1024 * 1024 ; // 50 MBs var cache = HttpCache . newBuilder () . cacheOnMemory ( maxSizeInBytes ) . build (); // The cache intercepts requests you send through this client var client = Methanol . newBuilder () . cache ( cache ) . build (); // No need to close, but doing so avoids surprises if you later switch to disk cache . close (); Hint You can pass the builder a custom Executor for launching asynchronous tasks needed by the cache. By default, an unbounded thread pool of daemon threads is used. Caution To avoid surprises, make sure the disk directory is exclusively owned by a single cache instance as long as it's open and nothing else. The cache enforces that to some degree by complaining with an IOException if it's initialized with a directory that's already in use by another instance in the same or a different JVM. Note that you can use the same HttpCache with multiple clients.","title":"Setup"},{"location":"caching/#usage","text":"An HTTP cache is a transparent layer between you and the origin server. Its main goal is to save time & bandwidth by avoiding network if requested resources are locally retrievable. It does so while preserving the typical HTTP client-server semantics. Thus, it should be OK for modules to start using a cache-configured Methanol (and hence HttpClient ) instance as a drop-in replacement without further setup.","title":"Usage"},{"location":"caching/#cachecontrol","text":"Requests override default cache behaviour using CacheControl . CacheControl Cache-Control header // Specify your cache directives var cacheControl = CacheControl . newBuilder () . maxAge ( Duration . ofMinutes ( 30 )) . staleIfError ( Duration . ofSeconds ( 60 )) . build (); // Apply the directives to your request var request = MutableRequest . GET ( \"...\" ) . cacheControl ( cacheControl ); // Cache-Control headers work as well var request = MutableRequest . GET ( \"...\" ) . header ( \"Cache-Control\" , \"max-age=1800, stale-if-error=60\" ); To properly use CacheControl , it is good to understand the key attributes of a cached response.","title":"CacheControl"},{"location":"caching/#age","text":"The age of a stored response is the time it has been resident in your cache or any other cache along the route to the origin. In other words, a response's age is the time evaluated since it was last generated by the server.","title":"Age"},{"location":"caching/#freshness","text":"A fresh response is one that is servable by the cache without contacting the origin. A server specifies how long a stored response stays fresh. This is known as the response's freshness lifetime . The freshness value of a response is its age subtracted from its freshness lifetime. A response is fresh if its freshness value is >= 0 . CacheControl lets you override a response's freshness lifetime by setting the max-age directive. var cacheControl = CacheControl . newBuilder () . maxAge ( Duration . ofSeconds ( 10 )) // Override the lifetime set by the server, if any . build (); You can specify how fresh you'd like the response to be by putting a lower bound on its freshness value. var cacheControl = CacheControl . newBuilder () . minFresh ( Duration . ofMinutes ( 10 )) // Accept a response that stays fresh for at least the next 10 minutes . build (); Info Sometimes, a response lacks an explicit freshness lifetime. As encouraged by the standard & followed by browsers, Methanol uses a heuristic of 10% of the time between a response's generation & last modification times in such cases.","title":"Freshness"},{"location":"caching/#staleness","text":"Responses with negative freshness values are said to be stale. The staleness value of a stored response is simply its freshness value negated. Normally, the cache won't serve a stale response until it's revalidated with the server. Revalidation causes the cache to ask the server, using special headers like If-None-Match & If-Modified-Since , if it can serve the stale response at its disposal. If the server doesn't mind, the cache serves said response without re-downloading its payload. Otherwise, the response is re-fetched. You can let the cache tolerate some stalness so it doesn't trigger revalidation. Bounded Staleness Arbitrary Staleness var cacheControl = CacheControl . newBuilder () . maxStale ( Duration . ofSeconds ( 30 )) // Allow at most 30 seconds of staleness . build (); var cacheControl = CacheControl . newBuilder () . anyMaxStale () // Allow any staleness . build (); stale-if-error makes the cache recover from network or server failures if there's a stored response. In such occasions, the cache falls back to the stored response if it satisfies the specified staleness. var cacheControl = CacheControl . newBuilder () . staleIfError ( Duration . ofSeconds ( 30 )) . build ();","title":"Staleness"},{"location":"caching/#no-cache","text":"You might want the cache to forward your request to origin even if there's a fresh stored response (e.g. refreshing a page). That's what no-cache is meant for. var cacheControl = CacheControl . newBuilder () . noCache () . build (); The cache will use network efficiently. If there's a stored response, its presence is communicated to the server, so it can decide to let the cache serve said response if nothing has changed.","title":"No Cache"},{"location":"caching/#only-if-cached","text":"Use only-if-cached to avoid network in all cases. As usual, a stored response is served if it's suitable. Otherwise, however, the cache immediately serves a locally generated 504 Gateway Timeout response. var cacheControl = CacheControl . newBuilder () . onlyIfCached () . build (); A perfect use-case is when network is down or the app is offline. You'd want to get a cached response if it's there or otherwise nothing.","title":"Only If Cached"},{"location":"caching/#prohibiting-storage","text":"Use no-store if you don't want the cache to store anything about the response. var cacheControl = CacheControl . newBuilder () . noStore () . build (); Note that this, however, doesn't prohibit the cache from serving an already stored response.","title":"Prohibiting Storage"},{"location":"caching/#asynchronous-revalidation","text":"Sometimes you need a balance between responsiveness & freshness. You are willing to get a response immediately even if it's stale, but ensure it is freshened for later access. That's exactly what stale-while-revalidate does. If the directive is found on a stale response, the cache serves it immediately provided it satisfies allowed staleness. What's interesting is that an asynchronous revalidation is triggered and the response is updated in background, keeping things fresh.","title":"Asynchronous Revalidation"},{"location":"caching/#invalidation","text":"HttpCache has APIs that give you more control over what's stored. var cache = HttpCache . newBuilder () . cacheOnDisk ( Path . of ( \"my-cache-dir\" ), 100 * 1024 * 1024 ) . build (); // Remove the entry mapped to a particular URI cache . remove ( URI . create ( \"https://i.imgur.com/NYvl8Sy.mp4\" )); // Remove the response variant matching a particular request cache . remove ( MutableRequest . GET ( URI . create ( \"https://i.imgur.com/NYvl8Sy.mp4\" )) . header ( \"Accept-Encoding\" , \"gzip\" )); // Remove specific entries by examining their URIs var iterator = cache . uris (); while ( iterator . hasNext ()) { var uri = iterator . next (); if ( uri . getHost (). equals ( \"i.imgur.com\" )) { iterator . remove (); } } // Remove all entries cache . clear (); // Dispose of the cache by deleting its entries then closing it in an atomic fashion. // The cache is rendered unusable after this call. This is meant for applications that // use a temporary directory for caching in case persistence isn't needed. cache . dispose ();","title":"Invalidation"},{"location":"caching/#cache-operation-statistics","text":"Cache operation typically involves 3 scenarios. Cache Hit : The blessed scenario; everything was entirely served from cache and no network was used. Conditional Cache Hit : The cache had to contact the origin to revalidate its copy of the response and the server decided it was valid. The cache uses server's response to update some metadata in background. Response payload isn't downloaded so network is used efficiently. Cache Miss : Either the cache had no matching response or the server decided such response is too stale to be server. In both cases, the whole response is fetched from network. This is when the cache populates or updates its entries if appropriate.","title":"Cache Operation &amp; Statistics"},{"location":"caching/#cacheawareresponse","text":"CacheAwareResponse complements HttpResponse to better reflect cache interference. If a cache is installed, any HttpResponse<T> returned by Methanol is also a CacheAwareResponse<T> , which you can use to know which of the previous scenarios was the case. var cache = HttpCache . newBuilder () . cacheOnDisk ( Path . of ( \"my-cache-dir\" ), 100 * 1024 * 1024 ) . build (); var client = Methanol . newBuilder () . cache ( cache ) . build (); var response = ( CacheAwareResponse < Path > ) client . send ( MutableRequest . GET ( \"https://i.imgur.com/NYvl8Sy.mp4\" ), BodyHandlers . ofFile ( Path . of ( \"banana_cat.mp4\" ))); var timeElapsed = Duration . between ( response . timeRequestSent (), response . timeResponseReceived ()); System . out . println ( \"Time elapsed: \" + timeElapsed ); // networkResponse & cacheResponse are optional HttpResponses that you can further investigate var networkResponse = response . networkResponse (); var cacheResponse = response . cacheResponse (); switch ( response . cacheStatus ()) { case HIT : assert networkResponse . isEmpty (); assert cacheResponse . isPresent (); break ; case CONDITIONAL_HIT : assert networkResponse . isPresent (); assert cacheResponse . isPresent (); break ; case MISS : assert networkResponse . isPresent (); // cacheResponse can be absent or present break ; case UNSATISFIABLE : // Network was forbidden by only-if-cached but there was no valid cache response assert response . statusCode () == HttpURLConnection . HTTP_GATEWAY_TIMEOUT ; assert networkResponse . isEmpty (); // cacheResponse can be absent or present break ; } cache . close ();","title":"CacheAwareResponse"},{"location":"caching/#httpcachestats","text":"You can examine cache statistics to measure its effectiveness. Statistics are either global or correspond to a specific URI . Global Stats URI-specific Stats var cache = HttpCache . newBuilder () . cacheOnDisk ( Path . of ( \"my-cache-dir\" ), 100 * 1024 * 1024 ) . build (); var stats = cache . stats (); System . out . println ( stats . hitRate ()); System . out . println ( stats . missRate ()); // Per URI statistics aren't recorder by default var cache = HttpCache . newBuilder () . cacheOnDisk ( Path . of ( \"my-cache-dir\" ), 100 * 1024 * 1024 ) . statsRecorder ( StatsRecorder . createConcurrentPerUriRecorder ()) . build (); var stats = cache . stats ( URI . create ( \"https://i.imgur.com/NYvl8Sy.mp4\" )); System . out . println ( stats . hitRate ()); System . out . println ( stats . missRate ()); See HttpCache.Stats for all recorded statistics.","title":"HttpCache.Stats"},{"location":"caching/#limitations","text":"The cache only stores responses to GETs. This is typical for most caches. The cache never stores partial responses . Only the most recent response variant can be stored. The cache doesn't store responses that have a Vary header with any of the values: Cookie , Cookie2 , Authorization , Proxy-Authroization . That's because the HttpClient can implicitly add these to requests, so Methanol won't be able to access their values to match responses against.","title":"Limitations"},{"location":"decompression/","text":"Response Decompression \u00b6 One caveat concerning Java's HTTP client is the lack of support for automatic response decompression. A workaround is to use an available InputStream decompressor (e.g. GZIPInputStream ) that matches response's Content-Encoding . However, such approach is invasive as it forces us to deal with InputStreams . The straightforward and recommended solution is to use Methanol's enhanced HTTP client , which gives you transparent response decompression for gzip & deflate out of the box. final Methanol client = Methanol . create (); < T > HttpResponse < T > get ( String url , BodyHandler < T > bodyHandler ) throws IOException , InterruptedException { // No need to worry about adding Accept-Encoding and // decompressing the response. The client does that for you! return client . send ( MutableRequest . GET ( url ), bodyHandler ); } Read on if you're interested in knowing how that's accomplished or you want to extend decompression support. Decoding BodyHandler \u00b6 The entry point to response body decompression is MoreBodyHandlers::decoding . This method takes your desired BodyHandler and gives you one that decompresses the response body as your handler's BodySubscriber receives it. var response = client . send ( request , MoreBodyHandlers . decoding ( BodyHandlers . ofString ())); Note that it doesn't matter which BodyHandler you're using; you can have whatever response body type you want. BodyDecoder \u00b6 A BodyDecoder is a BodySubscriber with the added semantics of a Flow.Processor . It intercepts the flow of bytes on its way down from the HTTP client, decoding each List<ByteBuffer> individually. The decoded bytes are forwarded to a downstream BodySubscriber , which converts them into the desired response body. A BodyDecoder.Factory associates itself with a defined encoding that's suitable as a Content-Encoding directive. Given a downstream BodySubscriber , the factory creates a BodyDecoder that forwards the response body after decoding it using the factory's encoding. For instance, a factory associated with gzip creates decoders that decompress the response using the gzip format . Factory Lookup \u00b6 Factories are installed as service-providers in the manner specified by Java's ServiceLoader . A decoding BodyHandler looks up a factory associated with response's Content-Encoding . If found, it's called to wrap user's BodySubscriber , so it receives the decompressed body. Otherwise, an UnsupportedOperationException is thrown. Supported Encodings \u00b6 The core module has support for gzip & deflate out of the box. There's also a separate module providing support for brotli . Extending decompression support \u00b6 Adding support for more encodings or overriding supported ones is a matter of writing a BodyDecoder implementation and providing a corresponding factory. However, implementing the decoder's Flow.Publisher semantics can be tricky. Instead, implement an AsyncDecoder and wrap it in an AsyncBodyDecoder , so you're only concerned with your decompression logic. Writing an AsyncDecoder \u00b6 Decoding is done as a number of decode(source, sink) rounds finalized by one final round, each with the currently available input. After the final round, your AsyncDecoder must've completely exhausted its source. Here's a decoder implementation that uses jzlib for gzip & deflate decompression. class JZlibDecoder implements AsyncDecoder { private static final int BUFFER_SIZE = 8096 ; private final String encoding ; private final com . jcraft . jzlib . Inflater inflater ; private final ByteBuffer input = ByteBuffer . allocate ( BUFFER_SIZE ); private final ByteBuffer output = ByteBuffer . allocate ( BUFFER_SIZE ); JZlibDecoder ( String encoding , com . jcraft . jzlib . JZlib . WrapperType wrapperType ) { try { this . encoding = encoding ; inflater = new com . jcraft . jzlib . Inflater ( wrapperType ); inflater . setInput ( input . array ()); inflater . setOutput ( output . array ()); } catch ( com . jcraft . jzlib . GZIPException e ) { throw new RuntimeException ( e ); } } @Override public String encoding () { return encoding ; } @Override public void decode ( ByteSource source , ByteSink sink ) throws IOException { synchronized ( inflater ) { while ( source . hasRemaining ()) { // Prepare input for this iteration refillInput ( source ); inflater . setNextInIndex ( 0 ); inflater . setAvailIn ( input . limit ()); // Continue inflating as long as there's more input or there's pending output boolean mightHavePendingOutput = false ; inflateLoop : while ( inflater . getAvailIn () > 0 || mightHavePendingOutput ) { // Prepare for new output inflater . setNextOutIndex ( 0 ); inflater . setAvailOut ( output . capacity ()); int status = inflater . inflate ( com . jcraft . jzlib . JZlib . Z_SYNC_FLUSH ); int outputCount = inflater . getNextOutIndex (); sink . pushBytes ( output . position ( 0 ). limit ( outputCount )); switch ( status ) { case com . jcraft . jzlib . JZlib . Z_OK : mightHavePendingOutput = inflater . getAvailOut () == 0 ; break ; case com . jcraft . jzlib . JZlib . Z_STREAM_END : // The compressed stream has ended break inflateLoop ; default : throw new IOException ( \"problem with zlib: \" + Integer . toHexString ( status )); } } } } } private void refillInput ( ByteSource source ) { input . clear (); source . pullBytes ( input ); input . flip (); } @Override public synchronized void close () { synchronized ( inflater ) { inflater . end (); } } } Registering a Factory \u00b6 Here's a BodyDecoder.Factory for gzip using our jzlib decoder. public static final class MyDecoderFactory implements BodyDecoder . Factory { @Override public String encoding () { return \"gzip\" ; } @Override public < T > BodyDecoder < T > create ( BodySubscriber < T > downstream ) { return new AsyncBodyDecoder <> ( new JZlibDecoder ( \"gzip\" , com . jcraft . jzlib . JZlib . WrapperType . GZIP ), downstream ); } @Override public < T > BodyDecoder < T > create ( BodySubscriber < T > downstream , Executor executor ) { return new AsyncBodyDecoder <> ( new JZlibDecoder ( \"gzip\" , com . jcraft . jzlib . JZlib . WrapperType . GZIP ), downstream ); } } The next step is to declare your factory as a service-provider. For instance, here's an appropriate provides...with declaration to put in module-info.java if your application uses Java modules. module my . module { ... provides BodyDecoder . Factory with MyDecoderFactory ; }","title":"Decompression"},{"location":"decompression/#response-decompression","text":"One caveat concerning Java's HTTP client is the lack of support for automatic response decompression. A workaround is to use an available InputStream decompressor (e.g. GZIPInputStream ) that matches response's Content-Encoding . However, such approach is invasive as it forces us to deal with InputStreams . The straightforward and recommended solution is to use Methanol's enhanced HTTP client , which gives you transparent response decompression for gzip & deflate out of the box. final Methanol client = Methanol . create (); < T > HttpResponse < T > get ( String url , BodyHandler < T > bodyHandler ) throws IOException , InterruptedException { // No need to worry about adding Accept-Encoding and // decompressing the response. The client does that for you! return client . send ( MutableRequest . GET ( url ), bodyHandler ); } Read on if you're interested in knowing how that's accomplished or you want to extend decompression support.","title":"Response Decompression"},{"location":"decompression/#decoding-bodyhandler","text":"The entry point to response body decompression is MoreBodyHandlers::decoding . This method takes your desired BodyHandler and gives you one that decompresses the response body as your handler's BodySubscriber receives it. var response = client . send ( request , MoreBodyHandlers . decoding ( BodyHandlers . ofString ())); Note that it doesn't matter which BodyHandler you're using; you can have whatever response body type you want.","title":"Decoding BodyHandler"},{"location":"decompression/#bodydecoder","text":"A BodyDecoder is a BodySubscriber with the added semantics of a Flow.Processor . It intercepts the flow of bytes on its way down from the HTTP client, decoding each List<ByteBuffer> individually. The decoded bytes are forwarded to a downstream BodySubscriber , which converts them into the desired response body. A BodyDecoder.Factory associates itself with a defined encoding that's suitable as a Content-Encoding directive. Given a downstream BodySubscriber , the factory creates a BodyDecoder that forwards the response body after decoding it using the factory's encoding. For instance, a factory associated with gzip creates decoders that decompress the response using the gzip format .","title":"BodyDecoder"},{"location":"decompression/#factory-lookup","text":"Factories are installed as service-providers in the manner specified by Java's ServiceLoader . A decoding BodyHandler looks up a factory associated with response's Content-Encoding . If found, it's called to wrap user's BodySubscriber , so it receives the decompressed body. Otherwise, an UnsupportedOperationException is thrown.","title":"Factory Lookup"},{"location":"decompression/#supported-encodings","text":"The core module has support for gzip & deflate out of the box. There's also a separate module providing support for brotli .","title":"Supported Encodings"},{"location":"decompression/#extending-decompression-support","text":"Adding support for more encodings or overriding supported ones is a matter of writing a BodyDecoder implementation and providing a corresponding factory. However, implementing the decoder's Flow.Publisher semantics can be tricky. Instead, implement an AsyncDecoder and wrap it in an AsyncBodyDecoder , so you're only concerned with your decompression logic.","title":"Extending decompression support"},{"location":"decompression/#writing-an-asyncdecoder","text":"Decoding is done as a number of decode(source, sink) rounds finalized by one final round, each with the currently available input. After the final round, your AsyncDecoder must've completely exhausted its source. Here's a decoder implementation that uses jzlib for gzip & deflate decompression. class JZlibDecoder implements AsyncDecoder { private static final int BUFFER_SIZE = 8096 ; private final String encoding ; private final com . jcraft . jzlib . Inflater inflater ; private final ByteBuffer input = ByteBuffer . allocate ( BUFFER_SIZE ); private final ByteBuffer output = ByteBuffer . allocate ( BUFFER_SIZE ); JZlibDecoder ( String encoding , com . jcraft . jzlib . JZlib . WrapperType wrapperType ) { try { this . encoding = encoding ; inflater = new com . jcraft . jzlib . Inflater ( wrapperType ); inflater . setInput ( input . array ()); inflater . setOutput ( output . array ()); } catch ( com . jcraft . jzlib . GZIPException e ) { throw new RuntimeException ( e ); } } @Override public String encoding () { return encoding ; } @Override public void decode ( ByteSource source , ByteSink sink ) throws IOException { synchronized ( inflater ) { while ( source . hasRemaining ()) { // Prepare input for this iteration refillInput ( source ); inflater . setNextInIndex ( 0 ); inflater . setAvailIn ( input . limit ()); // Continue inflating as long as there's more input or there's pending output boolean mightHavePendingOutput = false ; inflateLoop : while ( inflater . getAvailIn () > 0 || mightHavePendingOutput ) { // Prepare for new output inflater . setNextOutIndex ( 0 ); inflater . setAvailOut ( output . capacity ()); int status = inflater . inflate ( com . jcraft . jzlib . JZlib . Z_SYNC_FLUSH ); int outputCount = inflater . getNextOutIndex (); sink . pushBytes ( output . position ( 0 ). limit ( outputCount )); switch ( status ) { case com . jcraft . jzlib . JZlib . Z_OK : mightHavePendingOutput = inflater . getAvailOut () == 0 ; break ; case com . jcraft . jzlib . JZlib . Z_STREAM_END : // The compressed stream has ended break inflateLoop ; default : throw new IOException ( \"problem with zlib: \" + Integer . toHexString ( status )); } } } } } private void refillInput ( ByteSource source ) { input . clear (); source . pullBytes ( input ); input . flip (); } @Override public synchronized void close () { synchronized ( inflater ) { inflater . end (); } } }","title":"Writing an AsyncDecoder"},{"location":"decompression/#registering-a-factory","text":"Here's a BodyDecoder.Factory for gzip using our jzlib decoder. public static final class MyDecoderFactory implements BodyDecoder . Factory { @Override public String encoding () { return \"gzip\" ; } @Override public < T > BodyDecoder < T > create ( BodySubscriber < T > downstream ) { return new AsyncBodyDecoder <> ( new JZlibDecoder ( \"gzip\" , com . jcraft . jzlib . JZlib . WrapperType . GZIP ), downstream ); } @Override public < T > BodyDecoder < T > create ( BodySubscriber < T > downstream , Executor executor ) { return new AsyncBodyDecoder <> ( new JZlibDecoder ( \"gzip\" , com . jcraft . jzlib . JZlib . WrapperType . GZIP ), downstream ); } } The next step is to declare your factory as a service-provider. For instance, here's an appropriate provides...with declaration to put in module-info.java if your application uses Java modules. module my . module { ... provides BodyDecoder . Factory with MyDecoderFactory ; }","title":"Registering a Factory"},{"location":"enhanced_httpclient/","text":"Enhanced HttpClient \u00b6 Methanol has a special HttpClient that extends the standard one with interesting new features. Unsurprisingly, the client is named Methanol . Usage \u00b6 In addition to interceptors and caching , Methanol can apply default properties to your requests. Think resolving with a base URI, adding default request headers, default timeouts, etc. var builder = Methanol . newBuilder () . cache (...) . interceptor (...) . userAgent ( \"Will Smith\" ) // Custom User-Agent . baseUri ( \"https://api.github.com\" ) // Base URI to resolve requests' URI against . defaultHeader ( \"Accept\" , \"application/json\" ) // Default request headers . requestTimeout ( Duration . ofSeconds ( 20 )) // Default request timeout . readTimeout ( Duration . ofSeconds ( 5 )) // Timeout for single reads . autoAcceptEncoding ( true ); // Transparent response compression, this is true by default // Continue using as a standard HttpClient.Builder! var client = builder . executor (...) . executor ( Executors . newFixedThreadPool ( 16 )) . connectTimeout ( Duration . ofSeconds ( 30 )) ... . build (); You can also build from an existing HttpClient instance. However, you can't install an HttpCache in such case. HttpClient prebuiltClient = ... var client = Methanol . newBuilder ( prebuiltClient ) . interceptor (...) . userAgent ( \"Will Smith\" ) ... . build (); Tip Methanol is an HttpClient . It implements the same API like send & sendAsync , which you can continue using as usual. Note Default properties don't override those the request already has. For instance, a client with a default Accept: text/html will not override a request's Accept: application/json . Transparent Compression \u00b6 If autoAcceptEncoding is enabled, the client complements requests with an Accept-Encoding header which accepts all supported encodings (i.e. available BodyDecoder providers). Additionally, the response is transparently decompressed according to its Content-Encoding . Since deflate & gzip are supported out of the box, they're always included in Accept-Encoding . For instance, if brotli is installed, requests will typically have: Accept-Encoding: deflate, gzip, br . If you want specific encodings to be applied, add Accept-Encoding as a default header or explicitly set one in your request. Default Header Request Header // Advertise brotli decompression var client = Methanol . newBuilder () . defaultHeader ( \"Accept-Encoding\" , \"br\" ) . build (); // Advertise brotli decompression var request = MutableRequest . GET ( uri ) . header ( \"Accept-Encoding\" , \"br\" ); MimeBodyPublisher \u00b6 Methanol automatically sets a request's Content-Type if it has a MimeBodyPublisher . If the request already has a Content-Type , it's overwritten. This makes sense as a body knows its media type better than a containing request mistakenly setting a different one. Reactive Dispatching \u00b6 If you like reactive streams, use Methanol::exchange , which is like sendAsync but returns Publisher<HttpResponse<T>> sources instead. Without HTTP/2 Push With HTTP/2 Push var client = Methanol . create (); var request = MutableRequest . GET ( \"https://http2-push.appspot.com/?nopush\" ); var publisher = client . exchange ( request , BodyHandlers . ofFile ( Path . of ( \"page.html\" ))); JdkFlowAdapter . flowPublisherToFlux ( publisher ) . doOnNext ( response -> System . out . printf ( \"%s: %s\" , response , response . body ())) . blockLast (); var client = Methanol . create (); var request = MutableRequest . GET ( \"https://http2-push.appspot.com\" ); var publisher = client . exchange ( request , BodyHandlers . ofFile ( Path . of ( \"page.html\" )), pushPromise -> BodyHandlers . ofFile ( Path . of ( pushPromise . uri (). getPath ()). getFileName ())); JdkFlowAdapter . flowPublisherToFlux ( publisher ) . doOnNext ( response -> System . out . printf ( \"%s: %s%n\" , response , response . body ())) . blockLast (); MutableRequest \u00b6 MutableRequest is an HttpRequest that implements HttpRequest.Builder for settings request's properties. This drops immutability in favor of some convenience when the request is sent immediately. var response = client . send ( MutableReqeust . GET ( uri ), BodyHandlers . ofString ()); Additionally, MutableRequest accepts relative URIs (standard HttpRequest.Builder doesn't). This is a complementing feature to Methanol 's base URIs, against which relative ones are resolved. Tip You can use MutableRequest::toImmutableRequest to get an immutable HttpRequest snapshot.","title":"Enhanced HttpClient"},{"location":"enhanced_httpclient/#enhanced-httpclient","text":"Methanol has a special HttpClient that extends the standard one with interesting new features. Unsurprisingly, the client is named Methanol .","title":"Enhanced HttpClient"},{"location":"enhanced_httpclient/#usage","text":"In addition to interceptors and caching , Methanol can apply default properties to your requests. Think resolving with a base URI, adding default request headers, default timeouts, etc. var builder = Methanol . newBuilder () . cache (...) . interceptor (...) . userAgent ( \"Will Smith\" ) // Custom User-Agent . baseUri ( \"https://api.github.com\" ) // Base URI to resolve requests' URI against . defaultHeader ( \"Accept\" , \"application/json\" ) // Default request headers . requestTimeout ( Duration . ofSeconds ( 20 )) // Default request timeout . readTimeout ( Duration . ofSeconds ( 5 )) // Timeout for single reads . autoAcceptEncoding ( true ); // Transparent response compression, this is true by default // Continue using as a standard HttpClient.Builder! var client = builder . executor (...) . executor ( Executors . newFixedThreadPool ( 16 )) . connectTimeout ( Duration . ofSeconds ( 30 )) ... . build (); You can also build from an existing HttpClient instance. However, you can't install an HttpCache in such case. HttpClient prebuiltClient = ... var client = Methanol . newBuilder ( prebuiltClient ) . interceptor (...) . userAgent ( \"Will Smith\" ) ... . build (); Tip Methanol is an HttpClient . It implements the same API like send & sendAsync , which you can continue using as usual. Note Default properties don't override those the request already has. For instance, a client with a default Accept: text/html will not override a request's Accept: application/json .","title":"Usage"},{"location":"enhanced_httpclient/#transparent-compression","text":"If autoAcceptEncoding is enabled, the client complements requests with an Accept-Encoding header which accepts all supported encodings (i.e. available BodyDecoder providers). Additionally, the response is transparently decompressed according to its Content-Encoding . Since deflate & gzip are supported out of the box, they're always included in Accept-Encoding . For instance, if brotli is installed, requests will typically have: Accept-Encoding: deflate, gzip, br . If you want specific encodings to be applied, add Accept-Encoding as a default header or explicitly set one in your request. Default Header Request Header // Advertise brotli decompression var client = Methanol . newBuilder () . defaultHeader ( \"Accept-Encoding\" , \"br\" ) . build (); // Advertise brotli decompression var request = MutableRequest . GET ( uri ) . header ( \"Accept-Encoding\" , \"br\" );","title":"Transparent Compression"},{"location":"enhanced_httpclient/#mimebodypublisher","text":"Methanol automatically sets a request's Content-Type if it has a MimeBodyPublisher . If the request already has a Content-Type , it's overwritten. This makes sense as a body knows its media type better than a containing request mistakenly setting a different one.","title":"MimeBodyPublisher"},{"location":"enhanced_httpclient/#reactive-dispatching","text":"If you like reactive streams, use Methanol::exchange , which is like sendAsync but returns Publisher<HttpResponse<T>> sources instead. Without HTTP/2 Push With HTTP/2 Push var client = Methanol . create (); var request = MutableRequest . GET ( \"https://http2-push.appspot.com/?nopush\" ); var publisher = client . exchange ( request , BodyHandlers . ofFile ( Path . of ( \"page.html\" ))); JdkFlowAdapter . flowPublisherToFlux ( publisher ) . doOnNext ( response -> System . out . printf ( \"%s: %s\" , response , response . body ())) . blockLast (); var client = Methanol . create (); var request = MutableRequest . GET ( \"https://http2-push.appspot.com\" ); var publisher = client . exchange ( request , BodyHandlers . ofFile ( Path . of ( \"page.html\" )), pushPromise -> BodyHandlers . ofFile ( Path . of ( pushPromise . uri (). getPath ()). getFileName ())); JdkFlowAdapter . flowPublisherToFlux ( publisher ) . doOnNext ( response -> System . out . printf ( \"%s: %s%n\" , response , response . body ())) . blockLast ();","title":"Reactive Dispatching"},{"location":"enhanced_httpclient/#mutablerequest","text":"MutableRequest is an HttpRequest that implements HttpRequest.Builder for settings request's properties. This drops immutability in favor of some convenience when the request is sent immediately. var response = client . send ( MutableReqeust . GET ( uri ), BodyHandlers . ofString ()); Additionally, MutableRequest accepts relative URIs (standard HttpRequest.Builder doesn't). This is a complementing feature to Methanol 's base URIs, against which relative ones are resolved. Tip You can use MutableRequest::toImmutableRequest to get an immutable HttpRequest snapshot.","title":"MutableRequest"},{"location":"interceptors/","text":"Interceptors \u00b6 Interceptors allow you to inspect, mutate, retry and short-circuit HTTP calls. Together, interceptors build an invocation chain that's capable of applying powerful transformations to requests moving forward and to responses in their way back. Writing Interceptors \u00b6 Interceptors sit between a Methanol client and its underlying HttpClient , referred to as its backend. When registered, an interceptor is invoked each send or sendAsync call. Here's an interceptor that logs requests and their responses. public final class LoggingInterceptor implements Methanol . Interceptor { private static final Logger logger = Logger . getLogger ( LoggingInterceptor . class . getName ()); @Override public < T > HttpResponse < T > intercept ( HttpRequest request , Chain < T > chain ) throws IOException , InterruptedException { logRequest ( request ); return toLoggingChain ( request , chain ). forward ( request ); } @Override public < T > CompletableFuture < HttpResponse < T >> interceptAsync ( HttpRequest request , Chain < T > chain ) { logRequest ( request ); return toLoggingChain ( request , chain ). forwardAsync ( request ); } private static void logRequest ( HttpRequest request ) { logger . info (() -> String . format ( \"Sending %s%n%s\" , request , headersToString ( request . headers ()))); } private static < T > Chain < T > toLoggingChain ( HttpRequest request , Chain < T > chain ) { var sentAt = Instant . now (); return chain . withBodyHandler ( responseInfo -> { logger . info (() -> String . format ( \"Completed %s %s with %d in %sms%n%s\" , request . method (), request . uri (), responseInfo . statusCode (), Duration . between ( sentAt , Instant . now ()). toMillis (), headersToString ( responseInfo . headers ()))); // Apply the original BodyHandler return chain . bodyHandler (). apply ( responseInfo ); }); } private static String headersToString ( HttpHeaders headers ) { return headers . map (). entrySet (). stream () . map ( entry -> entry . getKey () + \": \" + String . join ( \", \" , entry . getValue ())) . collect ( Collectors . joining ( System . lineSeparator ())); } } HttpClient has blocking and asynchronous APIs, so interceptors must implement two methods matching each. An interceptor is given a Chain<T> so it can forward requests to its next sibling, or to the backend in case there's no more interceptors in the chain. The backend is where requests finally get sent. Typically, an interceptor calls its chain's forward or forwardAsync after it has done its job. If your interceptor only modifies requests, prefer passing a lambda to Interceptor::create . // Enable 'Expect: Continue' for all POSTs to a particular host var expectContinueInterceptor = Interceptor . create ( request -> request . method (). equalsIgnoreCase ( \"POST\" ) && request . uri (). getHost (). equals ( \"api.imgur.com\" ) ? MutableRequest . copyOf ( request ). expectContinue ( true ) : request ); Intercepting Bodies \u00b6 A powerful property of interceptors is their control over how responses are received by their caller. An interceptor can transform its chain's BodyHandler using Chain::withBodyHandler before it forwards requests. A transformed BodyHandler typically applies the handler the chain previously had, then wraps the resulted BodySubscriber , so it intercepts the response body as it's being received by the caller. This is how Methanol does transparent decompression & cache writes. Note that this applies to requests too. You can transform a request body by wrapping its BodyPublisher , if it's got any. BodyPublisher & BodySubscriber APIs can be nicely layered to apply different transformations. Invocation Order \u00b6 An interceptor can be either a client or a backend interceptor. Client interceptors sit between the application and Methanol 's internal interceptors. They are called as soon as the client receives a request. Backend interceptors sit between Methanol and its backend HttpClient . They get invoked right before the request gets sent. This has a number of implications. Client Interceptors \u00b6 See the request just as received from the application. Their transformed BodyHandler receives the response body after the client applies its decompressing & cache writing handlers. Backend Interceptors \u00b6 Observe the request after the client applies things like the base URI and default headers. Additionally, they see intermediate headers added by the client or the cache like Accept-Encoding & If-None-Math . Receive the response body just as transmitted by the backend. For instance, a transformed BodyHandler receives a compressed body if the response comes with a Content-Encoding header. May not always be invoked. This is the case when a cache decides it doesn't need network and hence doesn't proceed the call to the backend. Attention If a cache is installed, Methanol does automatic redirection by itself, which would otherwise be done by the backend. This allows redirects to be cached, increasing cache efficiency. As a consequence, backend interceptors may get invoked more than once in the presence of a cache. Registration \u00b6 You can register client and backend interceptors with interceptor(...) and backendInterceptor(...) respectively. Interceptors in each group get invoked in registration order. Client Interceptors Backend Interceptors var client = Methanol . newBuilder () . interceptor ( new LoggingInterceptor ()) . build (); var client = Methanol . newBuilder () . backendInterceptor ( new LoggingInterceptor ()) . build (); Short-circuiting \u00b6 Both client & backend interceptors can refrain from forwarding a request. They're allowed to short-circuit a request's path by returning a fabricated response. This makes them good candidates for testing. You can mock responses with client interceptors to investigate requests just as sent by your application. Moreover, responses can be mocked with backend interceptors to explore requests as they get sent. This makes backend interceptors suitable for testing how your application interacts with the cache. Limitations \u00b6 Remember that Methanol is built atop a standard HttpClient , which can perform its own redirects, retries and other intermediate requests like authentications. These aren't interceptable. That's because HttpClient exports no API to do so.","title":"Interceptors"},{"location":"interceptors/#interceptors","text":"Interceptors allow you to inspect, mutate, retry and short-circuit HTTP calls. Together, interceptors build an invocation chain that's capable of applying powerful transformations to requests moving forward and to responses in their way back.","title":"Interceptors"},{"location":"interceptors/#writing-interceptors","text":"Interceptors sit between a Methanol client and its underlying HttpClient , referred to as its backend. When registered, an interceptor is invoked each send or sendAsync call. Here's an interceptor that logs requests and their responses. public final class LoggingInterceptor implements Methanol . Interceptor { private static final Logger logger = Logger . getLogger ( LoggingInterceptor . class . getName ()); @Override public < T > HttpResponse < T > intercept ( HttpRequest request , Chain < T > chain ) throws IOException , InterruptedException { logRequest ( request ); return toLoggingChain ( request , chain ). forward ( request ); } @Override public < T > CompletableFuture < HttpResponse < T >> interceptAsync ( HttpRequest request , Chain < T > chain ) { logRequest ( request ); return toLoggingChain ( request , chain ). forwardAsync ( request ); } private static void logRequest ( HttpRequest request ) { logger . info (() -> String . format ( \"Sending %s%n%s\" , request , headersToString ( request . headers ()))); } private static < T > Chain < T > toLoggingChain ( HttpRequest request , Chain < T > chain ) { var sentAt = Instant . now (); return chain . withBodyHandler ( responseInfo -> { logger . info (() -> String . format ( \"Completed %s %s with %d in %sms%n%s\" , request . method (), request . uri (), responseInfo . statusCode (), Duration . between ( sentAt , Instant . now ()). toMillis (), headersToString ( responseInfo . headers ()))); // Apply the original BodyHandler return chain . bodyHandler (). apply ( responseInfo ); }); } private static String headersToString ( HttpHeaders headers ) { return headers . map (). entrySet (). stream () . map ( entry -> entry . getKey () + \": \" + String . join ( \", \" , entry . getValue ())) . collect ( Collectors . joining ( System . lineSeparator ())); } } HttpClient has blocking and asynchronous APIs, so interceptors must implement two methods matching each. An interceptor is given a Chain<T> so it can forward requests to its next sibling, or to the backend in case there's no more interceptors in the chain. The backend is where requests finally get sent. Typically, an interceptor calls its chain's forward or forwardAsync after it has done its job. If your interceptor only modifies requests, prefer passing a lambda to Interceptor::create . // Enable 'Expect: Continue' for all POSTs to a particular host var expectContinueInterceptor = Interceptor . create ( request -> request . method (). equalsIgnoreCase ( \"POST\" ) && request . uri (). getHost (). equals ( \"api.imgur.com\" ) ? MutableRequest . copyOf ( request ). expectContinue ( true ) : request );","title":"Writing Interceptors"},{"location":"interceptors/#intercepting-bodies","text":"A powerful property of interceptors is their control over how responses are received by their caller. An interceptor can transform its chain's BodyHandler using Chain::withBodyHandler before it forwards requests. A transformed BodyHandler typically applies the handler the chain previously had, then wraps the resulted BodySubscriber , so it intercepts the response body as it's being received by the caller. This is how Methanol does transparent decompression & cache writes. Note that this applies to requests too. You can transform a request body by wrapping its BodyPublisher , if it's got any. BodyPublisher & BodySubscriber APIs can be nicely layered to apply different transformations.","title":"Intercepting Bodies"},{"location":"interceptors/#invocation-order","text":"An interceptor can be either a client or a backend interceptor. Client interceptors sit between the application and Methanol 's internal interceptors. They are called as soon as the client receives a request. Backend interceptors sit between Methanol and its backend HttpClient . They get invoked right before the request gets sent. This has a number of implications.","title":"Invocation Order"},{"location":"interceptors/#client-interceptors","text":"See the request just as received from the application. Their transformed BodyHandler receives the response body after the client applies its decompressing & cache writing handlers.","title":"Client Interceptors"},{"location":"interceptors/#backend-interceptors","text":"Observe the request after the client applies things like the base URI and default headers. Additionally, they see intermediate headers added by the client or the cache like Accept-Encoding & If-None-Math . Receive the response body just as transmitted by the backend. For instance, a transformed BodyHandler receives a compressed body if the response comes with a Content-Encoding header. May not always be invoked. This is the case when a cache decides it doesn't need network and hence doesn't proceed the call to the backend. Attention If a cache is installed, Methanol does automatic redirection by itself, which would otherwise be done by the backend. This allows redirects to be cached, increasing cache efficiency. As a consequence, backend interceptors may get invoked more than once in the presence of a cache.","title":"Backend Interceptors"},{"location":"interceptors/#registration","text":"You can register client and backend interceptors with interceptor(...) and backendInterceptor(...) respectively. Interceptors in each group get invoked in registration order. Client Interceptors Backend Interceptors var client = Methanol . newBuilder () . interceptor ( new LoggingInterceptor ()) . build (); var client = Methanol . newBuilder () . backendInterceptor ( new LoggingInterceptor ()) . build ();","title":"Registration"},{"location":"interceptors/#short-circuiting","text":"Both client & backend interceptors can refrain from forwarding a request. They're allowed to short-circuit a request's path by returning a fabricated response. This makes them good candidates for testing. You can mock responses with client interceptors to investigate requests just as sent by your application. Moreover, responses can be mocked with backend interceptors to explore requests as they get sent. This makes backend interceptors suitable for testing how your application interacts with the cache.","title":"Short-circuiting"},{"location":"interceptors/#limitations","text":"Remember that Methanol is built atop a standard HttpClient , which can perform its own redirects, retries and other intermediate requests like authentications. These aren't interceptable. That's because HttpClient exports no API to do so.","title":"Limitations"},{"location":"interruptible_reading/","text":"Interruptible Reading \u00b6 Reading from blocking sources like InputStream isn't always avoidable. Once they're needed, JDK's BodyHandlers::ofInputStream can be used. However, reading from such stream blocks your threads indefinitely, which causes troubles when you want to close the application or change contexts amid reading. Methanol has support for interruptible channels . These are asynchronously closeable and respond to thread interrupts. Using them, you can voluntarily halt reading operations when they're not relevant anymore. MoreBodySubscibers has interruptible ReadableByteChannel and Reader implementations. Use JDK's Channels::newInputStream to get an InputStream from an interruptible ReadableByteChannel when input streams is what you need. Example - Interruptible Body Processing \u00b6 Here's an example of a hypothetical component that processes the response from a ReadableByteChannel . When the task is to be discarded, reader threads are interrupted by shutting down the owning ExecutorService . This closes open channels and instructs them to halt blocking reads. class BodyProcessor { final ExecutorService executorService = Executors . newCachedThreadPool (); final Methanol client = Methanol . create (); CompletableFuture < Void > processAsync ( HttpRequest request , Consumer < ByteBuffer > processAction ) { return client . sendAsync ( request , MoreBodyHandlers . ofByteChannel ()) . thenApplyAsync ( res -> { var buffer = ByteBuffer . allocate ( 8 * 1024 ); try ( var channel = res . body ()) { while ( channel . read ( buffer . clear ()) >= 0 ) { processAction . accept ( buffer . flip ()); } } catch ( ClosedByInterruptException | ClosedChannelException ignored ) { // The thread was interrupted due to ExecutorService shutdown } catch ( IOException e ) { throw new UncheckedIOException ( e ); } return null ; }, executorService ); } void terminate () { executorService . shutdownNow (); } }","title":"Interruptible Reading"},{"location":"interruptible_reading/#interruptible-reading","text":"Reading from blocking sources like InputStream isn't always avoidable. Once they're needed, JDK's BodyHandlers::ofInputStream can be used. However, reading from such stream blocks your threads indefinitely, which causes troubles when you want to close the application or change contexts amid reading. Methanol has support for interruptible channels . These are asynchronously closeable and respond to thread interrupts. Using them, you can voluntarily halt reading operations when they're not relevant anymore. MoreBodySubscibers has interruptible ReadableByteChannel and Reader implementations. Use JDK's Channels::newInputStream to get an InputStream from an interruptible ReadableByteChannel when input streams is what you need.","title":"Interruptible Reading"},{"location":"interruptible_reading/#example-interruptible-body-processing","text":"Here's an example of a hypothetical component that processes the response from a ReadableByteChannel . When the task is to be discarded, reader threads are interrupted by shutting down the owning ExecutorService . This closes open channels and instructs them to halt blocking reads. class BodyProcessor { final ExecutorService executorService = Executors . newCachedThreadPool (); final Methanol client = Methanol . create (); CompletableFuture < Void > processAsync ( HttpRequest request , Consumer < ByteBuffer > processAction ) { return client . sendAsync ( request , MoreBodyHandlers . ofByteChannel ()) . thenApplyAsync ( res -> { var buffer = ByteBuffer . allocate ( 8 * 1024 ); try ( var channel = res . body ()) { while ( channel . read ( buffer . clear ()) >= 0 ) { processAction . accept ( buffer . flip ()); } } catch ( ClosedByInterruptException | ClosedChannelException ignored ) { // The thread was interrupted due to ExecutorService shutdown } catch ( IOException e ) { throw new UncheckedIOException ( e ); } return null ; }, executorService ); } void terminate () { executorService . shutdownNow (); } }","title":"Example - Interruptible Body Processing"},{"location":"media_types/","text":"Mime \u00b6 Media types are the web's notion for file extensions. They're typically present in requests and responses as Content-Type directives. Methanol's MediaType greatly facilitates the representation and manipulation of media types. MediaType \u00b6 You can create a MediaType from its individual components or parse one from a Content-Type string. MediaType::of MediaType::parse var applicationJsonUtf8 = MediaType . of ( \"application\" , \"json\" , Map . of ( \"charset\" , \"UTF-8\" )); assertEquals ( \"application\" , applicationJsonUtf8 . type ()); assertEquals ( \"json\" , applicationJsonUtf8 . subtype ()); assertEquals ( \"utf-8\" , applicationJsonUtf8 . parameters (). get ( \"charset\" )); assertEquals ( Optional . of ( StandardCharsets . UTF_8 ), applicationJsonUtf8 . charset ()); var applicationJsonUtf8 = MediaType . parse ( \"application/json; charset=UTF-8\" ); assertEquals ( \"application\" , applicationJsonUtf8 . type ()); assertEquals ( \"json\" , applicationJsonUtf8 . subtype ()); assertEquals ( \"utf-8\" , applicationJsonUtf8 . parameters (). get ( \"charset\" )); assertEquals ( Optional . of ( StandardCharsets . UTF_8 ), applicationJsonUtf8 . charset ()); Media Ranges \u00b6 A MediaType also defines a media range to which one or more media types belong, including itself. var anyTextType = MediaType . parse ( \"text/*\" ); var textHtml = MediaType . parse ( \"text/html\" ); var applicationJson = MediaType . parse ( \"application/json\" ); assertTrue ( anyTextType . hasWildcard ()); assertTrue ( anyTextType . includes ( textHtml )); assertFalse ( anyTextType . includes ( applicationJson )); assertTrue ( anyTextType . isCompatibleWith ( textHtml )); assertTrue ( textHtml . isCompatibleWith ( anyTextType )); Tip MediaType has static definitions for the most popular media types & ranges. None of them, however, defines a charset parameter. You can use MediaType::withCharset to derive media types with charsets from the statically defined ones. static final MediaType APPLICATION_JSON_UTF8 = MediaType . APPLICATION_JSON . withCharset ( StandardCharsets . UTF_8 ); MimeBodyPublisher \u00b6 MimeBodyPublisher is a mixin-style interface that associates a MediaType with a BodyPublisher . It's recognized by Methanol and multipart bodies in that it gets the appropriate Content-Type header implicitly added. You can adapt an arbitrary BodyPublisher into a MimeBodyPublisher . Here's a factory method that creates MimeBodyPublihers for files. The file's media type is probed from the system, falling back to application/octet-stream if that doesn't work. static MimeBodyPublisher ofMimeFile ( Path file ) throws FileNotFoundException { MediaType mediaType = null ; try { var contentType = Files . probeContentType ( file ); if ( contentType != null ) { mediaType = MediaType . parse ( contentType ); } } catch ( IOException ignored ) { } return MoreBodyPublishers . ofMediaType ( BodyPublishers . ofFile ( file ), requireNonNullElse ( mediaType , MediaType . APPLICATION_OCTET_STREAM )); } final Methanol client = Methanol . create (); < T > HttpResponse < T > post ( String url , Path file , BodyHandler < T > handler ) throws IOException , InterruptedException { // Request's Content-Type is implicitly added return client . send ( MutableRequest . POST ( url , ofMimeFile ( file )), handler ); }","title":"Media Types"},{"location":"media_types/#mime","text":"Media types are the web's notion for file extensions. They're typically present in requests and responses as Content-Type directives. Methanol's MediaType greatly facilitates the representation and manipulation of media types.","title":"Mime"},{"location":"media_types/#mediatype","text":"You can create a MediaType from its individual components or parse one from a Content-Type string. MediaType::of MediaType::parse var applicationJsonUtf8 = MediaType . of ( \"application\" , \"json\" , Map . of ( \"charset\" , \"UTF-8\" )); assertEquals ( \"application\" , applicationJsonUtf8 . type ()); assertEquals ( \"json\" , applicationJsonUtf8 . subtype ()); assertEquals ( \"utf-8\" , applicationJsonUtf8 . parameters (). get ( \"charset\" )); assertEquals ( Optional . of ( StandardCharsets . UTF_8 ), applicationJsonUtf8 . charset ()); var applicationJsonUtf8 = MediaType . parse ( \"application/json; charset=UTF-8\" ); assertEquals ( \"application\" , applicationJsonUtf8 . type ()); assertEquals ( \"json\" , applicationJsonUtf8 . subtype ()); assertEquals ( \"utf-8\" , applicationJsonUtf8 . parameters (). get ( \"charset\" )); assertEquals ( Optional . of ( StandardCharsets . UTF_8 ), applicationJsonUtf8 . charset ());","title":"MediaType"},{"location":"media_types/#media-ranges","text":"A MediaType also defines a media range to which one or more media types belong, including itself. var anyTextType = MediaType . parse ( \"text/*\" ); var textHtml = MediaType . parse ( \"text/html\" ); var applicationJson = MediaType . parse ( \"application/json\" ); assertTrue ( anyTextType . hasWildcard ()); assertTrue ( anyTextType . includes ( textHtml )); assertFalse ( anyTextType . includes ( applicationJson )); assertTrue ( anyTextType . isCompatibleWith ( textHtml )); assertTrue ( textHtml . isCompatibleWith ( anyTextType )); Tip MediaType has static definitions for the most popular media types & ranges. None of them, however, defines a charset parameter. You can use MediaType::withCharset to derive media types with charsets from the statically defined ones. static final MediaType APPLICATION_JSON_UTF8 = MediaType . APPLICATION_JSON . withCharset ( StandardCharsets . UTF_8 );","title":"Media Ranges"},{"location":"media_types/#mimebodypublisher","text":"MimeBodyPublisher is a mixin-style interface that associates a MediaType with a BodyPublisher . It's recognized by Methanol and multipart bodies in that it gets the appropriate Content-Type header implicitly added. You can adapt an arbitrary BodyPublisher into a MimeBodyPublisher . Here's a factory method that creates MimeBodyPublihers for files. The file's media type is probed from the system, falling back to application/octet-stream if that doesn't work. static MimeBodyPublisher ofMimeFile ( Path file ) throws FileNotFoundException { MediaType mediaType = null ; try { var contentType = Files . probeContentType ( file ); if ( contentType != null ) { mediaType = MediaType . parse ( contentType ); } } catch ( IOException ignored ) { } return MoreBodyPublishers . ofMediaType ( BodyPublishers . ofFile ( file ), requireNonNullElse ( mediaType , MediaType . APPLICATION_OCTET_STREAM )); } final Methanol client = Methanol . create (); < T > HttpResponse < T > post ( String url , Path file , BodyHandler < T > handler ) throws IOException , InterruptedException { // Request's Content-Type is implicitly added return client . send ( MutableRequest . POST ( url , ofMimeFile ( file )), handler ); }","title":"MimeBodyPublisher"},{"location":"multipart_and_forms/","text":"Multipart & Forms \u00b6 Methanol has special BodyPublisher implementations for multipart uploads & form submission. Multipart Bodies \u00b6 MultipartBodyPublisher implements the flexible multipart format. A multipart body has one or more parts. Each part has a BodyPublisher for its content and HttpHeaders that describe it. MultipartBodyPublisher.Builder defaults to multipart/form-data if a multipart MediaType isn't explicitly specified. There're special methods for adding parts with a Content-Disposition: form-data header generated from a field name and an optional file name. These are referred to as form parts. // Substitute with your client ID. Visit https://api.imgur.com/oauth2/addclient to get one. static final String CLIENT_ID = System . getenv ( \"IMGUR_CLIENT_ID\" ); final Methanol client = Methanol . create (); HttpResponse < String > uploadGif () throws IOException , InterruptedException { var multipartBody = MultipartBodyPublisher . newBuilder () . textPart ( \"title\" , \"Dancing stick bug\" ) . filePart ( \"image\" , Path . of ( \"dancing-stick-bug.gif\" ), MediaType . IMAGE_GIF ) . build (); var request = MutableRequest . POST ( \"https://api.imgur.com/3/image\" , multipartBody ) . header ( \"Authorization\" , \"Client-ID \" + CLIENT_ID ); return client . send ( request , BodyHandlers . ofString ()); } If filePart isn't given a MediaType , it asks the system for one using the given Path , falling back to application/octet-stream if that doesn't work. Hint A part's Content-Type is automatically added if it's created with a MimeBodyPublisher . Generic Form Parts \u00b6 Use builder's formPart method to add a form part from an arbitrary BodyPublisher . It takes a field name and an optional file name. // Substitute with your client ID. Visit https://api.imgur.com/oauth2/addclient to get one static final String CLIENT_ID = System . getenv ( \"IMGUR_CLIENT_ID\" ); final Methanol client = Methanol . create (); HttpResponse < String > uploadPng ( String title , InputStream pngImageInputStream ) throws IOException , InterruptedException { var imagePart = MoreBodyPublishers . ofMediaType ( BodyPublishers . ofInputStream (() -> pngImageInputStream ), MediaType . IMAGE_PNG ); var multipartBody = MultipartBodyPublisher . newBuilder () . textPart ( \"title\" , title ) . formPart ( \"image\" , title + \".png\" , imagePart ) . build (); var request = MutableRequest . POST ( \"https://api.imgur.com/3/image\" , multipartBody ) . header ( \"Authorization\" , \"Client-ID \" + CLIENT_ID ); return client . send ( request , BodyHandlers . ofString ()); } Tip You can use formPart to add a file part from something that's not a Path (e.g. InputStream ) or to override the part's filename property, which is not possible with filePart . Form Bodies \u00b6 Use FormBodyPublisher to send form data as a set of URL-encoded queries. Data is added as string name-value pairs. final Methanol client = Methanol . create (); HttpResponse < String > sendQueries ( String url , Map < String , String > queries ) throws IOException , InterruptedException { var builder = FormBodyPublisher . newBuilder (); queries . forEach ( builder :: query ); var formBody = builder . build (); var request = MutableRequest . POST ( url , formBody ); return client . send ( request , BodyHandlers . ofString ()); } Hint Requests with MultipartBodyPublisher or FormBodyPublisher will have their Content-Type header added automatically if sent on a Methanol client.","title":"Multipart & Forms"},{"location":"multipart_and_forms/#multipart-forms","text":"Methanol has special BodyPublisher implementations for multipart uploads & form submission.","title":"Multipart &amp; Forms"},{"location":"multipart_and_forms/#multipart-bodies","text":"MultipartBodyPublisher implements the flexible multipart format. A multipart body has one or more parts. Each part has a BodyPublisher for its content and HttpHeaders that describe it. MultipartBodyPublisher.Builder defaults to multipart/form-data if a multipart MediaType isn't explicitly specified. There're special methods for adding parts with a Content-Disposition: form-data header generated from a field name and an optional file name. These are referred to as form parts. // Substitute with your client ID. Visit https://api.imgur.com/oauth2/addclient to get one. static final String CLIENT_ID = System . getenv ( \"IMGUR_CLIENT_ID\" ); final Methanol client = Methanol . create (); HttpResponse < String > uploadGif () throws IOException , InterruptedException { var multipartBody = MultipartBodyPublisher . newBuilder () . textPart ( \"title\" , \"Dancing stick bug\" ) . filePart ( \"image\" , Path . of ( \"dancing-stick-bug.gif\" ), MediaType . IMAGE_GIF ) . build (); var request = MutableRequest . POST ( \"https://api.imgur.com/3/image\" , multipartBody ) . header ( \"Authorization\" , \"Client-ID \" + CLIENT_ID ); return client . send ( request , BodyHandlers . ofString ()); } If filePart isn't given a MediaType , it asks the system for one using the given Path , falling back to application/octet-stream if that doesn't work. Hint A part's Content-Type is automatically added if it's created with a MimeBodyPublisher .","title":"Multipart Bodies"},{"location":"multipart_and_forms/#generic-form-parts","text":"Use builder's formPart method to add a form part from an arbitrary BodyPublisher . It takes a field name and an optional file name. // Substitute with your client ID. Visit https://api.imgur.com/oauth2/addclient to get one static final String CLIENT_ID = System . getenv ( \"IMGUR_CLIENT_ID\" ); final Methanol client = Methanol . create (); HttpResponse < String > uploadPng ( String title , InputStream pngImageInputStream ) throws IOException , InterruptedException { var imagePart = MoreBodyPublishers . ofMediaType ( BodyPublishers . ofInputStream (() -> pngImageInputStream ), MediaType . IMAGE_PNG ); var multipartBody = MultipartBodyPublisher . newBuilder () . textPart ( \"title\" , title ) . formPart ( \"image\" , title + \".png\" , imagePart ) . build (); var request = MutableRequest . POST ( \"https://api.imgur.com/3/image\" , multipartBody ) . header ( \"Authorization\" , \"Client-ID \" + CLIENT_ID ); return client . send ( request , BodyHandlers . ofString ()); } Tip You can use formPart to add a file part from something that's not a Path (e.g. InputStream ) or to override the part's filename property, which is not possible with filePart .","title":"Generic Form Parts"},{"location":"multipart_and_forms/#form-bodies","text":"Use FormBodyPublisher to send form data as a set of URL-encoded queries. Data is added as string name-value pairs. final Methanol client = Methanol . create (); HttpResponse < String > sendQueries ( String url , Map < String , String > queries ) throws IOException , InterruptedException { var builder = FormBodyPublisher . newBuilder (); queries . forEach ( builder :: query ); var formBody = builder . build (); var request = MutableRequest . POST ( url , formBody ); return client . send ( request , BodyHandlers . ofString ()); } Hint Requests with MultipartBodyPublisher or FormBodyPublisher will have their Content-Type header added automatically if sent on a Methanol client.","title":"Form Bodies"},{"location":"object_mapping/","text":"Object Mapping \u00b6 HTTP bodies are often mappable to high-level entities that your code understands. Java's HttpClient was designed with that in mind. However, available BodyPublisher & BodySubscriber implementations are too basic, and implementing your own can be tricky. Methanol builds upon these APIs with an extensible and easy-to-use object mapping mechanism that treats your objects as first-citizen HTTP bodies. Setup \u00b6 Before sending and receiving objects over HTTP, Methanol needs to adapt to your desired mapping schemes. Adapters for the most popular serialization libraries are provided in separate modules. methanol-gson : JSON with Gson methanol-jackson : JSON with Jackson methanol-jackson-flux : Reactive JSON with Jackson and Reactor methanol-jaxb : XML with JAXB methanol-protobuf : Google's Protocol Buffers Adapters are dynamically located using Java's ServiceLoader . You can find clear installation steps in each module. We'll see how to implement custom adapters as well. If you want to run examples presented here, get started by installing your favorite JSON adapter! Receiving Objects \u00b6 To get an HttpResponse<T> , give MoreBodyHandlers a T.class and it'll give you a BodyHandler<T> in return. final Methanol client = Methanol . newBuilder () . baseUri ( \"https://api.github.com/\" ) . defaultHeader ( \"Accept\" , \"application/vnd.github.v3+json\" ) . build (); GitHubUser getUser ( String username ) throws IOException , InterruptedException { var request = MutableRequest . GET ( \"user/\" + username ); var response = client . send ( request , MoreBodyHandlers . ofObject ( GitHubUser . class )); return response . body (); } public static final class GitHubUser { public String login ; public long id ; public String url ; // Other fields omitted. // Annotate with @JsonIgnoreProperties(ignoreUnknown = true) to run with Jackson. } If you want to get fancier with generics, use a TypeRef<T> . final Methanol client = Methanol . newBuilder () . baseUri ( \"https://api.github.com/\" ) . defaultHeader ( \"Accept\" , \"application/vnd.github.v3+json\" ) . build (); List < GitHubIssue > getIssuesForRepo ( String owner , String repo ) throws IOException , InterruptedException { var request = MutableRequest . GET ( \"repos/\" + owner + \"/\" + repo + \"/issues\" ); var response = client . send ( request , MoreBodyHandlers . ofObject ( new TypeRef < List < GitHubIssue >> () {})); return response . body (); } public static final class GitHubIssue { public String title ; public GitHubUser user ; public String body ; // Other fields omitted. // Annotate with @JsonIgnoreProperties(ignoreUnknown = true) to run with Jackson. } public static final class GitHubUser { public String login ; public long id ; public String url ; // Other fields omitted. // Annotate with @JsonIgnoreProperties(ignoreUnknown = true) to run with Jackson. } The right adapter is selected based on response's Content-Type . For instance, a response with Content-Type: application/json causes Methanol to look for a JSON adapter. If such lookup fails, an UnsupportedOperationException is thrown. Sending Objects \u00b6 Get a BodyPubilsher for whatever object you've got by passing it in along with a MediaType describing which adapter you prefer selected. final Methanol client = Methanol . newBuilder () . baseUri ( \"https://api.github.com/\" ) . defaultHeader ( \"Accept\" , \"application/vnd.github.v3+json\" ) . build (); String renderMarkdown ( RenderRequest renderRequest ) throws IOException , InterruptedException { var requestBody = MoreBodyPublishers . ofObject ( renderRequest , MediaType . APPLICATION_JSON ); var request = MutableRequest . POST ( \"markdown\" , requestBody ); var response = client . send ( request , BodyHandlers . ofString ()); return response . body (); } public static final class RenderRequest { public String text , mode , context ; } Adapters \u00b6 An adapter provides Encoder and/or Decoder implementations. Both interfaces implement BodyAdapter , which defines the methods necessary for Methanol to know which object types the adapter believes it can handle, and in what scheme. An Encoder creates a BodyPublisher that streams a given object's serialized form. Similarly, a Decoder supplies BodySubscriber<T> instances for a given TypeRef<T> that convert the response body into T . An optional MediaType is passed to encoders & decoders to further describe the desired mapping scheme (e.g. specify a character set). Example - An HTML Adapter \u00b6 Here's an adapter that uses Jsoup to convert HTML bodies to parsed Document objects and vise versa. When you're writing adapters, extend from AbstractBodyAdapter to get free media type matching & other helpful functions. public abstract class JsoupAdapter extends AbstractBodyAdapter implements BodyAdapter { JsoupAdapter () { super ( MediaType . TEXT_HTML ); } @Override public boolean supportsType ( TypeRef <?> type ) { return type . rawType () == Document . class ; } public static final class Decoder extends JsoupAdapter implements BodyAdapter . Decoder { @Override public < T > BodySubscriber < T > toObject ( TypeRef < T > type , @Nullable MediaType mediaType ) { requireSupport ( type ); requireCompatibleOrNull ( mediaType ); var charset = charsetOrUtf8 ( mediaType ); var subscriber = BodySubscribers . mapping ( BodySubscribers . ofString ( charset ), Jsoup :: parse ); return BodySubscribers . mapping ( subscriber , type . exactRawType ():: cast ); // Safely cast Document to T } } public static final class Encoder extends JsoupAdapter implements BodyAdapter . Encoder { @Override public BodyPublisher toBody ( Object object , @Nullable MediaType mediaType ) { requireSupport ( object . getClass ()); requireCompatibleOrNull ( mediaType ); var charset = charsetOrUtf8 ( mediaType ); var publisher = BodyPublishers . ofString ((( Document ) object ). outerHtml (), charset ); return attachMediaType ( publisher , mediaType ); } } } Tip Make sure your encoders call AbstractBodyAdapter::attachMediaType so the created BodyPublisher is converted to a MimeBodyPublisher if the given media type isn't null. That way, requests get the correct Content-Type header added by Methanol . Registration \u00b6 Declare your encoder & decoder implementations as service-providers in the manner specified by Java's ServiceLoader . Here's the appropriate provider declarations for our Jsoup adapter to put in module-info.java . module my . module { ... provides BodyAdapter . Decoder with JsoupAdapter . Decoder ; provides BodyAdapter . Encoder with JsoupAdapter . Encoder ; } See any of the supported adapters for more registration methods. Usage \u00b6 Now Methanol can send and receive HTML Documents ! final Methanol client = Methanol . create (); HttpResponse < Document > downloadHtml ( String url ) throws IOException , InterruptedException { var request = MutableRequest . GET ( url ). header ( \"Accept\" , \"text/html\" ); return client . send ( request , MoreBodyHandlers . ofObject ( Document . class )); } < T > HttpResponse < T > uploadHtml ( String url , Document htmlDoc , BodyHandler < T > responseHandler ) throws IOException , InterruptedException { var requestBody = MoreBodyPublishers . ofObject ( htmlDoc , MediaType . TEXT_HTML ); var request = MutableRequest . POST ( url , requestBody ); return client . send ( request , responseHandler ); } Buffering vs Streaming \u00b6 MoreBodyHandlers::ofObject creates handlers that use MoreBodySubscribers::ofObject to obtain the appropriate BodySubscriber<T> from a chosen adapter. Such subscriber typically loads the whole response into memory then decodes from there. If your responses tend to have large bodies, or you'd prefer the memory efficiency afforded by streaming sources, MoreBodyHandlers::ofDeferredObject is the way to go. final Methanol client = Methanol . newBuilder () . baseUri ( \"https://api.github.com/\" ) . defaultHeader ( \"Accept\" , \"application/vnd.github.v3+json\" ) . build (); GitHubUser getUser ( String username ) throws IOException , InterruptedException { var request = MutableRequest . GET ( \"user/\" + username ); var response = client . send ( request , MoreBodyHandlers . ofDeferredObject ( GitHubUser . class )); return response . body (). get (); } public static final class GitHubUser { public String login ; public long id ; public String url ; // Other fields omitted. // Annotate with @JsonIgnoreProperties(ignoreUnknown = true) to run with Jackson. } The handler results in an HttpResponse<Supplier<T>> . The response is completed as soon as all headers are read. If the chosen decoder's toDeferredObject is implemented correctly, processing is deferred till you invoke the supplier and the body is decoded from a streaming source, typically an InputStream or a Reader . The Decoder interface has a naive default implementation for toDeferredObject that doesn't read from a streaming source. Here's how it'd be properly implemented for our HTML adapter's decoder. @Override public < T > BodySubscriber < Supplier < T >> toDeferredObject ( TypeRef < T > type , @Nullable MediaType mediaType ) { requireSupport ( type ); requireCompatibleOrNull ( mediaType ); var charset = charsetOrUtf8 ( mediaType ); BodySubscriber < Supplier < Document >> subscriber = BodySubscribers . mapping ( MoreBodySubscribers . ofReader ( charset ), reader -> () -> Parser . htmlParser (). parseInput ( new BufferedReader ( reader ), \"\" )); // Note the deferred parsing return BodySubscribers . mapping ( subscriber , supplier -> () -> type . exactRawType (). cast ( supplier . get ())); // Safely cast Document to T }","title":"Object Mapping"},{"location":"object_mapping/#object-mapping","text":"HTTP bodies are often mappable to high-level entities that your code understands. Java's HttpClient was designed with that in mind. However, available BodyPublisher & BodySubscriber implementations are too basic, and implementing your own can be tricky. Methanol builds upon these APIs with an extensible and easy-to-use object mapping mechanism that treats your objects as first-citizen HTTP bodies.","title":"Object Mapping"},{"location":"object_mapping/#setup","text":"Before sending and receiving objects over HTTP, Methanol needs to adapt to your desired mapping schemes. Adapters for the most popular serialization libraries are provided in separate modules. methanol-gson : JSON with Gson methanol-jackson : JSON with Jackson methanol-jackson-flux : Reactive JSON with Jackson and Reactor methanol-jaxb : XML with JAXB methanol-protobuf : Google's Protocol Buffers Adapters are dynamically located using Java's ServiceLoader . You can find clear installation steps in each module. We'll see how to implement custom adapters as well. If you want to run examples presented here, get started by installing your favorite JSON adapter!","title":"Setup"},{"location":"object_mapping/#receiving-objects","text":"To get an HttpResponse<T> , give MoreBodyHandlers a T.class and it'll give you a BodyHandler<T> in return. final Methanol client = Methanol . newBuilder () . baseUri ( \"https://api.github.com/\" ) . defaultHeader ( \"Accept\" , \"application/vnd.github.v3+json\" ) . build (); GitHubUser getUser ( String username ) throws IOException , InterruptedException { var request = MutableRequest . GET ( \"user/\" + username ); var response = client . send ( request , MoreBodyHandlers . ofObject ( GitHubUser . class )); return response . body (); } public static final class GitHubUser { public String login ; public long id ; public String url ; // Other fields omitted. // Annotate with @JsonIgnoreProperties(ignoreUnknown = true) to run with Jackson. } If you want to get fancier with generics, use a TypeRef<T> . final Methanol client = Methanol . newBuilder () . baseUri ( \"https://api.github.com/\" ) . defaultHeader ( \"Accept\" , \"application/vnd.github.v3+json\" ) . build (); List < GitHubIssue > getIssuesForRepo ( String owner , String repo ) throws IOException , InterruptedException { var request = MutableRequest . GET ( \"repos/\" + owner + \"/\" + repo + \"/issues\" ); var response = client . send ( request , MoreBodyHandlers . ofObject ( new TypeRef < List < GitHubIssue >> () {})); return response . body (); } public static final class GitHubIssue { public String title ; public GitHubUser user ; public String body ; // Other fields omitted. // Annotate with @JsonIgnoreProperties(ignoreUnknown = true) to run with Jackson. } public static final class GitHubUser { public String login ; public long id ; public String url ; // Other fields omitted. // Annotate with @JsonIgnoreProperties(ignoreUnknown = true) to run with Jackson. } The right adapter is selected based on response's Content-Type . For instance, a response with Content-Type: application/json causes Methanol to look for a JSON adapter. If such lookup fails, an UnsupportedOperationException is thrown.","title":"Receiving Objects"},{"location":"object_mapping/#sending-objects","text":"Get a BodyPubilsher for whatever object you've got by passing it in along with a MediaType describing which adapter you prefer selected. final Methanol client = Methanol . newBuilder () . baseUri ( \"https://api.github.com/\" ) . defaultHeader ( \"Accept\" , \"application/vnd.github.v3+json\" ) . build (); String renderMarkdown ( RenderRequest renderRequest ) throws IOException , InterruptedException { var requestBody = MoreBodyPublishers . ofObject ( renderRequest , MediaType . APPLICATION_JSON ); var request = MutableRequest . POST ( \"markdown\" , requestBody ); var response = client . send ( request , BodyHandlers . ofString ()); return response . body (); } public static final class RenderRequest { public String text , mode , context ; }","title":"Sending Objects"},{"location":"object_mapping/#adapters","text":"An adapter provides Encoder and/or Decoder implementations. Both interfaces implement BodyAdapter , which defines the methods necessary for Methanol to know which object types the adapter believes it can handle, and in what scheme. An Encoder creates a BodyPublisher that streams a given object's serialized form. Similarly, a Decoder supplies BodySubscriber<T> instances for a given TypeRef<T> that convert the response body into T . An optional MediaType is passed to encoders & decoders to further describe the desired mapping scheme (e.g. specify a character set).","title":"Adapters"},{"location":"object_mapping/#example-an-html-adapter","text":"Here's an adapter that uses Jsoup to convert HTML bodies to parsed Document objects and vise versa. When you're writing adapters, extend from AbstractBodyAdapter to get free media type matching & other helpful functions. public abstract class JsoupAdapter extends AbstractBodyAdapter implements BodyAdapter { JsoupAdapter () { super ( MediaType . TEXT_HTML ); } @Override public boolean supportsType ( TypeRef <?> type ) { return type . rawType () == Document . class ; } public static final class Decoder extends JsoupAdapter implements BodyAdapter . Decoder { @Override public < T > BodySubscriber < T > toObject ( TypeRef < T > type , @Nullable MediaType mediaType ) { requireSupport ( type ); requireCompatibleOrNull ( mediaType ); var charset = charsetOrUtf8 ( mediaType ); var subscriber = BodySubscribers . mapping ( BodySubscribers . ofString ( charset ), Jsoup :: parse ); return BodySubscribers . mapping ( subscriber , type . exactRawType ():: cast ); // Safely cast Document to T } } public static final class Encoder extends JsoupAdapter implements BodyAdapter . Encoder { @Override public BodyPublisher toBody ( Object object , @Nullable MediaType mediaType ) { requireSupport ( object . getClass ()); requireCompatibleOrNull ( mediaType ); var charset = charsetOrUtf8 ( mediaType ); var publisher = BodyPublishers . ofString ((( Document ) object ). outerHtml (), charset ); return attachMediaType ( publisher , mediaType ); } } } Tip Make sure your encoders call AbstractBodyAdapter::attachMediaType so the created BodyPublisher is converted to a MimeBodyPublisher if the given media type isn't null. That way, requests get the correct Content-Type header added by Methanol .","title":"Example - An HTML Adapter"},{"location":"object_mapping/#registration","text":"Declare your encoder & decoder implementations as service-providers in the manner specified by Java's ServiceLoader . Here's the appropriate provider declarations for our Jsoup adapter to put in module-info.java . module my . module { ... provides BodyAdapter . Decoder with JsoupAdapter . Decoder ; provides BodyAdapter . Encoder with JsoupAdapter . Encoder ; } See any of the supported adapters for more registration methods.","title":"Registration"},{"location":"object_mapping/#usage","text":"Now Methanol can send and receive HTML Documents ! final Methanol client = Methanol . create (); HttpResponse < Document > downloadHtml ( String url ) throws IOException , InterruptedException { var request = MutableRequest . GET ( url ). header ( \"Accept\" , \"text/html\" ); return client . send ( request , MoreBodyHandlers . ofObject ( Document . class )); } < T > HttpResponse < T > uploadHtml ( String url , Document htmlDoc , BodyHandler < T > responseHandler ) throws IOException , InterruptedException { var requestBody = MoreBodyPublishers . ofObject ( htmlDoc , MediaType . TEXT_HTML ); var request = MutableRequest . POST ( url , requestBody ); return client . send ( request , responseHandler ); }","title":"Usage"},{"location":"object_mapping/#buffering-vs-streaming","text":"MoreBodyHandlers::ofObject creates handlers that use MoreBodySubscribers::ofObject to obtain the appropriate BodySubscriber<T> from a chosen adapter. Such subscriber typically loads the whole response into memory then decodes from there. If your responses tend to have large bodies, or you'd prefer the memory efficiency afforded by streaming sources, MoreBodyHandlers::ofDeferredObject is the way to go. final Methanol client = Methanol . newBuilder () . baseUri ( \"https://api.github.com/\" ) . defaultHeader ( \"Accept\" , \"application/vnd.github.v3+json\" ) . build (); GitHubUser getUser ( String username ) throws IOException , InterruptedException { var request = MutableRequest . GET ( \"user/\" + username ); var response = client . send ( request , MoreBodyHandlers . ofDeferredObject ( GitHubUser . class )); return response . body (). get (); } public static final class GitHubUser { public String login ; public long id ; public String url ; // Other fields omitted. // Annotate with @JsonIgnoreProperties(ignoreUnknown = true) to run with Jackson. } The handler results in an HttpResponse<Supplier<T>> . The response is completed as soon as all headers are read. If the chosen decoder's toDeferredObject is implemented correctly, processing is deferred till you invoke the supplier and the body is decoded from a streaming source, typically an InputStream or a Reader . The Decoder interface has a naive default implementation for toDeferredObject that doesn't read from a streaming source. Here's how it'd be properly implemented for our HTML adapter's decoder. @Override public < T > BodySubscriber < Supplier < T >> toDeferredObject ( TypeRef < T > type , @Nullable MediaType mediaType ) { requireSupport ( type ); requireCompatibleOrNull ( mediaType ); var charset = charsetOrUtf8 ( mediaType ); BodySubscriber < Supplier < Document >> subscriber = BodySubscribers . mapping ( MoreBodySubscribers . ofReader ( charset ), reader -> () -> Parser . htmlParser (). parseInput ( new BufferedReader ( reader ), \"\" )); // Note the deferred parsing return BodySubscribers . mapping ( subscriber , supplier -> () -> type . exactRawType (). cast ( supplier . get ())); // Safely cast Document to T }","title":"Buffering vs Streaming"},{"location":"progress_tracking/","text":"Progress Tracking \u00b6 You can track download & upload progress using Methanol's ProgressTracker . Setup \u00b6 A ProgressTracker controls the rate at which progress events are propagated using two thresholds: bytes transferred & time passed, both calculated since the last event. Byte count threshold Time passed threshold // Receive a progress event at least each 50 kBs of data var tracker = ProgressTracker . newBuilder () . bytesTransferredThreshold ( 50 * 1024 ) . build (); // Receive a progress event at least each half a second var tracker = ProgressTracker . newBuilder () . timePassedThreshold ( Duration . ofSeconds ( 1 ). dividedBy ( 2 )) . build (); Tip You can use the builder to set an Executor that's used for dispatching progress events to your listener. That's useful in case your listener does something like GUI updates. You'd want it to be invoked in the GUI thread rather than an arbitrary HTTP client thread. var tracker = ProgressTracker . newBuilder () . bytesTransferredThreshold ( 50 * 1024 ) . executor ( javafx . application . Platform :: runLater ) . build (); Usage \u00b6 You track download progress by attaching a Listener to a response's BodyHandler . Similarly, upload progress is tracked by registering a Listener with a request's BodyPublisher . Track downloads Track uploads final Methanol client = Methanol . create (); final ProgressTracker tracker = ProgressTracker . newBuilder () . bytesTransferredThreshold ( 60 * 1024 ) // 60 kB . build (); HttpResponse < Path > downloadVeryInterestingVideo () throws IOException , InterruptedException { var request = MutableRequest . GET ( \"https://i.imgur.com/NYvl8Sy.mp4\" ); var downloadingBodyHandler = BodyHandlers . ofFile ( Path . of ( \"interesting-video.mp4\" ), CREATE , WRITE ); var trackingBodyHandler = tracker . tracking ( downloadingBodyHandler , this :: onProgress ); return client . send ( request , trackingBodyHandler ); } void onProgress ( Progress progress ) { if ( progress . determinate ()) { // Overall progress can be measured var percent = 100 * progress . value (); System . out . printf ( \"Downloaded %d from %d bytes (%.2f%%)%n\" , progress . totalBytesTransferred (), progress . contentLength (), percent ); } else { System . out . println ( \"Downloaded \" + progress . totalBytesTransferred ()); } if ( progress . done ()) { System . out . println ( \"Done!\" ); } } final Methanol client = Methanol . create (); final ProgressTracker tracker = ProgressTracker . newBuilder () . bytesTransferredThreshold ( 60 * 1024 ) // 60 kB . build (); < T > HttpResponse < T > upload ( Path file , BodyHandler < T > bodyHandler ) throws IOException , InterruptedException { var trackingRequestBody = tracker . tracking ( BodyPublishers . ofFile ( file ), this :: onProgress ); var request = MutableRequest . POST ( \"https://httpbin.org/post\" , trackingRequestBody ); return client . send ( request , bodyHandler ); } void onProgress ( Progress progress ) { if ( progress . determinate ()) { // Overall progress can be measured var percent = 100 * progress . value (); System . out . printf ( \"Uploaded %d from %d bytes (%.2f%%)%n\" , progress . totalBytesTransferred (), progress . contentLength (), percent ); } else { System . out . println ( \"Uploaded \" + progress . totalBytesTransferred ()); } if ( progress . done ()) { System . out . println ( \"Done!\" ); } }","title":"Progress Tracking"},{"location":"progress_tracking/#progress-tracking","text":"You can track download & upload progress using Methanol's ProgressTracker .","title":"Progress Tracking"},{"location":"progress_tracking/#setup","text":"A ProgressTracker controls the rate at which progress events are propagated using two thresholds: bytes transferred & time passed, both calculated since the last event. Byte count threshold Time passed threshold // Receive a progress event at least each 50 kBs of data var tracker = ProgressTracker . newBuilder () . bytesTransferredThreshold ( 50 * 1024 ) . build (); // Receive a progress event at least each half a second var tracker = ProgressTracker . newBuilder () . timePassedThreshold ( Duration . ofSeconds ( 1 ). dividedBy ( 2 )) . build (); Tip You can use the builder to set an Executor that's used for dispatching progress events to your listener. That's useful in case your listener does something like GUI updates. You'd want it to be invoked in the GUI thread rather than an arbitrary HTTP client thread. var tracker = ProgressTracker . newBuilder () . bytesTransferredThreshold ( 50 * 1024 ) . executor ( javafx . application . Platform :: runLater ) . build ();","title":"Setup"},{"location":"progress_tracking/#usage","text":"You track download progress by attaching a Listener to a response's BodyHandler . Similarly, upload progress is tracked by registering a Listener with a request's BodyPublisher . Track downloads Track uploads final Methanol client = Methanol . create (); final ProgressTracker tracker = ProgressTracker . newBuilder () . bytesTransferredThreshold ( 60 * 1024 ) // 60 kB . build (); HttpResponse < Path > downloadVeryInterestingVideo () throws IOException , InterruptedException { var request = MutableRequest . GET ( \"https://i.imgur.com/NYvl8Sy.mp4\" ); var downloadingBodyHandler = BodyHandlers . ofFile ( Path . of ( \"interesting-video.mp4\" ), CREATE , WRITE ); var trackingBodyHandler = tracker . tracking ( downloadingBodyHandler , this :: onProgress ); return client . send ( request , trackingBodyHandler ); } void onProgress ( Progress progress ) { if ( progress . determinate ()) { // Overall progress can be measured var percent = 100 * progress . value (); System . out . printf ( \"Downloaded %d from %d bytes (%.2f%%)%n\" , progress . totalBytesTransferred (), progress . contentLength (), percent ); } else { System . out . println ( \"Downloaded \" + progress . totalBytesTransferred ()); } if ( progress . done ()) { System . out . println ( \"Done!\" ); } } final Methanol client = Methanol . create (); final ProgressTracker tracker = ProgressTracker . newBuilder () . bytesTransferredThreshold ( 60 * 1024 ) // 60 kB . build (); < T > HttpResponse < T > upload ( Path file , BodyHandler < T > bodyHandler ) throws IOException , InterruptedException { var trackingRequestBody = tracker . tracking ( BodyPublishers . ofFile ( file ), this :: onProgress ); var request = MutableRequest . POST ( \"https://httpbin.org/post\" , trackingRequestBody ); return client . send ( request , bodyHandler ); } void onProgress ( Progress progress ) { if ( progress . determinate ()) { // Overall progress can be measured var percent = 100 * progress . value (); System . out . printf ( \"Uploaded %d from %d bytes (%.2f%%)%n\" , progress . totalBytesTransferred (), progress . contentLength (), percent ); } else { System . out . println ( \"Uploaded \" + progress . totalBytesTransferred ()); } if ( progress . done ()) { System . out . println ( \"Done!\" ); } }","title":"Usage"},{"location":"writablebodypublisher/","text":"WritableBodyPublisher \u00b6 Using WritableBodyPublisher , you can stream the request body through an OutputStream or a WritableByteChannel , possibly asynchronously. Example - Gzipped Uploads \u00b6 Let's say your sever supports compressed requests. You'd want your file uploads to be faster, so you compress the request body with gzip. final Methanol client = Methanol . create (); CompletableFuture < HttpResponse < Void >> postAsync ( Path file ) { var requestBody = WritableBodyPublisher . create (); var request = MutableRequest . POST ( \"https://example.com\" , requestBody ) . header ( \"Content-Encoding\" , \"gzip\" ); CompletableFuture . runAsync (() -> { try ( var gzipOut = new GZIPOutputStream ( requestBody . outputStream ())) { Files . copy ( file , gzipOut ); } catch ( IOException ioe ) { requestBody . closeExceptionally ( ioe ); } }); return client . sendAsync ( request , BodyHandlers . discarding ()); } WritableBodyPublisher acts as a pipe which connects OutputStream and BodyPublisher backends. It may buffer content temporarily in case the consumer can't keep up with the producer, or till an inner buffer becomes full. You can use WritableBodyPublisher::flush to make any buffered content available for consumption. After you're done writing, call close() or closeExceptionally(Throwable) to complete the request either normally or exceptionally.","title":"WritableBodyPublisher"},{"location":"writablebodypublisher/#writablebodypublisher","text":"Using WritableBodyPublisher , you can stream the request body through an OutputStream or a WritableByteChannel , possibly asynchronously.","title":"WritableBodyPublisher"},{"location":"writablebodypublisher/#example-gzipped-uploads","text":"Let's say your sever supports compressed requests. You'd want your file uploads to be faster, so you compress the request body with gzip. final Methanol client = Methanol . create (); CompletableFuture < HttpResponse < Void >> postAsync ( Path file ) { var requestBody = WritableBodyPublisher . create (); var request = MutableRequest . POST ( \"https://example.com\" , requestBody ) . header ( \"Content-Encoding\" , \"gzip\" ); CompletableFuture . runAsync (() -> { try ( var gzipOut = new GZIPOutputStream ( requestBody . outputStream ())) { Files . copy ( file , gzipOut ); } catch ( IOException ioe ) { requestBody . closeExceptionally ( ioe ); } }); return client . sendAsync ( request , BodyHandlers . discarding ()); } WritableBodyPublisher acts as a pipe which connects OutputStream and BodyPublisher backends. It may buffer content temporarily in case the consumer can't keep up with the producer, or till an inner buffer becomes full. You can use WritableBodyPublisher::flush to make any buffered content available for consumption. After you're done writing, call close() or closeExceptionally(Throwable) to complete the request either normally or exceptionally.","title":"Example - Gzipped Uploads"},{"location":"adapters/gson/","text":"methanol-gson \u00b6 Adapters for JSON using Gson . Installation \u00b6 Gradle \u00b6 implementation 'com.github.mizosoft.methanol:methanol-gson:1.7.0' Maven \u00b6 <dependency> <groupId> com.github.mizosoft.methanol </groupId> <artifactId> methanol-gson </artifactId> <version> 1.7.0 </version> </dependency> The adapters need to be registered as service providers so Methanol knows they're there. The way this is done depends on your project setup. Module Path \u00b6 Follow these steps if your project uses the Java module system. Add this class to your module: public class GsonProviders { private static final Gson gson = new Gson (); public static class EncoderProvider { public static BodyAdapter . Encoder provider () { return GsonAdapterFactory . createEncoder ( gson ); } } public static class DecoderProvider { public static BodyAdapter . Decoder provider () { return GsonAdapterFactory . createDecoder ( gson ); } } } Add the corresponding provider declarations in your module-info.java file. requires methanol . adapter . gson ; provides BodyAdapter . Encoder with GsonProviders . EncoderProvider ; provides BodyAdapter . Decoder with GsonProviders . DecoderProvider ; Classpath \u00b6 Registering adapters from the classpath requires declaring the implementation classes in provider-configuration files that are bundled with your JAR. You'll first need to implement delegating Encoder & Decoder that forward to the instances created by GsonAdapterFactory . Extending from ForwardingEncoder & ForwardingDecoder makes this easier. You can use Google's AutoService to generate the provider-configuration files automatically, so you won't bother writing them. Using AutoService \u00b6 First, install AutoService . Gradle \u00b6 implementation \"com.google.auto.service:auto-service-annotations:$autoServiceVersion\" annotationProcessor \"com.google.auto.service:auto-service:$autoServiceVersion\" Maven \u00b6 <dependency> <groupId> com.google.auto.service </groupId> <artifactId> auto-service-annotations </artifactId> <version> ${autoServiceVersion} </version> </dependency> Configure the annotation processor with the compiler plugin. <plugin> <artifactId> maven-compiler-plugin </artifactId> <configuration> <annotationProcessorPaths> <path> <groupId> com.google.auto.service </groupId> <artifactId> auto-service </artifactId> <version> ${autoServiceVersion} </version> </path> </annotationProcessorPaths> </configuration> </plugin> Next, add this class to your project: public class GsonAdapters { private static final Gson gson = new Gson (); @AutoService ( BodyAdapter . Encoder . class ) public static class GsonEncoder extends ForwardingEncoder { public GsonEncoder () { super ( GsonAdapterFactory . createEncoder ( gson )); } } @AutoService ( BodyAdapter . Decoder . class ) public static class GsonDecoder extends ForwardingDecoder { public GsonDecoder () { super ( GsonAdapterFactory . createDecoder ( gson )); } } } Manual Configuration \u00b6 You can also write the configuration files manually. First, add this class to your project: public class GsonAdapters { private static final Gson gson = new Gson (); public static class GsonEncoder extends ForwardingEncoder { public GsonEncoder () { super ( GsonAdapterFactory . createEncoder ( gson )); } } public static class GsonDecoder extends ForwardingDecoder { public GsonDecoder () { super ( GsonAdapterFactory . createDecoder ( gson )); } } } Next, create two provider-configuration files in the resource directory: META-INF/services , one for the encoder and the other for the decoder. Each file must contain the fully qualified name of the implementation class. Let's say the above class is in a package named com.example . You'll want to have one file for the encoder named: META-INF/services/com.github.mizosoft.methanol.BodyAdapter$Encoder and contains the following line: com.example.GsonAdapters$GsonEncoder Similarly, the decoder's file is named: META-INF/services/com.github.mizosoft.methanol.BodyAdapter$Decoder and contains: com.example.GsonAdapters$GsonDecoder","title":"methanol-gson"},{"location":"adapters/gson/#methanol-gson","text":"Adapters for JSON using Gson .","title":"methanol-gson"},{"location":"adapters/gson/#installation","text":"","title":"Installation"},{"location":"adapters/gson/#gradle","text":"implementation 'com.github.mizosoft.methanol:methanol-gson:1.7.0'","title":"Gradle"},{"location":"adapters/gson/#maven","text":"<dependency> <groupId> com.github.mizosoft.methanol </groupId> <artifactId> methanol-gson </artifactId> <version> 1.7.0 </version> </dependency> The adapters need to be registered as service providers so Methanol knows they're there. The way this is done depends on your project setup.","title":"Maven"},{"location":"adapters/gson/#module-path","text":"Follow these steps if your project uses the Java module system. Add this class to your module: public class GsonProviders { private static final Gson gson = new Gson (); public static class EncoderProvider { public static BodyAdapter . Encoder provider () { return GsonAdapterFactory . createEncoder ( gson ); } } public static class DecoderProvider { public static BodyAdapter . Decoder provider () { return GsonAdapterFactory . createDecoder ( gson ); } } } Add the corresponding provider declarations in your module-info.java file. requires methanol . adapter . gson ; provides BodyAdapter . Encoder with GsonProviders . EncoderProvider ; provides BodyAdapter . Decoder with GsonProviders . DecoderProvider ;","title":"Module Path"},{"location":"adapters/gson/#classpath","text":"Registering adapters from the classpath requires declaring the implementation classes in provider-configuration files that are bundled with your JAR. You'll first need to implement delegating Encoder & Decoder that forward to the instances created by GsonAdapterFactory . Extending from ForwardingEncoder & ForwardingDecoder makes this easier. You can use Google's AutoService to generate the provider-configuration files automatically, so you won't bother writing them.","title":"Classpath"},{"location":"adapters/gson/#using-autoservice","text":"First, install AutoService .","title":"Using AutoService"},{"location":"adapters/gson/#gradle_1","text":"implementation \"com.google.auto.service:auto-service-annotations:$autoServiceVersion\" annotationProcessor \"com.google.auto.service:auto-service:$autoServiceVersion\"","title":"Gradle"},{"location":"adapters/gson/#maven_1","text":"<dependency> <groupId> com.google.auto.service </groupId> <artifactId> auto-service-annotations </artifactId> <version> ${autoServiceVersion} </version> </dependency> Configure the annotation processor with the compiler plugin. <plugin> <artifactId> maven-compiler-plugin </artifactId> <configuration> <annotationProcessorPaths> <path> <groupId> com.google.auto.service </groupId> <artifactId> auto-service </artifactId> <version> ${autoServiceVersion} </version> </path> </annotationProcessorPaths> </configuration> </plugin> Next, add this class to your project: public class GsonAdapters { private static final Gson gson = new Gson (); @AutoService ( BodyAdapter . Encoder . class ) public static class GsonEncoder extends ForwardingEncoder { public GsonEncoder () { super ( GsonAdapterFactory . createEncoder ( gson )); } } @AutoService ( BodyAdapter . Decoder . class ) public static class GsonDecoder extends ForwardingDecoder { public GsonDecoder () { super ( GsonAdapterFactory . createDecoder ( gson )); } } }","title":"Maven"},{"location":"adapters/gson/#manual-configuration","text":"You can also write the configuration files manually. First, add this class to your project: public class GsonAdapters { private static final Gson gson = new Gson (); public static class GsonEncoder extends ForwardingEncoder { public GsonEncoder () { super ( GsonAdapterFactory . createEncoder ( gson )); } } public static class GsonDecoder extends ForwardingDecoder { public GsonDecoder () { super ( GsonAdapterFactory . createDecoder ( gson )); } } } Next, create two provider-configuration files in the resource directory: META-INF/services , one for the encoder and the other for the decoder. Each file must contain the fully qualified name of the implementation class. Let's say the above class is in a package named com.example . You'll want to have one file for the encoder named: META-INF/services/com.github.mizosoft.methanol.BodyAdapter$Encoder and contains the following line: com.example.GsonAdapters$GsonEncoder Similarly, the decoder's file is named: META-INF/services/com.github.mizosoft.methanol.BodyAdapter$Decoder and contains: com.example.GsonAdapters$GsonDecoder","title":"Manual Configuration"},{"location":"adapters/jackson/","text":"methanol-jackson \u00b6 Adapters for Jackson . Installation \u00b6 Gradle \u00b6 implementation 'com.github.mizosoft.methanol:methanol-jackson:1.7.0' Maven \u00b6 <dependency> <groupId> com.github.mizosoft.methanol </groupId> <artifactId> methanol-jackson </artifactId> <version> 1.7.0 </version> </dependency> The adapters need to be registered as service providers so Methanol knows they're there. The way this is done depends on your project setup. Module Path \u00b6 Follow these steps if your project uses the Java module system. Add this class to your module: public class JacksonProviders { private static final ObjectMapper mapper = new ObjectMapper (); public static class EncoderProvider { public static BodyAdapter . Encoder provider () { return JacksonAdapterFactory . createEncoder ( mapper ); } } public static class DecoderProvider { public static BodyAdapter . Decoder provider () { return JacksonAdapterFactory . createDecoder ( mapper ); } } } Add the corresponding provider declarations in your module-info.java file. requires methanol . adapter . jackson ; provides BodyAdapter . Encoder with JacksonProviders . EncoderProvider ; provides BodyAdapter . Decoder with JacksonProviders . DecoderProvider ; Classpath \u00b6 Registering adapters from the classpath requires declaring the implementation classes in provider-configuration files that are bundled with your JAR. You'll first need to implement delegating Encoder & Decoder that forward to the instances created by JacksonAdapterFactory . Extending from ForwardingEncoder & ForwardingDecoder makes this easier. You can use Google's AutoService to generate the provider-configuration files automatically, so you won't bother writing them. Using AutoService \u00b6 First, install AutoService . Gradle \u00b6 implementation \"com.google.auto.service:auto-service-annotations:$autoServiceVersion\" annotationProcessor \"com.google.auto.service:auto-service:$autoServiceVersion\" Maven \u00b6 <dependency> <groupId> com.google.auto.service </groupId> <artifactId> auto-service-annotations </artifactId> <version> ${autoServiceVersion} </version> </dependency> Configure the annotation processor with the compiler plugin. <plugin> <artifactId> maven-compiler-plugin </artifactId> <configuration> <annotationProcessorPaths> <path> <groupId> com.google.auto.service </groupId> <artifactId> auto-service </artifactId> <version> ${autoServiceVersion} </version> </path> </annotationProcessorPaths> </configuration> </plugin> Next, add this class to your project: public class JacksonAdapters { private static final ObjectMapper mapper = new ObjectMapper (); @AutoService ( BodyAdapter . Encoder . class ) public static class JacksonEncoder extends ForwardingEncoder { public JacksonEncoder () { super ( JacksonAdapterFactory . createEncoder ( mapper )); } } @AutoService ( BodyAdapter . Decoder . class ) public static class JacksonDecoder extends ForwardingDecoder { public JacksonDecoder () { super ( JacksonAdapterFactory . createDecoder ( mapper )); } } } Manual Configuration \u00b6 You can also write the configuration files manually. First, add this class to your project: public class JacksonAdapters { private static final ObjectMapper mapper = new ObjectMapper (); public static class JacksonEncoder extends ForwardingEncoder { public JacksonEncoder () { super ( JacksonAdapterFactory . createEncoder ( mapper )); } } public static class JacksonDecoder extends ForwardingDecoder { public JacksonDecoder () { super ( JacksonAdapterFactory . createDecoder ( mapper )); } } } Next, create two provider-configuration files in the resource directory: META-INF/services , one for the encoder and the other for the decoder. Each file must contain the fully qualified name of the implementation class. Let's say the above class is in a package named com.example . You'll want to have one file for the encoder named: META-INF/services/com.github.mizosoft.methanol.BodyAdapter$Encoder and contains the following line: com.example.JacksonAdapters$JacksonEncoder Similarly, the decoder's file is named: META-INF/services/com.github.mizosoft.methanol.BodyAdapter$Decoder and contains: com.example.JacksonAdapters$JacksonDecoder","title":"methanol-jackson"},{"location":"adapters/jackson/#methanol-jackson","text":"Adapters for Jackson .","title":"methanol-jackson"},{"location":"adapters/jackson/#installation","text":"","title":"Installation"},{"location":"adapters/jackson/#gradle","text":"implementation 'com.github.mizosoft.methanol:methanol-jackson:1.7.0'","title":"Gradle"},{"location":"adapters/jackson/#maven","text":"<dependency> <groupId> com.github.mizosoft.methanol </groupId> <artifactId> methanol-jackson </artifactId> <version> 1.7.0 </version> </dependency> The adapters need to be registered as service providers so Methanol knows they're there. The way this is done depends on your project setup.","title":"Maven"},{"location":"adapters/jackson/#module-path","text":"Follow these steps if your project uses the Java module system. Add this class to your module: public class JacksonProviders { private static final ObjectMapper mapper = new ObjectMapper (); public static class EncoderProvider { public static BodyAdapter . Encoder provider () { return JacksonAdapterFactory . createEncoder ( mapper ); } } public static class DecoderProvider { public static BodyAdapter . Decoder provider () { return JacksonAdapterFactory . createDecoder ( mapper ); } } } Add the corresponding provider declarations in your module-info.java file. requires methanol . adapter . jackson ; provides BodyAdapter . Encoder with JacksonProviders . EncoderProvider ; provides BodyAdapter . Decoder with JacksonProviders . DecoderProvider ;","title":"Module Path"},{"location":"adapters/jackson/#classpath","text":"Registering adapters from the classpath requires declaring the implementation classes in provider-configuration files that are bundled with your JAR. You'll first need to implement delegating Encoder & Decoder that forward to the instances created by JacksonAdapterFactory . Extending from ForwardingEncoder & ForwardingDecoder makes this easier. You can use Google's AutoService to generate the provider-configuration files automatically, so you won't bother writing them.","title":"Classpath"},{"location":"adapters/jackson/#using-autoservice","text":"First, install AutoService .","title":"Using AutoService"},{"location":"adapters/jackson/#gradle_1","text":"implementation \"com.google.auto.service:auto-service-annotations:$autoServiceVersion\" annotationProcessor \"com.google.auto.service:auto-service:$autoServiceVersion\"","title":"Gradle"},{"location":"adapters/jackson/#maven_1","text":"<dependency> <groupId> com.google.auto.service </groupId> <artifactId> auto-service-annotations </artifactId> <version> ${autoServiceVersion} </version> </dependency> Configure the annotation processor with the compiler plugin. <plugin> <artifactId> maven-compiler-plugin </artifactId> <configuration> <annotationProcessorPaths> <path> <groupId> com.google.auto.service </groupId> <artifactId> auto-service </artifactId> <version> ${autoServiceVersion} </version> </path> </annotationProcessorPaths> </configuration> </plugin> Next, add this class to your project: public class JacksonAdapters { private static final ObjectMapper mapper = new ObjectMapper (); @AutoService ( BodyAdapter . Encoder . class ) public static class JacksonEncoder extends ForwardingEncoder { public JacksonEncoder () { super ( JacksonAdapterFactory . createEncoder ( mapper )); } } @AutoService ( BodyAdapter . Decoder . class ) public static class JacksonDecoder extends ForwardingDecoder { public JacksonDecoder () { super ( JacksonAdapterFactory . createDecoder ( mapper )); } } }","title":"Maven"},{"location":"adapters/jackson/#manual-configuration","text":"You can also write the configuration files manually. First, add this class to your project: public class JacksonAdapters { private static final ObjectMapper mapper = new ObjectMapper (); public static class JacksonEncoder extends ForwardingEncoder { public JacksonEncoder () { super ( JacksonAdapterFactory . createEncoder ( mapper )); } } public static class JacksonDecoder extends ForwardingDecoder { public JacksonDecoder () { super ( JacksonAdapterFactory . createDecoder ( mapper )); } } } Next, create two provider-configuration files in the resource directory: META-INF/services , one for the encoder and the other for the decoder. Each file must contain the fully qualified name of the implementation class. Let's say the above class is in a package named com.example . You'll want to have one file for the encoder named: META-INF/services/com.github.mizosoft.methanol.BodyAdapter$Encoder and contains the following line: com.example.JacksonAdapters$JacksonEncoder Similarly, the decoder's file is named: META-INF/services/com.github.mizosoft.methanol.BodyAdapter$Decoder and contains: com.example.JacksonAdapters$JacksonDecoder","title":"Manual Configuration"},{"location":"adapters/jackson_flux/","text":"methanol-jackson-flux \u00b6 Adapters for JSON & Reactive Streams using Jackson & Reactor . Decoding \u00b6 This adapter converts response bodies into publisher-based sources. Supported types are Mono , Flux , org.reactivestreams.Publisher and java.util.concurrent.Flow.Publisher . For all these types except Mono , the response body is expected to be a JSON array. The array is tokenized into its individual elements, each mapped to the publisher's element type. Note that an HttpResponse handled with this adapter is completed immediately after the response headers are received. Body completion is handled by the returned publisher source. Additionally, the decoder always uses Jackson's non-blocking parser. This makes MoreBodyHandlers::ofDeferredObject redundant with this decoder. Encoding \u00b6 With the exception of Mono , any subtype of org.reactivestreams.Publisher or java.util.concurrent.Flow.Publisher is encoded to a JSON array containing zero or more elements, each mapped from each published object. Mono sources are encoded to a single JSON object (if completed with any). Installation \u00b6 Gradle \u00b6 implementation 'com.github.mizosoft.methanol:methanol-jackson-flux:1.7.0' Maven \u00b6 <dependency> <groupId> com.github.mizosoft.methanol </groupId> <artifactId> methanol-jackson-flux </artifactId> <version> 1.7.0 </version> </dependency> The adapters need to be registered as service providers so Methanol knows they're there. The way this is done depends on your project setup. Module Path \u00b6 Follow these steps if your project uses the Java module system. Add this class to your module: public class JacksonFluxProviders { private static final ObjectMapper mapper = new ObjectMapper (); public static class EncoderProvider { public static BodyAdapter . Encoder provider () { return JacksonFluxAdapterFactory . createEncoder ( mapper ); } } public static class DecoderProvider { public static BodyAdapter . Decoder provider () { return JacksonFluxAdapterFactory . createDecoder ( mapper ); } } } Add the corresponding provider declarations in your module-info.java file. requires methanol . adapter . jackson . flux ; provides BodyAdapter . Encoder with JacksonFluxProviders . EncoderProvider ; provides BodyAdapter . Decoder with JacksonFluxProviders . DecoderProvider ; Classpath \u00b6 Registering adapters from the classpath requires declaring the implementation classes in provider-configuration files that are bundled with your JAR. You'll first need to implement delegating Encoder & Decoder that forward to the instances created by JacksonAdapterFactory . Extending from ForwardingEncoder & ForwardingDecoder makes this easier. You can use Google's AutoService to generate the provider-configuration files automatically, so you won't bother writing them. Using AutoService \u00b6 First, install AutoService . Gradle \u00b6 implementation \"com.google.auto.service:auto-service-annotations:$autoServiceVersion\" annotationProcessor \"com.google.auto.service:auto-service:$autoServiceVersion\" Maven \u00b6 <dependency> <groupId> com.google.auto.service </groupId> <artifactId> auto-service-annotations </artifactId> <version> ${autoServiceVersion} </version> </dependency> Configure the annotation processor with the compiler plugin. <plugin> <artifactId> maven-compiler-plugin </artifactId> <configuration> <annotationProcessorPaths> <path> <groupId> com.google.auto.service </groupId> <artifactId> auto-service </artifactId> <version> ${autoServiceVersion} </version> </path> </annotationProcessorPaths> </configuration> </plugin> Next, add this class to your project: public class JacksonFluxAdapters { private static final ObjectMapper mapper = new ObjectMapper (); @AutoService ( BodyAdapter . Encoder . class ) public static class JacksonFluxEncoder extends ForwardingEncoder { public JacksonFluxEncoder () { super ( JacksonFluxAdapterFactory . createEncoder ( mapper )); } } @AutoService ( BodyAdapter . Decoder . class ) public static class JacksonFluxDecoder extends ForwardingDecoder { public JacksonFluxDecoder () { super ( JacksonFluxAdapterFactory . createDecoder ( mapper )); } } } Manual Configuration \u00b6 You can also write the configuration files manually. First, add this class to your project: public class JacksonFluxAdapters { private static final ObjectMapper mapper = new ObjectMapper (); public static class JacksonFluxEncoder extends ForwardingEncoder { public JacksonFluxEncoder () { super ( JacksonFluxAdapterFactory . createEncoder ( mapper )); } } public static class JacksonFluxDecoder extends ForwardingDecoder { public JacksonFluxDecoder () { super ( JacksonFluxAdapterFactory . createDecoder ( mapper )); } } } Next, create two provider-configuration files in the resource directory: META-INF/services , one for the encoder and the other for the decoder. Each file must contain the fully qualified name of the implementation class. Let's say the above class is in a package named com.example . You'll want to have one file for the encoder named: META-INF/services/com.github.mizosoft.methanol.BodyAdapter$Encoder and contains the following line: com.example.JacksonFluxAdapters$JacksonFluxEncoder Similarly, the decoder's file is named: META-INF/services/com.github.mizosoft.methanol.BodyAdapter$Decoder and contains: com.example.JacksonFluxAdapters$JacksonFluxDecoder","title":"methanol-jackson-flux"},{"location":"adapters/jackson_flux/#methanol-jackson-flux","text":"Adapters for JSON & Reactive Streams using Jackson & Reactor .","title":"methanol-jackson-flux"},{"location":"adapters/jackson_flux/#decoding","text":"This adapter converts response bodies into publisher-based sources. Supported types are Mono , Flux , org.reactivestreams.Publisher and java.util.concurrent.Flow.Publisher . For all these types except Mono , the response body is expected to be a JSON array. The array is tokenized into its individual elements, each mapped to the publisher's element type. Note that an HttpResponse handled with this adapter is completed immediately after the response headers are received. Body completion is handled by the returned publisher source. Additionally, the decoder always uses Jackson's non-blocking parser. This makes MoreBodyHandlers::ofDeferredObject redundant with this decoder.","title":"Decoding"},{"location":"adapters/jackson_flux/#encoding","text":"With the exception of Mono , any subtype of org.reactivestreams.Publisher or java.util.concurrent.Flow.Publisher is encoded to a JSON array containing zero or more elements, each mapped from each published object. Mono sources are encoded to a single JSON object (if completed with any).","title":"Encoding"},{"location":"adapters/jackson_flux/#installation","text":"","title":"Installation"},{"location":"adapters/jackson_flux/#gradle","text":"implementation 'com.github.mizosoft.methanol:methanol-jackson-flux:1.7.0'","title":"Gradle"},{"location":"adapters/jackson_flux/#maven","text":"<dependency> <groupId> com.github.mizosoft.methanol </groupId> <artifactId> methanol-jackson-flux </artifactId> <version> 1.7.0 </version> </dependency> The adapters need to be registered as service providers so Methanol knows they're there. The way this is done depends on your project setup.","title":"Maven"},{"location":"adapters/jackson_flux/#module-path","text":"Follow these steps if your project uses the Java module system. Add this class to your module: public class JacksonFluxProviders { private static final ObjectMapper mapper = new ObjectMapper (); public static class EncoderProvider { public static BodyAdapter . Encoder provider () { return JacksonFluxAdapterFactory . createEncoder ( mapper ); } } public static class DecoderProvider { public static BodyAdapter . Decoder provider () { return JacksonFluxAdapterFactory . createDecoder ( mapper ); } } } Add the corresponding provider declarations in your module-info.java file. requires methanol . adapter . jackson . flux ; provides BodyAdapter . Encoder with JacksonFluxProviders . EncoderProvider ; provides BodyAdapter . Decoder with JacksonFluxProviders . DecoderProvider ;","title":"Module Path"},{"location":"adapters/jackson_flux/#classpath","text":"Registering adapters from the classpath requires declaring the implementation classes in provider-configuration files that are bundled with your JAR. You'll first need to implement delegating Encoder & Decoder that forward to the instances created by JacksonAdapterFactory . Extending from ForwardingEncoder & ForwardingDecoder makes this easier. You can use Google's AutoService to generate the provider-configuration files automatically, so you won't bother writing them.","title":"Classpath"},{"location":"adapters/jackson_flux/#using-autoservice","text":"First, install AutoService .","title":"Using AutoService"},{"location":"adapters/jackson_flux/#gradle_1","text":"implementation \"com.google.auto.service:auto-service-annotations:$autoServiceVersion\" annotationProcessor \"com.google.auto.service:auto-service:$autoServiceVersion\"","title":"Gradle"},{"location":"adapters/jackson_flux/#maven_1","text":"<dependency> <groupId> com.google.auto.service </groupId> <artifactId> auto-service-annotations </artifactId> <version> ${autoServiceVersion} </version> </dependency> Configure the annotation processor with the compiler plugin. <plugin> <artifactId> maven-compiler-plugin </artifactId> <configuration> <annotationProcessorPaths> <path> <groupId> com.google.auto.service </groupId> <artifactId> auto-service </artifactId> <version> ${autoServiceVersion} </version> </path> </annotationProcessorPaths> </configuration> </plugin> Next, add this class to your project: public class JacksonFluxAdapters { private static final ObjectMapper mapper = new ObjectMapper (); @AutoService ( BodyAdapter . Encoder . class ) public static class JacksonFluxEncoder extends ForwardingEncoder { public JacksonFluxEncoder () { super ( JacksonFluxAdapterFactory . createEncoder ( mapper )); } } @AutoService ( BodyAdapter . Decoder . class ) public static class JacksonFluxDecoder extends ForwardingDecoder { public JacksonFluxDecoder () { super ( JacksonFluxAdapterFactory . createDecoder ( mapper )); } } }","title":"Maven"},{"location":"adapters/jackson_flux/#manual-configuration","text":"You can also write the configuration files manually. First, add this class to your project: public class JacksonFluxAdapters { private static final ObjectMapper mapper = new ObjectMapper (); public static class JacksonFluxEncoder extends ForwardingEncoder { public JacksonFluxEncoder () { super ( JacksonFluxAdapterFactory . createEncoder ( mapper )); } } public static class JacksonFluxDecoder extends ForwardingDecoder { public JacksonFluxDecoder () { super ( JacksonFluxAdapterFactory . createDecoder ( mapper )); } } } Next, create two provider-configuration files in the resource directory: META-INF/services , one for the encoder and the other for the decoder. Each file must contain the fully qualified name of the implementation class. Let's say the above class is in a package named com.example . You'll want to have one file for the encoder named: META-INF/services/com.github.mizosoft.methanol.BodyAdapter$Encoder and contains the following line: com.example.JacksonFluxAdapters$JacksonFluxEncoder Similarly, the decoder's file is named: META-INF/services/com.github.mizosoft.methanol.BodyAdapter$Decoder and contains: com.example.JacksonFluxAdapters$JacksonFluxDecoder","title":"Manual Configuration"},{"location":"adapters/jaxb/","text":"methanol-jaxb \u00b6 Adapters for XML using JAXB . Installation \u00b6 Gradle \u00b6 implementation 'com.github.mizosoft.methanol:methanol-jaxb:1.7.0' Maven \u00b6 <dependency> <groupId> com.github.mizosoft.methanol </groupId> <artifactId> methanol-jaxb </artifactId> <version> 1.7.0 </version> </dependency> The adapters need to be registered as service providers so Methanol knows they're there. The way this is done depends on your project setup. Module Path \u00b6 Follow these steps if your project uses the Java module system. Add this class to your module: public class JaxbProviders { public static class EncoderProvider { public static BodyAdapter . Encoder provider () { return JaxbAdapterFactory . createEncoder (); } } public static class DecoderProvider { public static BodyAdapter . Decoder provider () { return JaxbAdapterFactory . createDecoder (); } } } Add the corresponding provider declarations in your module-info.java file. requires methanol . adapter . jaxb ; provides BodyAdapter . Encoder with JaxbProviders . EncoderProvider ; provides BodyAdapter . Decoder with JaxbProviders . DecoderProvider ; Classpath \u00b6 Registering adapters from the classpath requires declaring the implementation classes in provider-configuration files that are bundled with your JAR. You'll first need to implement delegating Encoder & Decoder that forward to the instances created by JaxbAdapterFactory . Extending from ForwardingEncoder & ForwardingDecoder makes this easier. You can use Google's AutoService to generate the provider-configuration files automatically, so you won't bother writing them. Using AutoService \u00b6 First, install AutoService . Gradle \u00b6 implementation \"com.google.auto.service:auto-service-annotations:$autoServiceVersion\" annotationProcessor \"com.google.auto.service:auto-service:$autoServiceVersion\" Maven \u00b6 <dependency> <groupId> com.google.auto.service </groupId> <artifactId> auto-service-annotations </artifactId> <version> ${autoServiceVersion} </version> </dependency> Configure the annotation processor with the compiler plugin. <plugin> <artifactId> maven-compiler-plugin </artifactId> <configuration> <annotationProcessorPaths> <path> <groupId> com.google.auto.service </groupId> <artifactId> auto-service </artifactId> <version> ${autoServiceVersion} </version> </path> </annotationProcessorPaths> </configuration> </plugin> Next, add this class to your project: public class JaxbAdapters { @AutoService ( BodyAdapter . Encoder . class ) public static class JaxbEncoder extends ForwardingEncoder { public JaxbEncoder () { super ( JaxbAdapterFactory . createEncoder ()); } } @AutoService ( BodyAdapter . Decoder . class ) public static class JaxbDecoder extends ForwardingDecoder { public JaxbDecoder () { super ( JaxbAdapterFactory . createDecoder ()); } } } Manual Configuration \u00b6 You can also write the configuration files manually. First, add this class to your project: public class JaxbAdapters { public static class JaxbEncoder extends ForwardingEncoder { public JaxbEncoder () { super ( JaxbAdapterFactory . createEncoder ()); } } public static class JaxbDecoder extends ForwardingDecoder { public JaxbDecoder () { super ( JaxbAdapterFactory . createDecoder ()); } } } Next, create two provider-configuration files in the resource directory: META-INF/services , one for the encoder and the other for the decoder. Each file must contain the fully qualified name of the implementation class. Let's say the above class is in a package named com.example . You'll want to have one file for the encoder named: META-INF/services/com.github.mizosoft.methanol.BodyAdapter$Encoder and contains the following line: com.example.JaxbAdapters$JaxbEncoder Similarly, the decoder's file is named: META-INF/services/com.github.mizosoft.methanol.BodyAdapter$Decoder and contains: com.example.JaxbAdapters$JaxbDecoder","title":"methanol-jaxb"},{"location":"adapters/jaxb/#methanol-jaxb","text":"Adapters for XML using JAXB .","title":"methanol-jaxb"},{"location":"adapters/jaxb/#installation","text":"","title":"Installation"},{"location":"adapters/jaxb/#gradle","text":"implementation 'com.github.mizosoft.methanol:methanol-jaxb:1.7.0'","title":"Gradle"},{"location":"adapters/jaxb/#maven","text":"<dependency> <groupId> com.github.mizosoft.methanol </groupId> <artifactId> methanol-jaxb </artifactId> <version> 1.7.0 </version> </dependency> The adapters need to be registered as service providers so Methanol knows they're there. The way this is done depends on your project setup.","title":"Maven"},{"location":"adapters/jaxb/#module-path","text":"Follow these steps if your project uses the Java module system. Add this class to your module: public class JaxbProviders { public static class EncoderProvider { public static BodyAdapter . Encoder provider () { return JaxbAdapterFactory . createEncoder (); } } public static class DecoderProvider { public static BodyAdapter . Decoder provider () { return JaxbAdapterFactory . createDecoder (); } } } Add the corresponding provider declarations in your module-info.java file. requires methanol . adapter . jaxb ; provides BodyAdapter . Encoder with JaxbProviders . EncoderProvider ; provides BodyAdapter . Decoder with JaxbProviders . DecoderProvider ;","title":"Module Path"},{"location":"adapters/jaxb/#classpath","text":"Registering adapters from the classpath requires declaring the implementation classes in provider-configuration files that are bundled with your JAR. You'll first need to implement delegating Encoder & Decoder that forward to the instances created by JaxbAdapterFactory . Extending from ForwardingEncoder & ForwardingDecoder makes this easier. You can use Google's AutoService to generate the provider-configuration files automatically, so you won't bother writing them.","title":"Classpath"},{"location":"adapters/jaxb/#using-autoservice","text":"First, install AutoService .","title":"Using AutoService"},{"location":"adapters/jaxb/#gradle_1","text":"implementation \"com.google.auto.service:auto-service-annotations:$autoServiceVersion\" annotationProcessor \"com.google.auto.service:auto-service:$autoServiceVersion\"","title":"Gradle"},{"location":"adapters/jaxb/#maven_1","text":"<dependency> <groupId> com.google.auto.service </groupId> <artifactId> auto-service-annotations </artifactId> <version> ${autoServiceVersion} </version> </dependency> Configure the annotation processor with the compiler plugin. <plugin> <artifactId> maven-compiler-plugin </artifactId> <configuration> <annotationProcessorPaths> <path> <groupId> com.google.auto.service </groupId> <artifactId> auto-service </artifactId> <version> ${autoServiceVersion} </version> </path> </annotationProcessorPaths> </configuration> </plugin> Next, add this class to your project: public class JaxbAdapters { @AutoService ( BodyAdapter . Encoder . class ) public static class JaxbEncoder extends ForwardingEncoder { public JaxbEncoder () { super ( JaxbAdapterFactory . createEncoder ()); } } @AutoService ( BodyAdapter . Decoder . class ) public static class JaxbDecoder extends ForwardingDecoder { public JaxbDecoder () { super ( JaxbAdapterFactory . createDecoder ()); } } }","title":"Maven"},{"location":"adapters/jaxb/#manual-configuration","text":"You can also write the configuration files manually. First, add this class to your project: public class JaxbAdapters { public static class JaxbEncoder extends ForwardingEncoder { public JaxbEncoder () { super ( JaxbAdapterFactory . createEncoder ()); } } public static class JaxbDecoder extends ForwardingDecoder { public JaxbDecoder () { super ( JaxbAdapterFactory . createDecoder ()); } } } Next, create two provider-configuration files in the resource directory: META-INF/services , one for the encoder and the other for the decoder. Each file must contain the fully qualified name of the implementation class. Let's say the above class is in a package named com.example . You'll want to have one file for the encoder named: META-INF/services/com.github.mizosoft.methanol.BodyAdapter$Encoder and contains the following line: com.example.JaxbAdapters$JaxbEncoder Similarly, the decoder's file is named: META-INF/services/com.github.mizosoft.methanol.BodyAdapter$Decoder and contains: com.example.JaxbAdapters$JaxbDecoder","title":"Manual Configuration"},{"location":"adapters/protobuf/","text":"methanol-protobuf \u00b6 Adapters for Google's Protocol Buffers . Encoding & Decoding \u00b6 Any subtype of MessageLite is supported by encoders & decoders. Decoders can optionally have an ExtensionRegistryLite or an ExtensionRegistry to enable message extensions . Installation \u00b6 Gradle \u00b6 implementation 'com.github.mizosoft.methanol:methanol-protobuf:1.7.0' Maven \u00b6 <dependency> <groupId> com.github.mizosoft.methanol </groupId> <artifactId> methanol-protobuf </artifactId> <version> 1.7.0 </version> </dependency> The adapters need to be registered as service providers so Methanol knows they're there. The way this is done depends on your project setup. Module Path \u00b6 Follow these steps if your project uses the Java module system. Add this class to your module: public class ProtobufProviders { public static class EncoderProvider { public static BodyAdapter . Encoder provider () { return ProtobufAdapterFactory . createEncoder (); } } public static class DecoderProvider { public static BodyAdapter . Decoder provider () { return ProtobufAdapterFactory . createDecoder (); } } } Add the corresponding provider declarations in your module-info.java file. requires methanol . adapter . protobuf ; provides BodyAdapter . Encoder with ProtobufProviders . EncoderProvider ; provides BodyAdapter . Decoder with ProtobufProviders . DecoderProvider ; Classpath \u00b6 Registering adapters from the classpath requires declaring the implementation classes in provider-configuration files that are bundled with your JAR. You'll first need to implement delegating Encoder & Decoder that forward to the instances created by ProtobufAdapterFactory . Extending from ForwardingEncoder & ForwardingDecoder makes this easier. You can use Google's AutoService to generate the provider-configuration files automatically, so you won't bother writing them. Using AutoService \u00b6 First, install AutoService . Gradle \u00b6 implementation \"com.google.auto.service:auto-service-annotations:$autoServiceVersion\" annotationProcessor \"com.google.auto.service:auto-service:$autoServiceVersion\" Maven \u00b6 <dependency> <groupId> com.google.auto.service </groupId> <artifactId> auto-service-annotations </artifactId> <version> ${autoServiceVersion} </version> </dependency> Configure the annotation processor with the compiler plugin. <plugin> <artifactId> maven-compiler-plugin </artifactId> <configuration> <annotationProcessorPaths> <path> <groupId> com.google.auto.service </groupId> <artifactId> auto-service </artifactId> <version> ${autoServiceVersion} </version> </path> </annotationProcessorPaths> </configuration> </plugin> Next, add this class to your project: public class ProtobufAdapters { @AutoService ( BodyAdapter . Encoder . class ) public static class ProtobufEncoder extends ForwardingEncoder { public ProtobufEncoder () { super ( ProtobufAdapterFactory . createEncoder ()); } } @AutoService ( BodyAdapter . Decoder . class ) public static class ProtobufDecoder extends ForwardingDecoder { public ProtobufDecoder () { super ( ProtobufAdapterFactory . createDecoder ()); } } } Manual Configuration \u00b6 You can also write the configuration files manually. First, add this class to your project: public class ProtobufAdapters { public static class ProtobufDecoder extends ForwardingDecoder { public ProtobufDecoder () { super ( ProtobufAdapterFactory . createDecoder ()); } } public static class ProtobufEncoder extends ForwardingEncoder { public ProtobufEncoder () { super ( ProtobufAdapterFactory . createEncoder ()); } } } Next, create two provider-configuration files in the resource directory: META-INF/services , one for the encoder and the other for the decoder. Each file must contain the fully qualified name of the implementation class. Let's say the above class is in a package named com.example . You'll want to have one file for the encoder named: META-INF/services/com.github.mizosoft.methanol.BodyAdapter$Encoder and contains the following line: com.example.ProtobufAdapters$ProtobufEncoder Similarly, the decoder's file is named: META-INF/services/com.github.mizosoft.methanol.BodyAdapter$Decoder and contains: com.example.ProtobufAdapters$ProtobufDecoder","title":"methanol-protobuf"},{"location":"adapters/protobuf/#methanol-protobuf","text":"Adapters for Google's Protocol Buffers .","title":"methanol-protobuf"},{"location":"adapters/protobuf/#encoding-decoding","text":"Any subtype of MessageLite is supported by encoders & decoders. Decoders can optionally have an ExtensionRegistryLite or an ExtensionRegistry to enable message extensions .","title":"Encoding &amp; Decoding"},{"location":"adapters/protobuf/#installation","text":"","title":"Installation"},{"location":"adapters/protobuf/#gradle","text":"implementation 'com.github.mizosoft.methanol:methanol-protobuf:1.7.0'","title":"Gradle"},{"location":"adapters/protobuf/#maven","text":"<dependency> <groupId> com.github.mizosoft.methanol </groupId> <artifactId> methanol-protobuf </artifactId> <version> 1.7.0 </version> </dependency> The adapters need to be registered as service providers so Methanol knows they're there. The way this is done depends on your project setup.","title":"Maven"},{"location":"adapters/protobuf/#module-path","text":"Follow these steps if your project uses the Java module system. Add this class to your module: public class ProtobufProviders { public static class EncoderProvider { public static BodyAdapter . Encoder provider () { return ProtobufAdapterFactory . createEncoder (); } } public static class DecoderProvider { public static BodyAdapter . Decoder provider () { return ProtobufAdapterFactory . createDecoder (); } } } Add the corresponding provider declarations in your module-info.java file. requires methanol . adapter . protobuf ; provides BodyAdapter . Encoder with ProtobufProviders . EncoderProvider ; provides BodyAdapter . Decoder with ProtobufProviders . DecoderProvider ;","title":"Module Path"},{"location":"adapters/protobuf/#classpath","text":"Registering adapters from the classpath requires declaring the implementation classes in provider-configuration files that are bundled with your JAR. You'll first need to implement delegating Encoder & Decoder that forward to the instances created by ProtobufAdapterFactory . Extending from ForwardingEncoder & ForwardingDecoder makes this easier. You can use Google's AutoService to generate the provider-configuration files automatically, so you won't bother writing them.","title":"Classpath"},{"location":"adapters/protobuf/#using-autoservice","text":"First, install AutoService .","title":"Using AutoService"},{"location":"adapters/protobuf/#gradle_1","text":"implementation \"com.google.auto.service:auto-service-annotations:$autoServiceVersion\" annotationProcessor \"com.google.auto.service:auto-service:$autoServiceVersion\"","title":"Gradle"},{"location":"adapters/protobuf/#maven_1","text":"<dependency> <groupId> com.google.auto.service </groupId> <artifactId> auto-service-annotations </artifactId> <version> ${autoServiceVersion} </version> </dependency> Configure the annotation processor with the compiler plugin. <plugin> <artifactId> maven-compiler-plugin </artifactId> <configuration> <annotationProcessorPaths> <path> <groupId> com.google.auto.service </groupId> <artifactId> auto-service </artifactId> <version> ${autoServiceVersion} </version> </path> </annotationProcessorPaths> </configuration> </plugin> Next, add this class to your project: public class ProtobufAdapters { @AutoService ( BodyAdapter . Encoder . class ) public static class ProtobufEncoder extends ForwardingEncoder { public ProtobufEncoder () { super ( ProtobufAdapterFactory . createEncoder ()); } } @AutoService ( BodyAdapter . Decoder . class ) public static class ProtobufDecoder extends ForwardingDecoder { public ProtobufDecoder () { super ( ProtobufAdapterFactory . createDecoder ()); } } }","title":"Maven"},{"location":"adapters/protobuf/#manual-configuration","text":"You can also write the configuration files manually. First, add this class to your project: public class ProtobufAdapters { public static class ProtobufDecoder extends ForwardingDecoder { public ProtobufDecoder () { super ( ProtobufAdapterFactory . createDecoder ()); } } public static class ProtobufEncoder extends ForwardingEncoder { public ProtobufEncoder () { super ( ProtobufAdapterFactory . createEncoder ()); } } } Next, create two provider-configuration files in the resource directory: META-INF/services , one for the encoder and the other for the decoder. Each file must contain the fully qualified name of the implementation class. Let's say the above class is in a package named com.example . You'll want to have one file for the encoder named: META-INF/services/com.github.mizosoft.methanol.BodyAdapter$Encoder and contains the following line: com.example.ProtobufAdapters$ProtobufEncoder Similarly, the decoder's file is named: META-INF/services/com.github.mizosoft.methanol.BodyAdapter$Decoder and contains: com.example.ProtobufAdapters$ProtobufDecoder","title":"Manual Configuration"}]}