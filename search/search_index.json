{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Methanol","text":"<p>Java enjoys a neat, built-in HTTP client. However, it lacks key HTTP features like multipart uploads, caching and response decompression. Methanol comes in to fill these gaps. The library comprises a set of lightweight, yet powerful extensions aimed at making it much easier &amp; more productive to work with <code>java.net.http</code>. You can say it's an <code>HttpClient</code> wrapper, but you'll see it almost seamlessly integrates with the standard API you might already know.</p> <p>Methanol isn't invasive. The core library has zero runtime dependencies. However, special attention is given to object mapping, so integration with libraries like Jackson or Gson becomes a breeze.</p>"},{"location":"#installation","title":"Installation","text":""},{"location":"#gradle","title":"Gradle","text":"<pre><code>implementation 'com.github.mizosoft.methanol:methanol:1.7.0'\n</code></pre>"},{"location":"#maven","title":"Maven","text":"<pre><code>&lt;dependency&gt;\n&lt;groupId&gt;com.github.mizosoft.methanol&lt;/groupId&gt;\n&lt;artifactId&gt;methanol&lt;/artifactId&gt;\n&lt;version&gt;1.7.0&lt;/version&gt;\n&lt;/dependency&gt;\n</code></pre>"},{"location":"#contributing","title":"Contributing","text":"<p>See CONTRIBUTING</p>"},{"location":"#license","title":"License","text":"<p>MIT</p>"},{"location":"CHANGELOG/","title":"Change Log","text":""},{"location":"CHANGELOG/#version-170","title":"Version 1.7.0","text":"<p>9-5-2022</p> <p>A full year has passed since the last Methanol release! Time truly flies. It's been difficult to find the time to cut this release due to my senior college year &amp; other life circumstances, but here we are!</p> <ul> <li>The Jackson adapter has been reworked to support the multitude of formats supported by Jackson, not    only JSON (#45). That means you can now pass arbitrary   <code>ObjectMapper</code> instances along with one or more <code>MediaTypes</code> describing their formats. For instance,   here's a provider for a Jackson-based XML decoder.</li> </ul> <pre><code>public class JacksonXmlDecoderProvider {\nprivate JacksonXmlDecoderProvider() {}\n\npublic static BodyAdapter.Decoder provider() {\nreturn JacksonAdapterFactory.createDecoder(new XmlMapper(), MediaType.TEXT_XML);\n}\n}\n</code></pre> <p>Binary formats (e.g. protocol buffers) usually require applying a schema for each type. <code>ObjectReaderFacotry</code>    &amp; <code>ObjectWriterFactory</code> have been added for this purpose. For instance, here's a provider for a protocol-buffers   decoder. You'll need to know which types to expect beforehand.</p> <pre><code>public class JacksonProtobufDecoderProvider {\nprivate JacksonProtobufDecoderProvider() {}\n\npublic record Point(int x, int y) {}\n\npublic static BodyAdapter.Decoder provider() throws IOException {\nvar schemas = Map.of(\nTypeRef.from(Point.class),\nProtobufSchemaLoader.std.parse(\n\"\"\"\n            message Point {\n              required int32 x = 1;\n              required int32 y = 2;\n            }\n            \"\"\"), ...);\n\n// Apply the corresponding schema for each created ObjectReader\nObjectReaderFactory readerFactory = (mapper, type) -&gt; mapper.readerFor(type.rawType()).with(schemas.get(type));\nreturn JacksonAdapterFactory.createDecoder(\nnew ProtobufMapper(), readerFactory, MediaType.APPLICATION_X_PROTOBUF);\n}\n}\n</code></pre> <ul> <li> <p>To avoid ambiguity, <code>JacksonAdapterFactory::createDecoder</code> &amp; <code>JacksonAdapterFactory::createEncoder</code>   that don't take an explicit <code>MediaType</code> have been deprecated and replaced with <code>JacksonAdapterFactory::createJsonDecoder</code>   &amp; <code>JacksonAdapterFactory::createJsonEncoder</code> respectively.</p> </li> <li> <p>Added timeouts for receiving all response headers (#49).   You can use these along with read timeouts to set more granular timing constraints for your requests   when request timeouts are too strict.</p> </li> </ul> <pre><code>var client = Methanol.newBuilder()\n.headersTimeout(Duration.ofSeconds(30))\n.readTimeout(Duration.ofSeconds(30))\n...\n.build()\n</code></pre> <ul> <li>Fix (#40): Methanol had a long-lived issue that made it   difficult for service providers to work with custom JAR formats, particularly the one used by Spring Boot's   executable JARs.   Instead of the system classloader, Methanol now relies on the classloader that loaded the library itself   for locating providers. This is not necessarily the system classloader as in the case with Spring Boot.</li> <li>Fix (46): <code>ProgressTracker</code> now returns <code>MimeBodyPublisher</code>   if the body being tracked is itself a <code>MimeBodyPublisher</code>. This prevents \"swallowing\" the <code>MediaType</code> of such bodies.</li> <li>Upgraded Jackson to <code>2.13.2</code>.</li> <li>Upgraded Gson to <code>2.9.0</code>.</li> <li>Upgraded Reactor to <code>3.4.17</code>.</li> </ul>"},{"location":"CHANGELOG/#version-160","title":"Version 1.6.0","text":"<p>30-5-2021</p> <ul> <li>Added <code>HttpCache.Listener</code>.</li> <li>Added <code>TaggableRequest</code>. This facilitates carrying application-specific data throughout interceptors &amp; listeners.</li> </ul> <pre><code>var interceptor = Interceptor.create(request -&gt; {\nvar taggableRequest = TaggableRequest.from(request);\nvar context = taggableRequest.tag(MyContext.class).orElseGet(MyContext::empty);\n...\n});\nvar client = Methanol.newBuilder()\n.interceptor(interceptor)\n.build();\n\nvar context = ...\nvar request = MutableRequest.GET(\"https://example.com\")\n.tag(MyContext.class, context);\nvar response = client.send(request, BodyHandlers.ofString());\n</code></pre> <ul> <li>Fixed disk cache possibly manipulating the disk index concurrently. This could happen if an index   update is delayed, as the scheduler mistakenly ran the index write immediately after the delay evaluates instead   of queuing it with the sequential index executor.</li> <li>Fixed <code>TimeoutSubscriber</code> (used in <code>MoreBodySubscribers::withReadTimeout</code>) possibly calling   downstream's <code>onNext</code> &amp; <code>onError</code> concurrently. This could happen if timeout evaluates while downstream's   <code>onNext</code> is still executing.</li> <li>Made <code>AsyncBodyDecoder</code> ignore upstream signals after decoding in <code>onNext</code> fails and the error is   reported to <code>onError</code>. This prevents receiving further <code>onXXXX</code> by upstream if it doesn't immediately   detect cancellation.</li> <li>Made the disk cache catch and log <code>StoreCorruptionException</code> thrown when opening an entry. This is   done instead of rethrowing.</li> <li><code>Methanol</code> now always validates request's <code>URI</code> after being resolved with the optional base <code>URI</code>.   Previously, the <code>URI</code> was only validated if there was a base <code>URI</code>.</li> <li>Upgraded gson to 2.8.7.</li> </ul>"},{"location":"CHANGELOG/#version-150","title":"Version 1.5.0","text":"<p>14-5-2021</p> <ul> <li> <p>Methanol now has an RFC-compliant HTTP cache! It can store entries on disk or   in memory. Give it a try!   <pre><code>void cache() throws InterruptedException, IOException {\nvar cache = HttpCache.newBuilder()\n.cacheOnDisk(Path.of(\"cache-dir\"), 100 * 1024 * 1024)\n.build();\nvar client = Methanol.newBuilder()\n.cache(cache)\n.build();\n\nvar request = MutableRequest.GET(\"https://i.imgur.com/NYvl8Sy.mp4\");\nvar response = (CacheAwareResponse&lt;Path&gt;) client.send(\nrequest, BodyHandlers.ofFile(Path.of(\"banana_cat.mp4\")));\n\nSystem.out.printf(\n\"%s (CacheStatus: %s, elapsed: %s)%n\",\nresponse,\nresponse.cacheStatus(),\nDuration.between(response.timeRequestSent(), response.timeResponseReceived()));\n\ncache.close();\n}\n</code></pre></p> </li> <li> <p>Added <code>CacheControl</code> to model the <code>Cache-Control</code> header and its directives. This is complementary   to the new cache as all configuration is communicated through <code>Cache-Control</code>.</p> </li> <li>Interceptors have been reworked. The old naming convention is deprecated. An interceptor is now either    a client or a backend interceptor instead of a pre/post decoration interceptor, where 'backend' refers   to <code>Methanol</code>'s backing <code>HttpClient</code>. The cache intercepts requests after client but before backend   interceptors. It was tempting to name the latter 'network interceptors', but that seemed rather confusing   as not all 'network' requests can be intercepted (<code>HttpClient</code> can make its own intermediate requests   like redirects &amp; retries).</li> <li>Added <code>HttpStatus</code>, which contains functions for checking response codes.</li> <li>Added <code>ForwardingEncoder</code> &amp; <code>ForwardingDecoder</code>. These are meant for easier installation of adapters   from the classpath.</li> <li><code>System.Logger</code> API is now used instead of <code>java.util.logging</code>.</li> <li>Fix: Don't attempt to decompress responses to HEADs. This fixed failures like <code>unexpected end of gzip stream</code>.</li> <li>Fix: Decompressed responses now have their stale <code>Content-Encoding</code> &amp; <code>Content-Length</code> headers removed.  </li> <li>Changed reactor dependency to API scope in the <code>methanol-jackson-flux</code> adapter.</li> <li>Upgraded Jackson to 2.12.3.</li> <li>Upgraded Reactor to 3.4.6.</li> <li>New project website!</li> </ul>"},{"location":"CHANGELOG/#version-141","title":"Version 1.4.1","text":"<p>26-9-2020</p> <ul> <li>Updated dependencies.</li> <li>Fix: Autodetect if a deflated stream is zlib-wrapped or not to not crash when some servers    incorrectly send raw deflated bytes for the <code>deflate</code> encoding.</li> </ul>"},{"location":"CHANGELOG/#version-140","title":"Version 1.4.0","text":"<p>27-7-2020</p> <ul> <li>Multipart progress tracking.</li> </ul>"},{"location":"CHANGELOG/#version-130","title":"Version 1.3.0","text":"<p>22-6-2020</p> <ul> <li>Default read timeout in <code>Methanol</code> client.</li> <li>API for tracking upload/download progress.</li> <li>High-level client interceptors.</li> </ul>"},{"location":"CHANGELOG/#version-120","title":"Version 1.2.0","text":"<p>1-5-2020</p> <ul> <li>Reactive JSON adapters with Jackson and Reactor.</li> <li>Common <code>MediaType</code> constants.</li> <li>XML adapters with JAXB.</li> </ul>"},{"location":"CHANGELOG/#version-110","title":"Version 1.1.0","text":"<p>17-4-2020 </p> <ul> <li>First \"main-stream\" release.</li> </ul>"},{"location":"CHANGELOG/#version-100","title":"Version 1.0.0","text":"<p>25-3-2020</p> <ul> <li>Dummy release.</li> </ul>"},{"location":"CONTRIBUTING/","title":"Contributing","text":"<p>Contributions are welcome! It is often a good idea to first discuss changes before submitting them. If you're considering small changes (e.g. in documentation), you can open a PR directly.</p> <p>You are more than welcome to:</p> <ul> <li>Report a bug</li> <li>Ask a question</li> <li>Propose a feature</li> <li>Submit a fix</li> <li>Improve documentation</li> </ul>"},{"location":"CONTRIBUTING/#prerequisites","title":"Prerequisites","text":"<p>It is recommended to set the <code>JAVA_HOME</code> environment variable to a JDK 11 (or later) directory in order to properly work with Gradle.</p>"},{"location":"CONTRIBUTING/#building","title":"Building","text":"<p>Before submitting a change, make sure to first run tests and code analysis. </p> <p><code>./gradlew clean check -PenableErrorprone</code></p> <p>Error-prone checks are included but disabled by default for build speed. It is desirable to make errorprone happy (maybe via reasonable suppressions). Checker Framework is optionally used but mainly for informative reasons (its acts weird and crashes, patches regarding this are welcome). Similarly, it can be run with <code>enableCheckerframework</code> project property.</p> <p><code>methanol-brotli</code> uses JNI and contains a <code>c/c++</code> subproject for the brotli decoder. The native project is not included in the build by default. You can do so with project property <code>includeBrotliJni</code> or running the <code>installBrotli</code> task if you have a proper tool chain. Note that brotli isn't yet supported for macOS, so make sure to exclude brotli tests when running from a Mac:</p> <p><code>./gradlew check -PenableErrorprone -x methanol-brotli:test</code></p>"},{"location":"CONTRIBUTING/#dependencies","title":"Dependencies","text":"<p>Methanol makes it easier to use third-party libraries with the HTTP client. However, it does so  without making users pay for what they don't need. The core module currently has zero runtime  dependencies, and it is important it remains so. Features that require dependencies should be in separate modules, possibly with <code>ServideLoader</code> abstractions introduced in the core  (e.g. <code>BodyAdapter</code>,<code>BodyDecoder</code>).</p>"},{"location":"CONTRIBUTING/#style","title":"Style","text":"<p>The project mostly adheres to the Google Style Guide. Changes are expected to be consistent regarding key style aspects (2 space indentation, 4 for continuation, etc). It is preferable to use google-java-format for new code.</p>"},{"location":"benchmarks/","title":"methanol-benchmarks","text":"<p>JMH tests for Methanol's performance.</p>"},{"location":"benchmarks/#running-benchmarks","title":"Running Benchmarks","text":"<p>Benchmarks are available as a runnable Jar in Maven. You run them as following:</p> <pre><code>java -jar benchmarks-1.7.0-all.jar\n</code></pre>"},{"location":"benchmarks/#results","title":"Results","text":""},{"location":"benchmarks/#bodydecoder-vs-inputstream","title":"BodyDecoder vs InputStream","text":"<p>Compare Methanol's non-blocking decoders with available <code>InputStream</code> ones:</p> Decoder Mode Cnt Score Error Units Gzip <code>BodyDecoder</code> thrpt 5 4170.501 50.458 ops/s <code>GZIPInputStream</code> thrpt 5 4108.730 70.605 ops/s Deflate <code>BodyDecoder</code> thrpt 5 4037.943 51.947 ops/s <code>InflaterInputStream</code> thrpt 5 4035.100 162.641 ops/s Brotli <code>BodyDecoder</code> thrpt 5 4186.791 213.283 ops/s <code>BrotliInputStream</code> thrpt 5 2631.312 136.291 ops/s <p>Results show that <code>BodyDecoder</code> implementations are on par with available <code>InputStream</code> based decoders. Note that the brotli benchmark is biased as it also compares native C vs pure Java implementations.</p>"},{"location":"brotli/","title":"methanol-brotli","text":"<p>Provides brotli decompression.</p>"},{"location":"brotli/#installation","title":"Installation","text":""},{"location":"brotli/#gradle","title":"Gradle","text":"<pre><code>implementation 'com.github.mizosoft.methanol:methanol-brotli:1.7.0'\n</code></pre>"},{"location":"brotli/#maven","title":"Maven","text":"<pre><code>&lt;dependency&gt;\n&lt;groupId&gt;com.github.mizosoft.methanol&lt;/groupId&gt;\n&lt;artifactId&gt;methanol-brotli&lt;/artifactId&gt;\n&lt;version&gt;1.7.0&lt;/version&gt;\n&lt;/dependency&gt;\n</code></pre>"},{"location":"brotli/#implementation-notes","title":"Implementation notes","text":"<p>The Java brotli decoder provided by Google only exposes <code>InputStream</code> APIs. It cannot be used to implement a non-blocking <code>BodyDecoder</code>. The C implementation is used instead through JNI bindings (also provided by Google). To allow multi-platform support, native libraries for each supported OS X Architecture are bundled with the JAR and extracted to a temp directory on use.</p>"},{"location":"brotli/#supported-platforms","title":"Supported platforms","text":"OS x86 x64 Tool Chain Tested Machines Windows \u2714 \u2714 Visual C++ Windows 10 &amp; CI Linux \u2714 \u2714 GCC 9.2.1 Ubuntu 19.10 &amp; CI Mac OS \u274c \u274c"},{"location":"brotli/#building-from-source","title":"Building from source","text":"<p>You can build from source if your platform is not supported. The build routine uses Gradle's native software plugin. You need to have a tool chain that's supported by gradle for your OS.</p>"},{"location":"brotli/#steps","title":"Steps","text":"<p>After cloning this repo, run gradle with the <code>installBrotli</code> and <code>assemble</code> tasks:</p> <p><code>gradlew installBrotli :methanol-brotli:assemble</code></p> <p>This builds the native libraries and copies them to <code>src/main/resources</code> for inclusion in the JAR. You will find the assembled ready-to-use Jar in the <code>build/libs/</code> directory.</p>"},{"location":"caching/","title":"Caching","text":"<p>Methanol comes with an RFC-compliant HTTP cache that supports both disk &amp; memory storage backends.</p>"},{"location":"caching/#setup","title":"Setup","text":"<p>An <code>HttpCache</code> is utilized by injecting it into a <code>Methanol</code> client. First, it needs to know where it stores entries and how much space it can occupy.</p> DiskMemory <pre><code>// Select a size limit thats suitable for your application\nlong maxSizeInBytes = 100 * 1024 * 1024; // 100 MBs\n\nvar cache = HttpCache.newBuilder()\n.cacheOnDisk(Path.of(\"my-cache-dir\"), maxSizeInBytes)\n.build();\n\n// The cache intercepts requests you send through this client\nvar client = Methanol.newBuilder()\n.cache(cache)\n.build();\n\n// It's important that you close the disk cache after you're done\ncache.close();\n</code></pre> <pre><code>// Select a size limit thats suitable for your application\nlong maxSizeInBytes = 50 * 1024 * 1024; // 50 MBs\n\nvar cache = HttpCache.newBuilder()\n.cacheOnMemory(maxSizeInBytes)\n.build();\n\n// The cache intercepts requests you send through this client\nvar client = Methanol.newBuilder()\n.cache(cache)\n.build();\n\n// No need to close, but doing so avoids surprises if you later switch to disk\ncache.close();\n</code></pre> <p>Hint</p> <p>You can pass the builder a custom <code>Executor</code> for launching asynchronous tasks needed by the cache. By default, an unbounded thread pool of daemon threads is used.</p> <p>Caution</p> <p>To avoid surprises, make sure the disk directory is exclusively owned by a single cache instance as long as it's open and nothing else. The cache enforces that to some degree by complaining with an <code>IOException</code> if it's initialized with a directory that's already in use by another instance in the same or a different JVM. Note that you can use the same <code>HttpCache</code> with multiple clients.</p>"},{"location":"caching/#usage","title":"Usage","text":"<p>An HTTP cache is a transparent layer between you and the origin server. Its main goal is to save time &amp; bandwidth by avoiding network if requested resources are locally retrievable. It does so while preserving the typical HTTP client-server semantics. Thus, it should be OK for modules to start using a cache-configured <code>Methanol</code> (and hence <code>HttpClient</code>) instance as a drop-in replacement without further setup.</p>"},{"location":"caching/#cachecontrol","title":"CacheControl","text":"<p>Requests override default cache behaviour using <code>CacheControl</code>.</p> CacheControlCache-Control header <pre><code>// Specify your cache directives\nvar cacheControl = CacheControl.newBuilder()\n.maxAge(Duration.ofMinutes(30))\n.staleIfError(Duration.ofSeconds(60))\n.build();\n\n// Apply the directives to your request\nvar request = MutableRequest.GET(\"...\")\n.cacheControl(cacheControl);\n</code></pre> <pre><code>// Cache-Control headers work as well\nvar request = MutableRequest.GET(\"...\")\n.header(\"Cache-Control\", \"max-age=1800, stale-if-error=60\");\n</code></pre> <p>To properly use <code>CacheControl</code>, it is good to understand the key attributes of a cached response.</p>"},{"location":"caching/#age","title":"Age","text":"<p>The age of a stored response is the time it has been resident in your cache or any other cache along the route to the origin. In other words, a response's age is the time evaluated since it was last generated by the server.</p>"},{"location":"caching/#freshness","title":"Freshness","text":"<p>A fresh response is one that is servable by the cache without contacting the origin. A server specifies how long a stored response stays fresh. This is known as the response's freshness lifetime. The freshness value of a response is its age subtracted from its freshness lifetime. A response is fresh if its freshness value is <code>&gt;= 0</code>.</p> <p><code>CacheControl</code> lets you override a response's freshness lifetime by setting the <code>max-age</code> directive.</p> <pre><code>var cacheControl = CacheControl.newBuilder() .maxAge(Duration.ofSeconds(10)) // Override the lifetime set by the server, if any\n.build();\n</code></pre> <p>You can specify how fresh you'd like the response to be by putting a lower bound on its freshness value.</p> <pre><code>var cacheControl = CacheControl.newBuilder() .minFresh(Duration.ofMinutes(10)) // Accept a response that stays fresh for at least the next 10 minutes\n.build();\n</code></pre> <p>Info</p> <p>Sometimes, a response lacks an explicit freshness lifetime. As encouraged by the standard &amp; followed by browsers, Methanol uses a heuristic of 10% of the time between a response's generation &amp; last modification times in such cases.</p>"},{"location":"caching/#staleness","title":"Staleness","text":"<p>Responses with negative freshness values are said to be stale. The staleness value of a stored response is simply its freshness value negated. Normally, the cache won't serve a stale response until it's revalidated with the server. Revalidation causes the cache to ask the server, using special headers like <code>If-None-Match</code> &amp; <code>If-Modified-Since</code>, if it can serve the stale response at its disposal.  If the server doesn't mind, the cache serves said response without re-downloading its payload. Otherwise, the response is re-fetched.</p> <p>You can let the cache tolerate some stalness so it doesn't trigger revalidation.</p> Bounded StalenessArbitrary Staleness <pre><code>var cacheControl = CacheControl.newBuilder() .maxStale(Duration.ofSeconds(30)) // Allow at most 30 seconds of staleness\n.build();\n</code></pre> <pre><code>var cacheControl = CacheControl.newBuilder() .anyMaxStale() // Allow any staleness\n.build();\n</code></pre> <p><code>stale-if-error</code> makes the cache recover from network or server failures if there's a stored response. In such occasions, the cache falls back to the stored response if it satisfies the specified staleness.</p> <pre><code>var cacheControl = CacheControl.newBuilder() .staleIfError(Duration.ofSeconds(30))\n.build();\n</code></pre>"},{"location":"caching/#no-cache","title":"No Cache","text":"<p>You might want the cache to forward your request to origin even if there's a fresh stored response (e.g. refreshing a page). That's what <code>no-cache</code> is meant for.</p> <pre><code>var cacheControl = CacheControl.newBuilder() .noCache()\n.build();\n</code></pre> <p>The cache will use network efficiently. If there's a stored response, its presence is communicated to the server, so it can decide to let the cache serve said response if nothing has changed.</p>"},{"location":"caching/#only-if-cached","title":"Only If Cached","text":"<p>Use <code>only-if-cached</code> to avoid network in all cases. As usual, a stored response is served if it's suitable. Otherwise, however, the cache immediately serves a locally generated <code>504 Gateway Timeout</code> response.</p> <pre><code>var cacheControl = CacheControl.newBuilder() .onlyIfCached()\n.build();\n</code></pre> <p>A perfect use-case is when network is down or the app is offline. You'd want to get a cached response if it's there or otherwise nothing.</p>"},{"location":"caching/#prohibiting-storage","title":"Prohibiting Storage","text":"<p>Use <code>no-store</code> if you don't want the cache to store anything about the response.</p> <pre><code>var cacheControl =  CacheControl.newBuilder() .noStore()\n.build();\n</code></pre> <p>Note that this, however, doesn't prohibit the cache from serving an already stored response.</p>"},{"location":"caching/#asynchronous-revalidation","title":"Asynchronous Revalidation","text":"<p>Sometimes you need a balance between responsiveness &amp; freshness. You are willing to get a response immediately even if it's stale, but ensure it is freshened for later access. That's exactly what <code>stale-while-revalidate</code> does.</p> <p>If the directive is found on a stale response, the cache serves it immediately provided it satisfies allowed staleness. What's interesting is that an  asynchronous revalidation is triggered and the response is updated in background, keeping things fresh.</p>"},{"location":"caching/#invalidation","title":"Invalidation","text":"<p><code>HttpCache</code> has APIs that give you more control over what's stored.</p> <pre><code>var cache = HttpCache.newBuilder()\n.cacheOnDisk(Path.of(\"my-cache-dir\"), 100 * 1024 * 1024)\n.build();\n\n// Remove the entry mapped to a particular URI\ncache.remove(URI.create(\"https://i.imgur.com/NYvl8Sy.mp4\"));\n\n// Remove the response variant matching a particular request\ncache.remove(\nMutableRequest.GET(URI.create(\"https://i.imgur.com/NYvl8Sy.mp4\"))\n.header(\"Accept-Encoding\", \"gzip\"));\n\n// Remove specific entries by examining their URIs\nvar iterator = cache.uris();\nwhile (iterator.hasNext()) {\nvar uri = iterator.next();  if (uri.getHost().equals(\"i.imgur.com\")) {\niterator.remove();  }\n}\n\n// Remove all entries\ncache.clear();\n\n// Dispose of the cache by deleting its entries then closing it in an atomic fashion.\n// The cache is rendered unusable after this call. This is meant for applications that\n// use a temporary directory for caching in case persistence isn't needed.\ncache.dispose();\n</code></pre>"},{"location":"caching/#cache-operation-statistics","title":"Cache Operation &amp; Statistics","text":"<p>Cache operation typically involves 3 scenarios.</p> <ul> <li>Cache Hit: The blessed scenario; everything was entirely served from cache and no network was    used.</li> <li>Conditional Cache Hit: The cache had to contact the origin to revalidate its copy of the    response and the server decided it was valid. The cache uses server's response to update some     metadata in background. Response payload isn't downloaded so network is used efficiently.</li> <li>Cache Miss: Either the cache had no matching response or the server decided such response is    too stale to be server. In both cases, the whole response is fetched from network.    This is when the cache populates or updates its entries if appropriate.</li> </ul>"},{"location":"caching/#cacheawareresponse","title":"CacheAwareResponse","text":"<p><code>CacheAwareResponse</code> complements <code>HttpResponse</code> to better reflect cache interference. If a cache is installed, any <code>HttpResponse&lt;T&gt;</code> returned by <code>Methanol</code> is also a <code>CacheAwareResponse&lt;T&gt;</code>, which you can use to know which of the previous scenarios was the case.</p> <pre><code>var cache = HttpCache.newBuilder()\n.cacheOnDisk(Path.of(\"my-cache-dir\"), 100 * 1024 * 1024)\n.build();\nvar client = Methanol.newBuilder()\n.cache(cache)\n.build();\n\nvar response = (CacheAwareResponse&lt;Path&gt;) client.send(\nMutableRequest.GET(\"https://i.imgur.com/NYvl8Sy.mp4\"), BodyHandlers.ofFile(Path.of(\"banana_cat.mp4\")));\n\nvar timeElapsed  = Duration.between(response.timeRequestSent(), response.timeResponseReceived());\nSystem.out.println(\"Time elapsed: \" + timeElapsed);\n\n// networkResponse &amp; cacheResponse are optional HttpResponses that you can further investigate\nvar networkResponse = response.networkResponse();\nvar cacheResponse = response.cacheResponse();\nswitch (response.cacheStatus()) {\ncase HIT:\nassert networkResponse.isEmpty();\nassert cacheResponse.isPresent();\nbreak;\n\ncase CONDITIONAL_HIT:\nassert networkResponse.isPresent();\nassert cacheResponse.isPresent();\nbreak;\n\ncase MISS:\nassert networkResponse.isPresent();\n// cacheResponse can be absent or present\nbreak;\n\ncase UNSATISFIABLE:\n// Network was forbidden by only-if-cached but there was no valid cache response\nassert response.statusCode() == HttpURLConnection.HTTP_GATEWAY_TIMEOUT;\nassert networkResponse.isEmpty();\n// cacheResponse can be absent or present\nbreak;\n}\n\ncache.close();\n</code></pre>"},{"location":"caching/#httpcachestats","title":"HttpCache.Stats","text":"<p>You can examine cache statistics to measure its effectiveness. Statistics are either global or correspond to a specific <code>URI</code>.</p> Global StatsURI-specific Stats <pre><code>var cache = HttpCache.newBuilder()\n.cacheOnDisk(Path.of(\"my-cache-dir\"), 100 * 1024 * 1024)\n.build();\n\nvar stats = cache.stats();\nSystem.out.println(stats.hitRate());\nSystem.out.println(stats.missRate());\n</code></pre> <pre><code>// Per URI statistics aren't recorder by default\nvar cache = HttpCache.newBuilder()\n.cacheOnDisk(Path.of(\"my-cache-dir\"), 100 * 1024 * 1024)\n.statsRecorder(StatsRecorder.createConcurrentPerUriRecorder())\n.build();\n\nvar stats = cache.stats(URI.create(\"https://i.imgur.com/NYvl8Sy.mp4\"));\nSystem.out.println(stats.hitRate());\nSystem.out.println(stats.missRate());\n</code></pre> <p>See <code>HttpCache.Stats</code> for all recorded statistics.</p>"},{"location":"caching/#limitations","title":"Limitations","text":"<ul> <li>The cache only stores responses to GETs. This is typical for most caches.</li> <li>The cache never stores partial responses.  </li> <li>Only the most recent response variant can be stored.</li> <li>The cache doesn't store responses that have a <code>Vary</code> header with any of the values: <code>Cookie</code>,    <code>Cookie2</code>, <code>Authorization</code>, <code>Proxy-Authroization</code>. That's because the <code>HttpClient</code> can implicitly   add these to requests, so Methanol won't be able to access their values to match responses against.</li> </ul>"},{"location":"decompression/","title":"Response Decompression","text":"<p>One caveat concerning Java's HTTP client is the lack of support for automatic response decompression. A workaround is to use an available <code>InputStream</code> decompressor (e.g. <code>GZIPInputStream</code>) that matches response's <code>Content-Encoding</code>. However, such approach is invasive as it forces us to deal with <code>InputStreams</code>.</p> <p>The straightforward and recommended solution is to use Methanol's enhanced HTTP client, which gives you transparent response decompression for <code>gzip</code> &amp; <code>deflate</code> out of the box.</p> <pre><code>final Methanol client = Methanol.create();\n\n&lt;T&gt; HttpResponse&lt;T&gt; get(String url, BodyHandler&lt;T&gt; bodyHandler) throws IOException, InterruptedException {\n// No need to worry about adding Accept-Encoding and\n// decompressing the response. The client does that for you!\nreturn client.send(MutableRequest.GET(url), bodyHandler);\n}\n</code></pre> <p>Read on if you're interested in knowing how that's accomplished or you want to extend decompression support.</p>"},{"location":"decompression/#decoding-bodyhandler","title":"Decoding BodyHandler","text":"<p>The entry point to response body decompression is <code>MoreBodyHandlers::decoding</code>. This method takes your desired <code>BodyHandler</code> and gives you one that decompresses the response body as your handler's <code>BodySubscriber</code> receives it.</p> <pre><code>var response = client.send(request, MoreBodyHandlers.decoding(BodyHandlers.ofString()));\n</code></pre> <p>Note that it doesn't matter which <code>BodyHandler</code> you're using; you can have whatever response body type you want.</p>"},{"location":"decompression/#bodydecoder","title":"BodyDecoder","text":"<p>A <code>BodyDecoder</code> is a <code>BodySubscriber</code> with the added semantics of a <code>Flow.Processor</code>. It intercepts the flow of bytes on its way down from the HTTP client, decoding each <code>List&lt;ByteBuffer&gt;</code> individually. The decoded bytes are forwarded to a downstream <code>BodySubscriber</code>, which converts them into the desired response body.</p> <p>A <code>BodyDecoder.Factory</code> associates itself with a defined encoding that's suitable as a <code>Content-Encoding</code> directive. Given a downstream <code>BodySubscriber</code>, the factory creates a <code>BodyDecoder</code> that forwards the response body after decoding it using the factory's encoding. For instance, a factory associated with <code>gzip</code> creates decoders that decompress the response using the gzip format.</p>"},{"location":"decompression/#factory-lookup","title":"Factory Lookup","text":"<p>Factories are installed as service-providers in the manner specified by Java's <code>ServiceLoader</code>. A decoding <code>BodyHandler</code> looks up a factory associated with response's <code>Content-Encoding</code>. If found, it's called to wrap user's <code>BodySubscriber</code>, so it receives the decompressed body. Otherwise, an <code>UnsupportedOperationException</code> is thrown.</p>"},{"location":"decompression/#supported-encodings","title":"Supported Encodings","text":"<p>The core module has support for <code>gzip</code> &amp; <code>deflate</code> out of the box. There's also a separate module providing support for brotli.</p>"},{"location":"decompression/#extending-decompression-support","title":"Extending decompression support","text":"<p>Adding support for more encodings or overriding supported ones is a matter of writing a <code>BodyDecoder</code> implementation and providing a corresponding factory. However, implementing the decoder's <code>Flow.Publisher</code> semantics can be tricky. Instead, implement an <code>AsyncDecoder</code> and wrap it in an <code>AsyncBodyDecoder</code>, so you're only concerned with your decompression logic.</p>"},{"location":"decompression/#writing-an-asyncdecoder","title":"Writing an AsyncDecoder","text":"<p>Decoding is done as a number of <code>decode(source, sink)</code> rounds finalized by one final round, each with the currently available input. After the final round, your <code>AsyncDecoder</code> must've completely exhausted its source. Here's a decoder implementation that uses jzlib for <code>gzip</code> &amp; <code>deflate</code> decompression.</p> <pre><code>class JZlibDecoder implements AsyncDecoder {\nprivate static final int BUFFER_SIZE = 8096;\n\nprivate final String encoding;\nprivate final com.jcraft.jzlib.Inflater inflater;\nprivate final ByteBuffer input = ByteBuffer.allocate(BUFFER_SIZE);\nprivate final ByteBuffer output = ByteBuffer.allocate(BUFFER_SIZE);\n\nJZlibDecoder(String encoding, com.jcraft.jzlib.JZlib.WrapperType wrapperType) {\ntry {\nthis.encoding = encoding;\ninflater = new com.jcraft.jzlib.Inflater(wrapperType);\ninflater.setInput(input.array());\ninflater.setOutput(output.array());\n} catch (com.jcraft.jzlib.GZIPException e) {\nthrow new RuntimeException(e);\n}\n}\n\n@Override\npublic String encoding() {\nreturn encoding;\n}\n\n@Override\npublic void decode(ByteSource source, ByteSink sink) throws IOException {\nsynchronized (inflater) {\nwhile (source.hasRemaining()) {\n// Prepare input for this iteration\nrefillInput(source);\ninflater.setNextInIndex(0);\ninflater.setAvailIn(input.limit());\n\n// Continue inflating as long as there's more input or there's pending output\n\nboolean mightHavePendingOutput = false;\n\ninflateLoop:\nwhile (inflater.getAvailIn() &gt; 0 || mightHavePendingOutput) {\n// Prepare for new output\ninflater.setNextOutIndex(0);\ninflater.setAvailOut(output.capacity());\n\nint status = inflater.inflate(com.jcraft.jzlib.JZlib.Z_SYNC_FLUSH);\nint outputCount = inflater.getNextOutIndex();\nsink.pushBytes(output.position(0).limit(outputCount));\n\nswitch (status) {\ncase com.jcraft.jzlib.JZlib.Z_OK:\nmightHavePendingOutput = inflater.getAvailOut() == 0;\nbreak;\n\ncase com.jcraft.jzlib.JZlib.Z_STREAM_END:\n// The compressed stream has ended\nbreak inflateLoop;\n\ndefault:\nthrow new IOException(\"problem with zlib: \" + Integer.toHexString(status));\n}\n}\n}\n}\n}\n\nprivate void refillInput(ByteSource source) {\ninput.clear();\nsource.pullBytes(input);\ninput.flip();\n}\n\n@Override\npublic synchronized void close() {\nsynchronized (inflater) {\ninflater.end();\n}\n}\n}\n</code></pre>"},{"location":"decompression/#registering-a-factory","title":"Registering a Factory","text":"<p>Here's a <code>BodyDecoder.Factory</code> for <code>gzip</code> using our jzlib decoder.</p> <pre><code>public static final class MyDecoderFactory implements BodyDecoder.Factory {\n@Override\npublic String encoding() {\nreturn \"gzip\";\n}\n\n@Override\npublic &lt;T&gt; BodyDecoder&lt;T&gt; create(BodySubscriber&lt;T&gt; downstream) {\nreturn new AsyncBodyDecoder&lt;&gt;(\nnew JZlibDecoder(\"gzip\", com.jcraft.jzlib.JZlib.WrapperType.GZIP), downstream);\n}\n\n@Override\npublic &lt;T&gt; BodyDecoder&lt;T&gt; create(BodySubscriber&lt;T&gt; downstream, Executor executor) {\nreturn new AsyncBodyDecoder&lt;&gt;(\nnew JZlibDecoder(\"gzip\", com.jcraft.jzlib.JZlib.WrapperType.GZIP), downstream);\n}\n}\n</code></pre> <p>The next step is to declare your factory as a service-provider. For instance, here's an appropriate <code>provides...with</code> declaration to put in <code>module-info.java</code> if your application uses Java modules.</p> <pre><code>module my.module {\n...\n\nprovides BodyDecoder.Factory with MyDecoderFactory;\n}\n</code></pre>"},{"location":"enhanced_httpclient/","title":"Enhanced HttpClient","text":"<p>Methanol has a special <code>HttpClient</code> that extends the standard one with interesting new features. Unsurprisingly, the client is named <code>Methanol</code>.</p>"},{"location":"enhanced_httpclient/#usage","title":"Usage","text":"<p>In addition to interceptors and caching, <code>Methanol</code> can apply default properties to your requests. Think resolving with a base URI, adding default request headers, default timeouts, etc.</p> <pre><code>var builder = Methanol.newBuilder()\n.cache(...)\n.interceptor(...)\n.userAgent(\"Will Smith\")                     // Custom User-Agent\n.baseUri(\"https://api.github.com\")           // Base URI to resolve requests' URI against\n.defaultHeader(\"Accept\", \"application/json\") // Default request headers\n.requestTimeout(Duration.ofSeconds(20))      // Default request timeout\n.headersTimeout(Duration.ofSeconds(5))       // Timeout for receiving response headers\n.readTimeout(Duration.ofSeconds(5))          // Timeout for single reads\n.autoAcceptEncoding(true);                   // Transparent response compression, this is true by default\n\n// Continue using as a standard HttpClient.Builder!\nvar client = builder.executor(...)\n.executor(Executors.newFixedThreadPool(16))\n.connectTimeout(Duration.ofSeconds(30))\n...\n.build();\n</code></pre> <p>You can also build from an existing <code>HttpClient</code> instance. However, you can't install an <code>HttpCache</code> in such case.</p> <pre><code>HttpClient prebuiltClient = ...\nvar client = Methanol.newBuilder(prebuiltClient)\n.interceptor(...)\n.userAgent(\"Will Smith\")\n...\n.build();\n</code></pre> <p>Tip</p> <p><code>Methanol</code> is an <code>HttpClient</code>. It implements the same API like <code>send</code> &amp; <code>sendAsync</code>, which you can continue using as usual.</p> <p>Note</p> <p>Default properties don't override those the request already has. For instance, a client with a default <code>Accept: text/html</code> will not override a request's <code>Accept: application/json</code>.</p>"},{"location":"enhanced_httpclient/#transparent-compression","title":"Transparent Compression","text":"<p>If <code>autoAcceptEncoding</code> is enabled, the client complements requests with an <code>Accept-Encoding</code> header which accepts all supported encodings (i.e. available <code>BodyDecoder</code> providers). Additionally, the response is transparently decompressed according to its <code>Content-Encoding</code>.</p> <p>Since <code>deflate</code> &amp; <code>gzip</code> are supported out of the box, they're always included in <code>Accept-Encoding</code>. For instance, if brotli is installed, requests will typically have: <code>Accept-Encoding: deflate, gzip, br</code>. If you want specific encodings to be applied, add <code>Accept-Encoding</code> as a default header or explicitly set one in your request.</p> Default HeaderRequest Header <pre><code>// Advertise brotli decompression\nvar client = Methanol.newBuilder()\n.defaultHeader(\"Accept-Encoding\", \"br\")\n.build();\n</code></pre> <pre><code>// Advertise brotli decompression\nvar request = MutableRequest.GET(uri)\n.header(\"Accept-Encoding\", \"br\");\n</code></pre>"},{"location":"enhanced_httpclient/#mimebodypublisher","title":"MimeBodyPublisher","text":"<p><code>Methanol</code> automatically sets a request's <code>Content-Type</code> if it has a <code>MimeBodyPublisher</code>. If the request already has a <code>Content-Type</code>, it's overwritten. This makes sense as a body knows its media type better than a containing request mistakenly setting a different one.</p>"},{"location":"enhanced_httpclient/#reactive-dispatching","title":"Reactive Dispatching","text":"<p>If you like reactive streams, use <code>Methanol::exchange</code>, which is like <code>sendAsync</code> but returns <code>Publisher&lt;HttpResponse&lt;T&gt;&gt;</code> sources instead.</p> Without HTTP/2 PushWith HTTP/2 Push <pre><code>var client = Methanol.create();\n\nvar request = MutableRequest.GET(\"https://http2-push.appspot.com/?nopush\");\nvar publisher = client.exchange(request, BodyHandlers.ofFile(Path.of(\"page.html\")));\n\nJdkFlowAdapter.flowPublisherToFlux(publisher)\n.doOnNext(response -&gt; System.out.printf(\"%s: %s\", response, response.body()))\n.blockLast();\n</code></pre> <pre><code>var client = Methanol.create();\n\nvar request = MutableRequest.GET(\"https://http2-push.appspot.com\");\nvar publisher = client.exchange(\nrequest, BodyHandlers.ofFile(Path.of(\"page.html\")), pushPromise -&gt; BodyHandlers.ofFile(Path.of(pushPromise.uri().getPath()).getFileName()));\n\nJdkFlowAdapter.flowPublisherToFlux(publisher)\n.doOnNext(response -&gt; System.out.printf(\"%s: %s%n\", response, response.body()))\n.blockLast();\n</code></pre>"},{"location":"enhanced_httpclient/#mutablerequest","title":"MutableRequest","text":"<p><code>MutableRequest</code> is an <code>HttpRequest</code> that implements <code>HttpRequest.Builder</code> for settings request's properties. This drops immutability in favor of some convenience when the request is sent immediately.</p> <pre><code>var response = client.send(MutableReqeust.GET(uri), BodyHandlers.ofString());\n</code></pre> <p>Additionally, <code>MutableRequest</code> accepts relative URIs (standard <code>HttpRequest.Builder</code> doesn't). This is a complementing feature to <code>Methanol</code>'s base URIs, against which relative ones are resolved.</p> <p>Tip</p> <p>You can use <code>MutableRequest::toImmutableRequest</code> to get an immutable <code>HttpRequest</code> snapshot.</p>"},{"location":"interceptors/","title":"Interceptors","text":"<p>Interceptors allow you to inspect, mutate, retry and short-circuit HTTP calls. Together, interceptors build an invocation chain that's capable of applying powerful transformations to requests moving forward and to responses in their way back.</p>"},{"location":"interceptors/#writing-interceptors","title":"Writing Interceptors","text":"<p>Interceptors sit between a <code>Methanol</code> client and its underlying <code>HttpClient</code>, referred to as its backend. When registered, an interceptor is invoked each <code>send</code> or <code>sendAsync</code> call. Here's an interceptor that logs requests and their responses.</p> <pre><code>public final class LoggingInterceptor implements Methanol.Interceptor {\nprivate static final Logger logger = Logger.getLogger(LoggingInterceptor.class.getName());\n\n@Override\npublic &lt;T&gt; HttpResponse&lt;T&gt; intercept(HttpRequest request, Chain&lt;T&gt; chain)\nthrows IOException, InterruptedException {\nlogRequest(request);\nreturn toLoggingChain(request, chain).forward(request);\n}\n\n@Override\npublic &lt;T&gt; CompletableFuture&lt;HttpResponse&lt;T&gt;&gt; interceptAsync(\nHttpRequest request, Chain&lt;T&gt; chain) {\nlogRequest(request);\nreturn toLoggingChain(request, chain).forwardAsync(request);\n}\n\nprivate static void logRequest(HttpRequest request) {\nlogger.info(() -&gt; String.format(\"Sending %s%n%s\", request, headersToString(request.headers())));\n}\n\nprivate static &lt;T&gt; Chain&lt;T&gt; toLoggingChain(HttpRequest request, Chain&lt;T&gt; chain) {\nvar sentAt = Instant.now();\nreturn chain.withBodyHandler(responseInfo -&gt; {\nlogger.info(() -&gt; String.format(\n\"Completed %s %s with %d in %sms%n%s\",\nrequest.method(),\nrequest.uri(),\nresponseInfo.statusCode(),\nDuration.between(sentAt, Instant.now()).toMillis(),\nheadersToString(responseInfo.headers())));\n\n// Apply the original BodyHandler\nreturn chain.bodyHandler().apply(responseInfo);\n});\n}\n\nprivate static String headersToString(HttpHeaders headers) {\nreturn headers.map().entrySet().stream()\n.map(entry -&gt; entry.getKey() + \": \" + String.join(\", \", entry.getValue()))\n.collect(Collectors.joining(System.lineSeparator()));\n}\n}\n</code></pre> <p><code>HttpClient</code> has blocking and asynchronous APIs, so interceptors must implement two methods matching each. An interceptor is given a <code>Chain&lt;T&gt;</code> so it can forward requests to  its next sibling, or to the backend in case there's no more interceptors in the chain. The backend is where requests finally get sent. Typically, an interceptor calls its chain's <code>forward</code> or <code>forwardAsync</code> after it has done its job.</p> <p>If your interceptor only modifies requests, prefer passing a lambda to <code>Interceptor::create</code>.</p> <pre><code>// Enable 'Expect: Continue' for all POSTs to a particular host\nvar expectContinueInterceptor = Interceptor.create(request -&gt;\nrequest.method().equalsIgnoreCase(\"POST\") &amp;&amp; request.uri().getHost().equals(\"api.imgur.com\")\n? MutableRequest.copyOf(request).expectContinue(true)\n: request);\n</code></pre>"},{"location":"interceptors/#intercepting-bodies","title":"Intercepting Bodies","text":"<p>A powerful property of interceptors is their control over how responses are received by their caller. An interceptor can transform its chain's <code>BodyHandler</code> using <code>Chain::withBodyHandler</code> before it forwards requests. A transformed <code>BodyHandler</code> typically applies the handler the chain previously had, then wraps the resulted <code>BodySubscriber</code>, so it intercepts the response body as it's being received by the caller. This is how <code>Methanol</code> does transparent decompression &amp; cache writes.</p> <p>Note that this applies to requests too. You can transform a request body by wrapping its  <code>BodyPublisher</code>, if it's got any. <code>BodyPublisher</code> &amp; <code>BodySubscriber</code> APIs can be nicely layered to apply different transformations.</p>"},{"location":"interceptors/#invocation-order","title":"Invocation Order","text":"<p>An interceptor can be either a client or a backend interceptor. Client interceptors sit between the application and <code>Methanol</code>'s internal interceptors. They are called as soon as the client receives a request. Backend interceptors sit between <code>Methanol</code> and its backend <code>HttpClient</code>. They get invoked right before the request gets sent. This has a number of implications.</p>"},{"location":"interceptors/#client-interceptors","title":"Client Interceptors","text":"<ul> <li>See the request just as received from the application.</li> <li>Their transformed <code>BodyHandler</code> receives the response body after the client applies its    decompressing &amp; cache writing handlers.</li> </ul>"},{"location":"interceptors/#backend-interceptors","title":"Backend Interceptors","text":"<ul> <li>Observe the request after the client applies things like the base URI and default   headers. Additionally, they see   intermediate headers added by the client or the cache like <code>Accept-Encoding</code> &amp; <code>If-None-Math</code>.</li> <li>Receive the response body just as transmitted by the backend. For instance, a transformed   <code>BodyHandler</code> receives a compressed body if the response comes with a <code>Content-Encoding</code> header.</li> <li>May not always be invoked. This is the case when a cache decides it doesn't need network and hence   doesn't proceed the call to the backend.</li> </ul> <p>Attention</p> <p>If a cache is installed, <code>Methanol</code> does automatic redirection by itself, which would otherwise be done by the backend. This allows redirects to be cached, increasing cache efficiency. As a consequence, backend interceptors may get invoked more than once in the presence of a cache.</p>"},{"location":"interceptors/#registration","title":"Registration","text":"<p>You can register client and backend interceptors with <code>interceptor(...)</code> and <code>backendInterceptor(...)</code> respectively. Interceptors in each group get invoked in registration order.</p> Client InterceptorsBackend Interceptors <pre><code>var client = Methanol.newBuilder()\n.interceptor(new LoggingInterceptor())\n.build();\n</code></pre> <pre><code>var client = Methanol.newBuilder()\n.backendInterceptor(new LoggingInterceptor())\n.build();\n</code></pre>"},{"location":"interceptors/#short-circuiting","title":"Short-circuiting","text":"<p>Both client &amp; backend interceptors can refrain from forwarding a request. They're allowed to short-circuit a request's path by returning a fabricated response. This makes them good candidates for testing. You can mock responses with client interceptors to investigate requests just as sent by your application. Moreover, responses can be mocked with backend interceptors to explore requests as they get sent. This makes backend interceptors suitable for testing how your application interacts with the cache.</p>"},{"location":"interceptors/#limitations","title":"Limitations","text":"<p>Remember that <code>Methanol</code> is built atop a standard <code>HttpClient</code>, which can perform its own redirects, retries and other intermediate requests like authentications. These aren't interceptable. That's because <code>HttpClient</code> exports no API to do so.</p>"},{"location":"interruptible_reading/","title":"Interruptible Reading","text":"<p>Reading from blocking sources like <code>InputStream</code> isn't always avoidable. Once they're needed, JDK's <code>BodyHandlers::ofInputStream</code> can be used. However, reading from such stream blocks your threads indefinitely, which causes troubles when you want to close the application or change contexts amid reading. Methanol has support for interruptible channels. These are asynchronously closeable and respond to thread interrupts. Using them, you can voluntarily halt reading operations when they're not relevant anymore.</p> <p><code>MoreBodySubscibers</code> has interruptible <code>ReadableByteChannel</code> and <code>Reader</code> implementations. Use JDK's <code>Channels::newInputStream</code> to get an <code>InputStream</code> from an interruptible <code>ReadableByteChannel</code> when input streams is what you need.</p>"},{"location":"interruptible_reading/#example-interruptible-body-processing","title":"Example - Interruptible Body Processing","text":"<p>Here's an example of a hypothetical component that processes the response from a <code>ReadableByteChannel</code>. When the task is to be discarded, reader threads are interrupted by shutting down the owning <code>ExecutorService</code>. This closes open channels and instructs them to halt blocking reads.</p> <pre><code>class BodyProcessor {\nfinal ExecutorService executorService = Executors.newCachedThreadPool();\nfinal Methanol client = Methanol.create();\n\nCompletableFuture&lt;Void&gt; processAsync(HttpRequest request, Consumer&lt;ByteBuffer&gt; processAction) {\nreturn client.sendAsync(request, MoreBodyHandlers.ofByteChannel())\n.thenApplyAsync(res -&gt; {\nvar buffer = ByteBuffer.allocate(8 * 1024);\ntry (var channel = res.body()) {\nwhile (channel.read(buffer.clear()) &gt;= 0) {\nprocessAction.accept(buffer.flip());\n}\n} catch (ClosedByInterruptException | ClosedChannelException ignored) {\n// The thread was interrupted due to ExecutorService shutdown\n} catch (IOException e) {\nthrow new UncheckedIOException(e);\n}\nreturn null;\n}, executorService);\n}\n\nvoid terminate() { executorService.shutdownNow(); }\n}\n</code></pre>"},{"location":"media_types/","title":"Mime","text":"<p>Media types are the web's notion for file extensions. They're typically present in requests and responses as <code>Content-Type</code> directives. Methanol's <code>MediaType</code> greatly facilitates the representation and manipulation of media types.</p>"},{"location":"media_types/#mediatype","title":"MediaType","text":"<p>You can create a <code>MediaType</code> from its individual components or parse one from a <code>Content-Type</code> string.</p> MediaType::ofMediaType::parse <pre><code>var applicationJsonUtf8 = MediaType.of(\"application\", \"json\", Map.of(\"charset\", \"UTF-8\")); assertEquals(\"application\", applicationJsonUtf8.type());\nassertEquals(\"json\", applicationJsonUtf8.subtype());\nassertEquals(\"utf-8\", applicationJsonUtf8.parameters().get(\"charset\"));\nassertEquals(Optional.of(StandardCharsets.UTF_8), applicationJsonUtf8.charset());\n</code></pre> <pre><code>var applicationJsonUtf8 = MediaType.parse(\"application/json; charset=UTF-8\");\n\nassertEquals(\"application\", applicationJsonUtf8.type());\nassertEquals(\"json\", applicationJsonUtf8.subtype());\nassertEquals(\"utf-8\", applicationJsonUtf8.parameters().get(\"charset\"));\nassertEquals(Optional.of(StandardCharsets.UTF_8), applicationJsonUtf8.charset());\n</code></pre>"},{"location":"media_types/#media-ranges","title":"Media Ranges","text":"<p>A <code>MediaType</code> also defines a media range to which one or more media types belong, including itself.</p> <pre><code>var anyTextType = MediaType.parse(\"text/*\");\nvar textHtml = MediaType.parse(\"text/html\");\nvar applicationJson = MediaType.parse(\"application/json\");\n\nassertTrue(anyTextType.hasWildcard());\nassertTrue(anyTextType.includes(textHtml));\nassertFalse(anyTextType.includes(applicationJson));\nassertTrue(anyTextType.isCompatibleWith(textHtml));\nassertTrue(textHtml.isCompatibleWith(anyTextType));\n</code></pre> <p>Tip</p> <p><code>MediaType</code> has static definitions for the most popular media types &amp; ranges. None of them, however, defines a <code>charset</code> parameter. You can use <code>MediaType::withCharset</code> to derive media types with charsets from the statically defined ones.</p> <pre><code>static final MediaType APPLICATION_JSON_UTF8 = MediaType.APPLICATION_JSON.withCharset(StandardCharsets.UTF_8);\n</code></pre>"},{"location":"media_types/#mimebodypublisher","title":"MimeBodyPublisher","text":"<p><code>MimeBodyPublisher</code> is a mixin-style interface that associates a <code>MediaType</code> with a <code>BodyPublisher</code>.  It's recognized by <code>Methanol</code> and multipart bodies in that it gets the appropriate <code>Content-Type</code> header implicitly added.</p> <p>You can adapt an arbitrary <code>BodyPublisher</code> into a <code>MimeBodyPublisher</code>. Here's a factory method that creates <code>MimeBodyPublihers</code> for files. The file's media type is probed from the system, falling back to <code>application/octet-stream</code> if that doesn't work. </p> <pre><code>static MimeBodyPublisher ofMimeFile(Path file) throws FileNotFoundException {\nMediaType mediaType = null;\ntry {\nvar contentType = Files.probeContentType(file);\nif (contentType != null) {\nmediaType = MediaType.parse(contentType);\n}\n} catch (IOException ignored) {\n}\n\nreturn MoreBodyPublishers.ofMediaType(\nBodyPublishers.ofFile(file),\nrequireNonNullElse(mediaType, MediaType.APPLICATION_OCTET_STREAM));\n}\n\nfinal Methanol client = Methanol.create();\n\n&lt;T&gt; HttpResponse&lt;T&gt; post(String url, Path file, BodyHandler&lt;T&gt; handler)\nthrows IOException, InterruptedException {\n\n// Request's Content-Type is implicitly added\nreturn client.send(MutableRequest.POST(url, ofMimeFile(file)), handler);\n}\n</code></pre>"},{"location":"multipart_and_forms/","title":"Multipart &amp; Forms","text":"<p>Methanol has special <code>BodyPublisher</code> implementations for multipart uploads &amp; form submission.</p>"},{"location":"multipart_and_forms/#multipart-bodies","title":"Multipart Bodies","text":"<p><code>MultipartBodyPublisher</code> implements the flexible multipart format. A multipart body has one or more parts. Each part has a <code>BodyPublisher</code> for its content and <code>HttpHeaders</code> that describe it. <code>MultipartBodyPublisher.Builder</code>defaults to <code>multipart/form-data</code> if a multipart <code>MediaType</code> isn't explicitly specified. There're special methods for adding parts with a <code>Content-Disposition: form-data</code> header generated from a field name and an optional file name. These are referred to as form parts. </p> <pre><code>// Substitute with your client ID. Visit https://api.imgur.com/oauth2/addclient to get one.\nstatic final String CLIENT_ID = System.getenv(\"IMGUR_CLIENT_ID\"); final Methanol client = Methanol.create();\n\nHttpResponse&lt;String&gt; uploadGif() throws IOException, InterruptedException {\nvar multipartBody = MultipartBodyPublisher.newBuilder()\n.textPart(\"title\", \"Dancing stick bug\")\n.filePart(\"image\", Path.of(\"dancing-stick-bug.gif\"), MediaType.IMAGE_GIF)\n.build();\nvar request = MutableRequest.POST(\"https://api.imgur.com/3/image\", multipartBody)\n.header(\"Authorization\", \"Client-ID \" + CLIENT_ID); return client.send(request, BodyHandlers.ofString());\n}\n</code></pre> <p>If <code>filePart</code> isn't given a <code>MediaType</code>, it asks the system for one using the given <code>Path</code>, falling back to <code>application/octet-stream</code> if that doesn't work.</p> <p>Hint</p> <p>A part's <code>Content-Type</code> is automatically added if it's created with a <code>MimeBodyPublisher</code>.</p>"},{"location":"multipart_and_forms/#generic-form-parts","title":"Generic Form Parts","text":"<p>Use builder's <code>formPart</code> method to add a form part from an arbitrary <code>BodyPublisher</code>. It takes a field name and an optional file name.</p> <pre><code>// Substitute with your client ID. Visit https://api.imgur.com/oauth2/addclient to get one\nstatic final String CLIENT_ID = System.getenv(\"IMGUR_CLIENT_ID\"); final Methanol client = Methanol.create();\n\nHttpResponse&lt;String&gt; uploadPng(String title, InputStream pngImageInputStream)\nthrows IOException, InterruptedException {\nvar imagePart = MoreBodyPublishers.ofMediaType(\nBodyPublishers.ofInputStream(() -&gt; pngImageInputStream), MediaType.IMAGE_PNG);\nvar multipartBody = MultipartBodyPublisher.newBuilder()\n.textPart(\"title\", title)\n.formPart(\n\"image\", title + \".png\", MoreBodyPublishers.ofMediaType(imagePart, MediaType.IMAGE_PNG))\n.build();\nvar request = MutableRequest.POST(\"https://api.imgur.com/3/image\", multipartBody)\n.header(\"Authorization\", \"Client-ID \" + CLIENT_ID); return client.send(request, BodyHandlers.ofString());\n}\n</code></pre> <p>Tip</p> <p>You can use <code>formPart</code> to add a file part from something that's not a <code>Path</code> (e.g. <code>InputStream</code>) or to override the part's <code>filename</code> property, which is not possible with <code>filePart</code>.</p> <p>Tip</p> <p>Use <code>MoreBodyPublishers::ofMediaType</code> to pair an arbitrary <code>BodyPublisher</code> with its proper <code>MediaType</code> if you want a <code>Content-Type</code> header to be specified by the part.</p>"},{"location":"multipart_and_forms/#form-bodies","title":"Form Bodies","text":"<p>Use <code>FormBodyPublisher</code> to send form data as a set of URL-encoded queries. Data is added as string name-value pairs.</p> <pre><code>final Methanol client = Methanol.create();\n\nHttpResponse&lt;String&gt; sendQueries(String url, Map&lt;String, String&gt; queries)\nthrows IOException, InterruptedException {\nvar builder = FormBodyPublisher.newBuilder();\nqueries.forEach(builder::query);\n\nvar formBody = builder.build();\nvar request = MutableRequest.POST(url, formBody);\n\nreturn client.send(request, BodyHandlers.ofString());\n}\n</code></pre> <p>Hint</p> <p>Requests with <code>MultipartBodyPublisher</code> or <code>FormBodyPublisher</code> will have their <code>Content-Type</code> header added automatically if sent on a <code>Methanol</code> client.</p>"},{"location":"object_mapping/","title":"Object Mapping","text":"<p>HTTP bodies are often mappable to high-level entities that your code understands. Java's HttpClient was designed with that in mind. However, available <code>BodyPublisher</code> &amp; <code>BodySubscriber</code> implementations are too basic, and implementing your own can be tricky. Methanol builds upon these APIs with an extensible and easy-to-use object mapping mechanism that treats your objects as first-citizen HTTP bodies.</p>"},{"location":"object_mapping/#setup","title":"Setup","text":"<p>Before sending and receiving objects over HTTP, Methanol needs to adapt to your desired mapping schemes. Adapters for the most popular serialization libraries are provided in separate modules.</p> <ul> <li><code>methanol-gson</code>: JSON with Gson</li> <li><code>methanol-jackson</code>: JSON with Jackson (but also XML, protocol buffers and other formats support by Jackson)</li> <li><code>methanol-jackson-flux</code>: Reactive JSON with Jackson and Reactor</li> <li><code>methanol-jaxb</code>: XML with JAXB</li> <li><code>methanol-protobuf</code>: Google's Protocol Buffers</li> </ul> <p>Adapters are dynamically located using Java's <code>ServiceLoader</code>. You can find clear installation steps in each module. We'll see how to implement custom adapters as well.</p> <p>If you want to run examples presented here, get started by installing your favorite JSON adapter!</p>"},{"location":"object_mapping/#receiving-objects","title":"Receiving Objects","text":"<p>To get an <code>HttpResponse&lt;T&gt;</code>, give <code>MoreBodyHandlers</code> a <code>T.class</code> and it'll give you a <code>BodyHandler&lt;T&gt;</code> in return.</p> <pre><code>final Methanol client = Methanol.newBuilder()\n.baseUri(\"https://api.github.com/\")\n.defaultHeader(\"Accept\", \"application/vnd.github.v3+json\")\n.build();\n\nGitHubUser getUser(String username) throws IOException, InterruptedException {\nvar request = MutableRequest.GET(\"user/\" + username);\nvar response = client.send(request, MoreBodyHandlers.ofObject(GitHubUser.class));\nreturn response.body();\n}\n\npublic static final class GitHubUser {\npublic String login;\npublic long id;\npublic String url;\n\n// Other fields omitted. \n// Annotate with @JsonIgnoreProperties(ignoreUnknown = true) to run with Jackson.\n}\n</code></pre> <p>If you want to get fancier with generics, use a <code>TypeRef&lt;T&gt;</code>.</p> <pre><code>final Methanol client = Methanol.newBuilder()\n.baseUri(\"https://api.github.com/\")\n.defaultHeader(\"Accept\", \"application/vnd.github.v3+json\")\n.build();\n\nList&lt;GitHubIssue&gt; getIssuesForRepo(String owner, String repo) throws IOException, InterruptedException {\nvar request = MutableRequest.GET(\"repos/\" + owner + \"/\" + repo +  \"/issues\");\nvar response = client.send(\nrequest, MoreBodyHandlers.ofObject(new TypeRef&lt;List&lt;GitHubIssue&gt;&gt;() {}));\nreturn response.body();\n}\n\npublic static final class GitHubIssue {\npublic String title;\npublic GitHubUser user;\npublic String body;\n\n// Other fields omitted. \n// Annotate with @JsonIgnoreProperties(ignoreUnknown = true) to run with Jackson.\n}\n\npublic static final class GitHubUser {\npublic String login;\npublic long id;\npublic String url;\n\n// Other fields omitted. \n// Annotate with @JsonIgnoreProperties(ignoreUnknown = true) to run with Jackson.\n}\n</code></pre> <p>The right adapter is selected based on response's <code>Content-Type</code>. For instance, a response with <code>Content-Type: application/json</code> causes Methanol to look for a JSON adapter. If such lookup fails, an <code>UnsupportedOperationException</code> is thrown. </p>"},{"location":"object_mapping/#sending-objects","title":"Sending Objects","text":"<p>Get a <code>BodyPubilsher</code> for whatever object you've got by passing it in along with a <code>MediaType</code> describing which adapter you prefer selected.</p> <pre><code>final Methanol client = Methanol.newBuilder()\n.baseUri(\"https://api.github.com/\")\n.defaultHeader(\"Accept\", \"application/vnd.github.v3+json\")\n.build();\n\nString renderMarkdown(RenderRequest renderRequest) throws IOException, InterruptedException {\nvar requestBody = MoreBodyPublishers.ofObject(renderRequest, MediaType.APPLICATION_JSON);\nvar request = MutableRequest.POST(\"markdown\", requestBody);\nvar response = client.send(request, BodyHandlers.ofString());\n\nreturn response.body();\n}\n\npublic static final class RenderRequest {\npublic String text, mode, context;\n}\n</code></pre>"},{"location":"object_mapping/#adapters","title":"Adapters","text":"<p>An adapter provides <code>Encoder</code> and/or <code>Decoder</code> implementations. Both interfaces implement <code>BodyAdapter</code>, which defines the methods necessary for Methanol to know which  object types the adapter believes it can handle, and in what scheme. An <code>Encoder</code> creates a <code>BodyPublisher</code> that streams a given object's serialized form. Similarly, a <code>Decoder</code> supplies <code>BodySubscriber&lt;T&gt;</code> instances for a given <code>TypeRef&lt;T&gt;</code> that convert the response body into <code>T</code>. An optional <code>MediaType</code> is passed to encoders &amp; decoders to further describe the desired mapping scheme  (e.g. specify a character set).</p>"},{"location":"object_mapping/#example-an-html-adapter","title":"Example - An HTML Adapter","text":"<p>Here's an adapter that uses Jsoup to convert HTML bodies to parsed <code>Document</code> objects and vise versa. When you're writing adapters, extend from <code>AbstractBodyAdapter</code> to get free media type matching &amp; other helpful functions.</p> <pre><code>public abstract class JsoupAdapter extends AbstractBodyAdapter {\nJsoupAdapter() {\nsuper(MediaType.TEXT_HTML);\n}\n\n@Override\npublic boolean supportsType(TypeRef&lt;?&gt; type) {\nreturn type.rawType() == Document.class;\n}\n\npublic static final class Decoder extends JsoupAdapter implements BodyAdapter.Decoder {\n@Override\npublic &lt;T&gt; BodySubscriber&lt;T&gt; toObject(TypeRef&lt;T&gt; type, @Nullable MediaType mediaType) {\nrequireSupport(type);\nrequireCompatibleOrNull(mediaType);\n\nvar charset = charsetOrUtf8(mediaType);\nvar subscriber = BodySubscribers.mapping(BodySubscribers.ofString(charset), Jsoup::parse);\nreturn BodySubscribers.mapping(subscriber, type.exactRawType()::cast); // Safely cast Document to T\n}\n}\n\npublic static final class Encoder extends JsoupAdapter implements BodyAdapter.Encoder {\n@Override\npublic BodyPublisher toBody(Object object, @Nullable MediaType mediaType) {\nrequireSupport(object.getClass());\nrequireCompatibleOrNull(mediaType);\n\nvar charset = charsetOrUtf8(mediaType);\nvar publisher = BodyPublishers.ofString(((Document) object).outerHtml(), charset);\nreturn attachMediaType(publisher, mediaType);\n}\n}\n}\n</code></pre> <p>Tip</p> <p>Make sure your encoders call <code>AbstractBodyAdapter::attachMediaType</code> so the created <code>BodyPublisher</code> is converted to a <code>MimeBodyPublisher</code> if the given media type isn't null. That way, requests get the correct <code>Content-Type</code> header added by <code>Methanol</code>.</p>"},{"location":"object_mapping/#registration","title":"Registration","text":"<p>Declare your encoder &amp; decoder implementations as service-providers in the manner specified by Java's <code>ServiceLoader</code>. Here's the appropriate provider declarations for our Jsoup adapter to put in <code>module-info.java</code>.</p> <pre><code>module my.module {\n...\n\nprovides BodyAdapter.Decoder with JsoupAdapter.Decoder;\nprovides BodyAdapter.Encoder with JsoupAdapter.Encoder;\n}\n</code></pre> <p>See any of the supported adapters for more registration methods.</p>"},{"location":"object_mapping/#usage","title":"Usage","text":"<p>Now Methanol can send and receive HTML <code>Documents</code>!</p> <pre><code>final Methanol client = Methanol.create();\n\nHttpResponse&lt;Document&gt; downloadHtml(String url) throws IOException, InterruptedException {\nvar request = MutableRequest.GET(url).header(\"Accept\", \"text/html\");\n\nreturn client.send(request, MoreBodyHandlers.ofObject(Document.class));\n}\n\n&lt;T&gt; HttpResponse&lt;T&gt; uploadHtml(String url, Document htmlDoc, BodyHandler&lt;T&gt; responseHandler) throws IOException, InterruptedException {\nvar requestBody = MoreBodyPublishers.ofObject(htmlDoc, MediaType.TEXT_HTML);\nvar request = MutableRequest.POST(url, requestBody);\n\nreturn client.send(request, responseHandler);\n}\n</code></pre>"},{"location":"object_mapping/#buffering-vs-streaming","title":"Buffering vs Streaming","text":"<p><code>MoreBodyHandlers::ofObject</code> creates handlers that use <code>MoreBodySubscribers::ofObject</code> to obtain the appropriate <code>BodySubscriber&lt;T&gt;</code> from a chosen adapter. Such subscriber typically loads the whole response into memory then decodes from there. If your responses tend to have large bodies, or you'd prefer the memory efficiency afforded by streaming sources, <code>MoreBodyHandlers::ofDeferredObject</code> is the way to go.</p> <pre><code>final Methanol client = Methanol.newBuilder()\n.baseUri(\"https://api.github.com/\")\n.defaultHeader(\"Accept\", \"application/vnd.github.v3+json\")\n.build();\n\nGitHubUser getUser(String username) throws IOException, InterruptedException {\nvar request = MutableRequest.GET(\"user/\" + username);\nvar response = client.send(request, MoreBodyHandlers.ofDeferredObject(GitHubUser.class));\nreturn response.body().get();\n}\n\npublic static final class GitHubUser {\npublic String login;\npublic long id;\npublic String url;\n\n// Other fields omitted. \n// Annotate with @JsonIgnoreProperties(ignoreUnknown = true) to run with Jackson.\n}\n</code></pre> <p>The handler results in an <code>HttpResponse&lt;Supplier&lt;T&gt;&gt;</code>. The response is completed as soon as all headers are read. If the chosen decoder's <code>toDeferredObject</code> is implemented correctly, processing is deferred till you invoke the supplier and the body is decoded from a streaming source, typically an <code>InputStream</code> or a <code>Reader</code>.</p> <p>The <code>Decoder</code> interface has a naive default implementation for <code>toDeferredObject</code> that doesn't read from a streaming source. Here's how it'd be properly implemented for our HTML adapter's decoder.</p> <pre><code>@Override\npublic &lt;T&gt; BodySubscriber&lt;Supplier&lt;T&gt;&gt; toDeferredObject(\nTypeRef&lt;T&gt; type, @Nullable MediaType mediaType) {\nrequireSupport(type);\nrequireCompatibleOrNull(mediaType);\n\nvar charset = charsetOrUtf8(mediaType);\nBodySubscriber&lt;Supplier&lt;Document&gt;&gt; subscriber = BodySubscribers.mapping(\nMoreBodySubscribers.ofReader(charset),\nreader -&gt; () -&gt; Parser.htmlParser().parseInput(new BufferedReader(reader), \"\")); // Note the deferred parsing\nreturn BodySubscribers.mapping(\nsubscriber,\nsupplier -&gt; () -&gt; type.exactRawType().cast(supplier.get())); // Safely cast Document to T\n}\n</code></pre>"},{"location":"progress_tracking/","title":"Progress Tracking","text":"<p>You can track download &amp; upload progress using Methanol's <code>ProgressTracker</code>.</p>"},{"location":"progress_tracking/#setup","title":"Setup","text":"<p>A <code>ProgressTracker</code> controls the rate at which progress events are propagated using two thresholds: bytes transferred &amp; time passed, both calculated since the last event. </p> Byte count thresholdTime passed threshold <pre><code>// Receive a progress event at least each 50 kBs of data\nvar tracker = ProgressTracker.newBuilder()\n.bytesTransferredThreshold(50 * 1024)\n.build();\n</code></pre> <pre><code>// Receive a progress event at least each half a second\nvar tracker = ProgressTracker.newBuilder()\n.timePassedThreshold(Duration.ofSeconds(1).dividedBy(2))\n.build();\n</code></pre> <p>Tip</p> <p>You can use the builder to set an <code>Executor</code> that's used for dispatching progress events to  your listener. That's useful in case your listener does something like GUI updates. You'd want it to be invoked in the GUI thread rather than    an arbitrary HTTP client thread.</p> <pre><code>var tracker = ProgressTracker.newBuilder()\n.bytesTransferredThreshold(50 * 1024)\n.executor(javafx.application.Platform::runLater)\n.build();\n</code></pre>"},{"location":"progress_tracking/#usage","title":"Usage","text":"<p>You track download progress by attaching a <code>Listener</code> to a response's <code>BodyHandler</code>. Similarly, upload progress is tracked by registering a <code>Listener</code> with a request's <code>BodyPublisher</code>.</p> Track downloadsTrack uploads <pre><code>final Methanol client = Methanol.create();\n\nfinal ProgressTracker tracker = ProgressTracker.newBuilder()\n.bytesTransferredThreshold(60 * 1024) // 60 kB\n.build();\n\nHttpResponse&lt;Path&gt; downloadVeryInterestingVideo() throws IOException, InterruptedException {\nvar request = MutableRequest.GET(\"https://i.imgur.com/NYvl8Sy.mp4\");\n\nvar downloadingBodyHandler = BodyHandlers.ofFile(\nPath.of(\"interesting-video.mp4\"), CREATE, WRITE);\nvar trackingBodyHandler = tracker.tracking(downloadingBodyHandler, this::onProgress);\n\nreturn client.send(request, trackingBodyHandler);\n}\n\nvoid onProgress(Progress progress) {\nif (progress.determinate()) { // Overall progress can be measured\nvar percent = 100 * progress.value();\nSystem.out.printf(\n\"Downloaded %d from %d bytes (%.2f%%)%n\", progress.totalBytesTransferred(), progress.contentLength(), percent);\n} else {\nSystem.out.println(\"Downloaded \" + progress.totalBytesTransferred());\n}\n\nif (progress.done()) {\nSystem.out.println(\"Done!\");\n}\n}\n</code></pre> <pre><code>final Methanol client = Methanol.create();\n\nfinal ProgressTracker tracker = ProgressTracker.newBuilder()\n.bytesTransferredThreshold(60 * 1024) // 60 kB\n.build();\n\n&lt;T&gt; HttpResponse&lt;T&gt; upload(Path file, BodyHandler&lt;T&gt; bodyHandler)\nthrows IOException, InterruptedException {\nvar trackingRequestBody = tracker.tracking(BodyPublishers.ofFile(file), this::onProgress);\nvar request = MutableRequest.POST(\"https://httpbin.org/post\", trackingRequestBody);\n\nreturn client.send(request, bodyHandler);\n}\n\nvoid onProgress(Progress progress) {\nif (progress.determinate()) { // Overall progress can be measured\nvar percent = 100 * progress.value();\nSystem.out.printf(\n\"Uploaded %d from %d bytes (%.2f%%)%n\", progress.totalBytesTransferred(), progress.contentLength(), percent);\n} else {\nSystem.out.println(\"Uploaded \" + progress.totalBytesTransferred());\n}\n\nif (progress.done()) {\nSystem.out.println(\"Done!\");\n}\n}\n</code></pre>"},{"location":"writablebodypublisher/","title":"WritableBodyPublisher","text":"<p>Using <code>WritableBodyPublisher</code>, you can stream the request body through an <code>OutputStream</code> or a <code>WritableByteChannel</code>, possibly asynchronously.</p>"},{"location":"writablebodypublisher/#example-gzipped-uploads","title":"Example - Gzipped Uploads","text":"<p>Let's say your sever supports compressed requests. You'd want your file uploads to be faster, so you compress the request body with gzip.</p> <pre><code>final Methanol client = Methanol.create();\n\nCompletableFuture&lt;HttpResponse&lt;Void&gt;&gt; postAsync(Path file) {\nvar requestBody = WritableBodyPublisher.create();\nvar request = MutableRequest.POST(\"https://example.com\", requestBody)\n.header(\"Content-Encoding\", \"gzip\");\n\nCompletableFuture.runAsync(() -&gt; {\ntry (var gzipOut = new GZIPOutputStream(requestBody.outputStream())) {\nFiles.copy(file, gzipOut);\n} catch (IOException ioe) {\nrequestBody.closeExceptionally(ioe);\n}\n});\n\nreturn client.sendAsync(request, BodyHandlers.discarding());\n}\n</code></pre> <p><code>WritableBodyPublisher</code> acts as a pipe which connects <code>OutputStream</code> and <code>BodyPublisher</code> backends. It may buffer content temporarily in case the consumer can't keep up with the producer, or till an inner buffer becomes full. You can use <code>WritableBodyPublisher::flush</code>to make any buffered content available for consumption. After you're done writing, call <code>close()</code> or <code>closeExceptionally(Throwable)</code> to complete the request either normally or exceptionally.</p>"},{"location":"adapters/gson/","title":"methanol-gson","text":"<p>Adapters for JSON using Gson.</p>"},{"location":"adapters/gson/#installation","title":"Installation","text":""},{"location":"adapters/gson/#gradle","title":"Gradle","text":"<pre><code>implementation 'com.github.mizosoft.methanol:methanol-gson:1.7.0'\n</code></pre>"},{"location":"adapters/gson/#maven","title":"Maven","text":"<pre><code>&lt;dependency&gt;\n&lt;groupId&gt;com.github.mizosoft.methanol&lt;/groupId&gt;\n&lt;artifactId&gt;methanol-gson&lt;/artifactId&gt;\n&lt;version&gt;1.7.0&lt;/version&gt;\n&lt;/dependency&gt;\n</code></pre> <p>The adapters need to be registered as service providers so Methanol knows they're there. The way this is done depends on your project setup.</p>"},{"location":"adapters/gson/#module-path","title":"Module Path","text":"<p>Follow these steps if your project uses the Java module system.</p> <ol> <li> <p>Add this class to your module:</p> <pre><code>public class GsonProviders {\nprivate static final Gson gson = new Gson();\n\npublic static class EncoderProvider {\npublic static BodyAdapter.Encoder provider() {\nreturn GsonAdapterFactory.createEncoder(gson);\n}\n}\n\npublic static class DecoderProvider {\npublic static BodyAdapter.Decoder provider() {\nreturn GsonAdapterFactory.createDecoder(gson);\n}\n}\n}\n</code></pre> </li> <li> <p>Add the corresponding provider declarations in your <code>module-info.java</code> file.</p> <pre><code>requires methanol.adapter.gson;\n\nprovides BodyAdapter.Encoder with GsonProviders.EncoderProvider;\nprovides BodyAdapter.Decoder with GsonProviders.DecoderProvider;\n</code></pre> </li> </ol>"},{"location":"adapters/gson/#classpath","title":"Classpath","text":"<p>Registering adapters from the classpath requires declaring the implementation classes in provider-configuration files that are bundled with your JAR. You'll first need to implement delegating <code>Encoder</code> &amp; <code>Decoder</code> that forward to the instances created by <code>GsonAdapterFactory</code>. Extending from <code>ForwardingEncoder</code> &amp; <code>ForwardingDecoder</code> makes this easier.</p> <p>You can use Google's AutoService to generate the provider-configuration files automatically, so you won't bother writing them.</p>"},{"location":"adapters/gson/#using-autoservice","title":"Using AutoService","text":"<p>First, install AutoService.</p>"},{"location":"adapters/gson/#gradle_1","title":"Gradle","text":"<pre><code>implementation \"com.google.auto.service:auto-service-annotations:$autoServiceVersion\"\nannotationProcessor \"com.google.auto.service:auto-service:$autoServiceVersion\"\n</code></pre>"},{"location":"adapters/gson/#maven_1","title":"Maven","text":"<pre><code>&lt;dependency&gt;\n&lt;groupId&gt;com.google.auto.service&lt;/groupId&gt;\n&lt;artifactId&gt;auto-service-annotations&lt;/artifactId&gt;\n&lt;version&gt;${autoServiceVersion}&lt;/version&gt;\n&lt;/dependency&gt;\n</code></pre> <p>Configure the annotation processor with the compiler plugin.</p> <pre><code>&lt;plugin&gt;\n&lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;\n&lt;configuration&gt;\n&lt;annotationProcessorPaths&gt;\n&lt;path&gt;\n&lt;groupId&gt;com.google.auto.service&lt;/groupId&gt;\n&lt;artifactId&gt;auto-service&lt;/artifactId&gt;\n&lt;version&gt;${autoServiceVersion}&lt;/version&gt;\n&lt;/path&gt;\n&lt;/annotationProcessorPaths&gt;\n&lt;/configuration&gt;\n&lt;/plugin&gt;\n</code></pre> <p>Next, add this class to your project:</p> <pre><code>public class GsonAdapters {\nprivate static final Gson gson = new Gson();\n\n@AutoService(BodyAdapter.Encoder.class)\npublic static class Encoder extends ForwardingEncoder {\npublic Encoder() {\nsuper(GsonAdapterFactory.createEncoder(gson));\n}\n}\n\n@AutoService(BodyAdapter.Decoder.class)\npublic static class Decoder extends ForwardingDecoder {\npublic Decoder() {\nsuper(GsonAdapterFactory.createDecoder(gson));\n}\n}\n}\n</code></pre>"},{"location":"adapters/gson/#manual-configuration","title":"Manual Configuration","text":"<p>You can also write the configuration files manually. First, add this class to your project:</p> <pre><code>public class GsonAdapters {\nprivate static final Gson gson = new Gson();\n\npublic static class Encoder extends ForwardingEncoder {\npublic Encoder() {\nsuper(GsonAdapterFactory.createEncoder(gson));\n}\n}\n\npublic static class Decoder extends ForwardingDecoder {\npublic Decoder() {\nsuper(GsonAdapterFactory.createDecoder(gson));\n}\n}\n}\n</code></pre> <p>Next, create two provider-configuration files in the resource directory: <code>META-INF/services</code>, one for the encoder and the other for the decoder. Each file must contain the fully qualified name of the implementation class.</p> <p>Let's say the above class is in a package named <code>com.example</code>. You'll want to have one file for the encoder named:</p> <pre><code>META-INF/services/com.github.mizosoft.methanol.BodyAdapter$Encoder\n</code></pre> <p>and contains the following line:</p> <pre><code>com.example.GsonAdapters$Encoder\n</code></pre> <p>Similarly, the decoder's file is named:</p> <pre><code>META-INF/services/com.github.mizosoft.methanol.BodyAdapter$Decoder\n</code></pre> <p>and contains:</p> <pre><code>com.example.GsonAdapters$Decoder\n</code></pre>"},{"location":"adapters/jackson/","title":"methanol-jackson","text":"<p>Adapters for Jackson.</p>"},{"location":"adapters/jackson/#installation","title":"Installation","text":""},{"location":"adapters/jackson/#gradle","title":"Gradle","text":"<pre><code>implementation 'com.github.mizosoft.methanol:methanol-jackson:1.7.0'\n</code></pre>"},{"location":"adapters/jackson/#maven","title":"Maven","text":"<pre><code>&lt;dependency&gt;\n&lt;groupId&gt;com.github.mizosoft.methanol&lt;/groupId&gt;\n&lt;artifactId&gt;methanol-jackson&lt;/artifactId&gt;\n&lt;version&gt;1.7.0&lt;/version&gt;\n&lt;/dependency&gt;\n</code></pre> <p>The adapters need to be registered as service providers so Methanol knows they're there. The way this is done depends on your project setup.</p>"},{"location":"adapters/jackson/#module-path","title":"Module Path","text":"<p>Follow these steps if your project uses the Java module system.</p> <ol> <li> <p>Add this class to your module:</p> <pre><code>public class JacksonJsonProviders {\nprivate static final ObjectMapper mapper = new ObjectMapper();\n\npublic static class EncoderProvider {\npublic static BodyAdapter.Encoder provider() {\nreturn JacksonAdapterFactory.createJsonEncoder(mapper);\n}\n}\n\npublic static class DecoderProvider {\npublic static BodyAdapter.Decoder provider() {\nreturn JacksonAdapterFactory.createJsonDecoder(mapper);\n}\n}\n}\n</code></pre> </li> <li> <p>Add the corresponding provider declarations in your <code>module-info.java</code> file.</p> <pre><code>requires methanol.adapter.jackson;\n\nprovides BodyAdapter.Encoder with JacksonJsonProviders.EncoderProvider;\nprovides BodyAdapter.Decoder with JacksonJsonProviders.DecoderProvider;\n</code></pre> </li> </ol>"},{"location":"adapters/jackson/#classpath","title":"Classpath","text":"<p>Registering adapters from the classpath requires declaring the implementation classes in provider-configuration files that are bundled with your JAR. You'll first need to implement delegating <code>Encoder</code> &amp; <code>Decoder</code> that forward to the instances created by <code>JacksonAdapterFactory</code>. Extending from <code>ForwardingEncoder</code> &amp; <code>ForwardingDecoder</code> makes this easier.</p> <p>You can use Google's AutoService to generate the provider-configuration files automatically, so you won't bother writing them.</p>"},{"location":"adapters/jackson/#using-autoservice","title":"Using AutoService","text":"<p>First, install AutoService.</p>"},{"location":"adapters/jackson/#gradle_1","title":"Gradle","text":"<pre><code>implementation \"com.google.auto.service:auto-service-annotations:$autoServiceVersion\"\nannotationProcessor \"com.google.auto.service:auto-service:$autoServiceVersion\"\n</code></pre>"},{"location":"adapters/jackson/#maven_1","title":"Maven","text":"<pre><code>&lt;dependency&gt;\n&lt;groupId&gt;com.google.auto.service&lt;/groupId&gt;\n&lt;artifactId&gt;auto-service-annotations&lt;/artifactId&gt;\n&lt;version&gt;${autoServiceVersion}&lt;/version&gt;\n&lt;/dependency&gt;\n</code></pre> <p>Configure the annotation processor with the compiler plugin.</p> <pre><code>&lt;plugin&gt;\n&lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;\n&lt;configuration&gt;\n&lt;annotationProcessorPaths&gt;\n&lt;path&gt;\n&lt;groupId&gt;com.google.auto.service&lt;/groupId&gt;\n&lt;artifactId&gt;auto-service&lt;/artifactId&gt;\n&lt;version&gt;${autoServiceVersion}&lt;/version&gt;\n&lt;/path&gt;\n&lt;/annotationProcessorPaths&gt;\n&lt;/configuration&gt;\n&lt;/plugin&gt;\n</code></pre> <p>Next, add this class to your project:</p> <pre><code>public class JacksonJsonAdapters {\nprivate static final ObjectMapper mapper = new ObjectMapper();\n\n@AutoService(BodyAdapter.Encoder.class)\npublic static class Encoder extends ForwardingEncoder {\npublic Encoder() {\nsuper(JacksonAdapterFactory.createJsonEncoder(mapper));\n}\n}\n\n@AutoService(BodyAdapter.Decoder.class)\npublic static class Decoder extends ForwardingDecoder {\npublic Decoder() {\nsuper(JacksonAdapterFactory.createJsonDecoder(mapper));\n}\n}\n}\n</code></pre>"},{"location":"adapters/jackson/#manual-configuration","title":"Manual Configuration","text":"<p>You can also write the configuration files manually. First, add this class to your project:</p> <pre><code>public class JacksonJsonAdapters {\nprivate static final ObjectMapper mapper = new ObjectMapper();\n\npublic static class Encoder extends ForwardingEncoder {\npublic Encoder() {\nsuper(JacksonAdapterFactory.createJsonEncoder(mapper));\n}\n}\n\npublic static class Decoder extends ForwardingDecoder {\npublic Decoder() {\nsuper(JacksonAdapterFactory.createJsonDecoder(mapper));\n}\n}\n}\n</code></pre> <p>Next, create two provider-configuration files in the resource directory: <code>META-INF/services</code>, one for the encoder and the other for the decoder. Each file must contain the fully qualified name of the implementation class.</p> <p>Let's say the above class is in a package named <code>com.example</code>. You'll want to have one file for the encoder named:</p> <pre><code>META-INF/services/com.github.mizosoft.methanol.BodyAdapter$Encoder\n</code></pre> <p>and contains the following line:</p> <pre><code>com.example.JacksonJsonAdapters$Encoder\n</code></pre> <p>Similarly, the decoder's file is named:</p> <pre><code>META-INF/services/com.github.mizosoft.methanol.BodyAdapter$Decoder\n</code></pre> <p>and contains:</p> <pre><code>com.example.JacksonJsonAdapters$Decoder\n</code></pre>"},{"location":"adapters/jackson/#adapters-for-other-formats","title":"Adapters for other formats","text":"<p>The Jackson adapter doesn't only support JSON. You can pair whatever <code>ObjectMapper</code> implementation  with one or more <code>MediaTypes</code> to create adapters for any of the formats supported by Jackson. For instance, here's a provider for a XML adapter. You'll need to pull in <code>jackson-dataformat-xml</code>. You can install it as mentioned above. </p> <pre><code>public class JacksonXmlProviders {\nprivate static final ObjectMapper mapper = new XmlMapper();\n\npublic static class EncoderProvider {\npublic static BodyAdapter.Encoder provider() {\nreturn JacksonAdapterFactory.createEncoder(mapper, MediaType.TEXT_XML);\n}\n}\n\npublic static class DecoderProvider {\npublic static BodyAdapter.Decoder provider() {\nreturn JacksonAdapterFactory.createDecoder(mapper, MediaType.TEXT_XML);\n}\n}\n}\n</code></pre> <p>For binary formats, you usually can't just plug in an <code>ObjectMapper</code> as a schema must be applied for each type. For this reason you can use a custom <code>ObjectReaderFactory</code> and/or <code>ObjectWriterFactory</code>. For instance, here's a provider for a Protocol Buffers adapter. You'll need to know what types are expected beforehand.</p> <pre><code>record Point(int x, int y) {}\n\npublic class JacksonProtobufProviders {\nprivate static final ObjectMapper mapper = new ProtobufMapper();\n\n/**\n   * We'll store our schemas in a map. You can implement this in other ways, like loading the\n   * protobuf files lazily when needed.\n   */\nprivate static final Map&lt;TypeRef&lt;?&gt;, ProtobufSchema&gt; schemas;\n\nstatic {\ntry {\nschemas = Map.of(\nTypeRef.from(Point.class),\nProtobufSchemaLoader.std.parse(\n\"\"\"\n              message Point {\n                required int32 x = 1;\n                required int32 y = 2;\n              }\n              \"\"\"));\n} catch (IOException e) {\nthrow new ExceptionInInitializerError(e);\n}\n}\n\npublic static class EncoderProvider {\npublic static BodyAdapter.Encoder provider() {\nObjectWriterFactory writerFactory = (mapper, type) -&gt; mapper.writer(schemas.get(type));\nreturn JacksonAdapterFactory.createEncoder(\nmapper, writerFactory, MediaType.APPLICATION_X_PROTOBUF);\n}\n}\n\npublic static class DecoderProvider {\npublic static BodyAdapter.Decoder provider() {\nObjectReaderFactory readerFactory =\n(mapper, type) -&gt; mapper.readerFor(type.rawType()).with(schemas.get(type));\nreturn JacksonAdapterFactory.createDecoder(\nmapper, readerFactory, MediaType.APPLICATION_X_PROTOBUF);\n}\n}\n}\n</code></pre>"},{"location":"adapters/jackson_flux/","title":"methanol-jackson-flux","text":"<p>Adapters for JSON &amp; Reactive Streams using Jackson &amp; Reactor.</p>"},{"location":"adapters/jackson_flux/#decoding","title":"Decoding","text":"<p>This adapter converts response bodies into publisher-based sources. Supported types are <code>Mono</code>, <code>Flux</code>, <code>org.reactivestreams.Publisher</code> and <code>java.util.concurrent.Flow.Publisher</code>. For all these types except <code>Mono</code>, the response body is expected to be a JSON array. The array is tokenized into its individual elements, each mapped to the publisher's element type.</p> <p>Note that an <code>HttpResponse</code> handled with this adapter is completed immediately after the response headers are received. Body completion is handled by the returned publisher source. Additionally, the decoder always uses Jackson's non-blocking parser. This makes <code>MoreBodyHandlers::ofDeferredObject</code> redundant with this decoder.</p>"},{"location":"adapters/jackson_flux/#encoding","title":"Encoding","text":"<p>With the exception of <code>Mono</code>, any subtype of <code>org.reactivestreams.Publisher</code> or <code>java.util.concurrent.Flow.Publisher</code> is encoded to a JSON array containing zero or more elements, each mapped from each published object. <code>Mono</code> sources are encoded to a single JSON object (if completed with any).</p>"},{"location":"adapters/jackson_flux/#installation","title":"Installation","text":""},{"location":"adapters/jackson_flux/#gradle","title":"Gradle","text":"<pre><code>implementation 'com.github.mizosoft.methanol:methanol-jackson-flux:1.7.0'\n</code></pre>"},{"location":"adapters/jackson_flux/#maven","title":"Maven","text":"<pre><code>&lt;dependency&gt;\n&lt;groupId&gt;com.github.mizosoft.methanol&lt;/groupId&gt;\n&lt;artifactId&gt;methanol-jackson-flux&lt;/artifactId&gt;\n&lt;version&gt;1.7.0&lt;/version&gt;\n&lt;/dependency&gt;\n</code></pre> <p>The adapters need to be registered as service providers so Methanol knows they're there. The way this is done depends on your project setup.</p>"},{"location":"adapters/jackson_flux/#module-path","title":"Module Path","text":"<p>Follow these steps if your project uses the Java module system.</p> <ol> <li> <p>Add this class to your module:</p> <pre><code>public class JacksonFluxProviders {\nprivate static final ObjectMapper mapper = new ObjectMapper();\n\npublic static class EncoderProvider {\npublic static BodyAdapter.Encoder provider() {\nreturn JacksonFluxAdapterFactory.createEncoder(mapper);\n}\n}\n\npublic static class DecoderProvider {\npublic static BodyAdapter.Decoder provider() {\nreturn JacksonFluxAdapterFactory.createDecoder(mapper);\n}\n}\n}\n</code></pre> </li> <li> <p>Add the corresponding provider declarations in your <code>module-info.java</code> file.</p> <pre><code>requires methanol.adapter.jackson.flux;\n\nprovides BodyAdapter.Encoder with JacksonFluxProviders.EncoderProvider;\nprovides BodyAdapter.Decoder with JacksonFluxProviders.DecoderProvider;\n</code></pre> </li> </ol>"},{"location":"adapters/jackson_flux/#classpath","title":"Classpath","text":"<p>Registering adapters from the classpath requires declaring the implementation classes in provider-configuration files that are bundled with your JAR. You'll first need to implement delegating <code>Encoder</code> &amp; <code>Decoder</code> that forward to the instances created by <code>JacksonAdapterFactory</code>. Extending from <code>ForwardingEncoder</code> &amp; <code>ForwardingDecoder</code> makes this easier.</p> <p>You can use Google's AutoService to generate the provider-configuration files automatically, so you won't bother writing them.</p>"},{"location":"adapters/jackson_flux/#using-autoservice","title":"Using AutoService","text":"<p>First, install AutoService.</p>"},{"location":"adapters/jackson_flux/#gradle_1","title":"Gradle","text":"<pre><code>implementation \"com.google.auto.service:auto-service-annotations:$autoServiceVersion\"\nannotationProcessor \"com.google.auto.service:auto-service:$autoServiceVersion\"\n</code></pre>"},{"location":"adapters/jackson_flux/#maven_1","title":"Maven","text":"<pre><code>&lt;dependency&gt;\n&lt;groupId&gt;com.google.auto.service&lt;/groupId&gt;\n&lt;artifactId&gt;auto-service-annotations&lt;/artifactId&gt;\n&lt;version&gt;${autoServiceVersion}&lt;/version&gt;\n&lt;/dependency&gt;\n</code></pre> <p>Configure the annotation processor with the compiler plugin.</p> <pre><code>&lt;plugin&gt;\n&lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;\n&lt;configuration&gt;\n&lt;annotationProcessorPaths&gt;\n&lt;path&gt;\n&lt;groupId&gt;com.google.auto.service&lt;/groupId&gt;\n&lt;artifactId&gt;auto-service&lt;/artifactId&gt;\n&lt;version&gt;${autoServiceVersion}&lt;/version&gt;\n&lt;/path&gt;\n&lt;/annotationProcessorPaths&gt;\n&lt;/configuration&gt;\n&lt;/plugin&gt;\n</code></pre> <p>Next, add this class to your project:</p> <pre><code>public class JacksonFluxAdapters {\nprivate static final ObjectMapper mapper = new ObjectMapper();\n\n@AutoService(BodyAdapter.Encoder.class)\npublic static class Encoder extends ForwardingEncoder {\npublic Encoder() {\nsuper(JacksonFluxAdapterFactory.createEncoder(mapper));\n}\n}\n\n@AutoService(BodyAdapter.Decoder.class)\npublic static class Decoder extends ForwardingDecoder {\npublic Decoder() {\nsuper(JacksonFluxAdapterFactory.createDecoder(mapper));\n}\n}\n}\n</code></pre>"},{"location":"adapters/jackson_flux/#manual-configuration","title":"Manual Configuration","text":"<p>You can also write the configuration files manually. First, add this class to your project:</p> <pre><code>public class JacksonFluxAdapters {\nprivate static final ObjectMapper mapper = new ObjectMapper();\n\npublic static class Encoder extends ForwardingEncoder {\npublic Encoder() {\nsuper(JacksonFluxAdapterFactory.createEncoder(mapper));\n}\n}\n\npublic static class Decoder extends ForwardingDecoder {\npublic Decoder() {\nsuper(JacksonFluxAdapterFactory.createDecoder(mapper));\n}\n}\n}\n</code></pre> <p>Next, create two provider-configuration files in the resource directory: <code>META-INF/services</code>, one for the encoder and the other for the decoder. Each file must contain the fully qualified name of the implementation class.</p> <p>Let's say the above class is in a package named <code>com.example</code>. You'll want to have one file for the encoder named:</p> <pre><code>META-INF/services/com.github.mizosoft.methanol.BodyAdapter$Encoder\n</code></pre> <p>and contains the following line:</p> <pre><code>com.example.JacksonFluxAdapters$Encoder\n</code></pre> <p>Similarly, the decoder's file is named:</p> <pre><code>META-INF/services/com.github.mizosoft.methanol.BodyAdapter$Decoder\n</code></pre> <p>and contains:</p> <pre><code>com.example.JacksonFluxAdapters$Decoder\n</code></pre>"},{"location":"adapters/jaxb/","title":"methanol-jaxb","text":"<p>Adapters for XML using JAXB.</p>"},{"location":"adapters/jaxb/#installation","title":"Installation","text":""},{"location":"adapters/jaxb/#gradle","title":"Gradle","text":"<pre><code>implementation 'com.github.mizosoft.methanol:methanol-jaxb:1.7.0'\n</code></pre>"},{"location":"adapters/jaxb/#maven","title":"Maven","text":"<pre><code>&lt;dependency&gt;\n&lt;groupId&gt;com.github.mizosoft.methanol&lt;/groupId&gt;\n&lt;artifactId&gt;methanol-jaxb&lt;/artifactId&gt;\n&lt;version&gt;1.7.0&lt;/version&gt;\n&lt;/dependency&gt;\n</code></pre> <p>The adapters need to be registered as service providers so Methanol knows they're there. The way this is done depends on your project setup.</p>"},{"location":"adapters/jaxb/#module-path","title":"Module Path","text":"<p>Follow these steps if your project uses the Java module system.</p> <ol> <li> <p>Add this class to your module:</p> <pre><code>public class JaxbProviders {      public static class EncoderProvider {\npublic static BodyAdapter.Encoder provider() {\nreturn JaxbAdapterFactory.createEncoder();\n}\n}\n\npublic static class DecoderProvider {\npublic static BodyAdapter.Decoder provider() {\nreturn JaxbAdapterFactory.createDecoder();\n}\n}\n}\n</code></pre> </li> <li> <p>Add the corresponding provider declarations in your <code>module-info.java</code> file.</p> <pre><code>requires methanol.adapter.jaxb;   provides BodyAdapter.Encoder with JaxbProviders.EncoderProvider;\nprovides BodyAdapter.Decoder with JaxbProviders.DecoderProvider;\n</code></pre> </li> </ol>"},{"location":"adapters/jaxb/#classpath","title":"Classpath","text":"<p>Registering adapters from the classpath requires declaring the implementation classes in provider-configuration files that are bundled with your JAR. You'll first need to implement delegating <code>Encoder</code> &amp; <code>Decoder</code> that forward to the instances created by <code>JaxbAdapterFactory</code>. Extending from <code>ForwardingEncoder</code> &amp; <code>ForwardingDecoder</code> makes this easier.</p> <p>You can use Google's AutoService to generate the provider-configuration files automatically, so you won't bother writing them.</p>"},{"location":"adapters/jaxb/#using-autoservice","title":"Using AutoService","text":"<p>First, install AutoService.</p>"},{"location":"adapters/jaxb/#gradle_1","title":"Gradle","text":"<pre><code>implementation \"com.google.auto.service:auto-service-annotations:$autoServiceVersion\"\nannotationProcessor \"com.google.auto.service:auto-service:$autoServiceVersion\"\n</code></pre>"},{"location":"adapters/jaxb/#maven_1","title":"Maven","text":"<pre><code>&lt;dependency&gt;\n&lt;groupId&gt;com.google.auto.service&lt;/groupId&gt;\n&lt;artifactId&gt;auto-service-annotations&lt;/artifactId&gt;\n&lt;version&gt;${autoServiceVersion}&lt;/version&gt;\n&lt;/dependency&gt;\n</code></pre> <p>Configure the annotation processor with the compiler plugin.</p> <pre><code>&lt;plugin&gt;\n&lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;\n&lt;configuration&gt;\n&lt;annotationProcessorPaths&gt;\n&lt;path&gt;\n&lt;groupId&gt;com.google.auto.service&lt;/groupId&gt;\n&lt;artifactId&gt;auto-service&lt;/artifactId&gt;\n&lt;version&gt;${autoServiceVersion}&lt;/version&gt;\n&lt;/path&gt;\n&lt;/annotationProcessorPaths&gt;\n&lt;/configuration&gt;\n&lt;/plugin&gt;\n</code></pre> <p>Next, add this class to your project:</p> <pre><code>public class JaxbAdapters {\n@AutoService(BodyAdapter.Encoder.class)\npublic static class Encoder extends ForwardingEncoder {\npublic Encoder() {\nsuper(JaxbAdapterFactory.createEncoder());\n}\n}\n\n@AutoService(BodyAdapter.Decoder.class)\npublic static class Decoder extends ForwardingDecoder {\npublic Decoder() {\nsuper(JaxbAdapterFactory.createDecoder());\n}\n}\n}\n</code></pre>"},{"location":"adapters/jaxb/#manual-configuration","title":"Manual Configuration","text":"<p>You can also write the configuration files manually. First, add this class to your project:</p> <pre><code>public class JaxbAdapters {\npublic static class Encoder extends ForwardingEncoder {\npublic Encoder() {\nsuper(JaxbAdapterFactory.createEncoder());\n}\n}\n\npublic static class Decoder extends ForwardingDecoder {\npublic Decoder() {\nsuper(JaxbAdapterFactory.createDecoder());\n}\n}\n}\n</code></pre> <p>Next, create two provider-configuration files in the resource directory: <code>META-INF/services</code>, one for the encoder and the other for the decoder. Each file must contain the fully qualified name of the implementation class.</p> <p>Let's say the above class is in a package named <code>com.example</code>. You'll want to have one file for the encoder named:</p> <pre><code>META-INF/services/com.github.mizosoft.methanol.BodyAdapter$Encoder\n</code></pre> <p>and contains the following line:</p> <pre><code>com.example.JaxbAdapters$Encoder\n</code></pre> <p>Similarly, the decoder's file is named:</p> <pre><code>META-INF/services/com.github.mizosoft.methanol.BodyAdapter$Decoder\n</code></pre> <p>and contains:</p> <pre><code>com.example.JaxbAdapters$Decoder\n</code></pre>"},{"location":"adapters/protobuf/","title":"methanol-protobuf","text":"<p>Adapters for Google's Protocol Buffers.</p>"},{"location":"adapters/protobuf/#encoding-decoding","title":"Encoding &amp; Decoding","text":"<p>Any subtype of <code>MessageLite</code> is supported by encoders &amp; decoders. Decoders can optionally have an <code>ExtensionRegistryLite</code> or an <code>ExtensionRegistry</code> to enable message extensions.</p>"},{"location":"adapters/protobuf/#installation","title":"Installation","text":""},{"location":"adapters/protobuf/#gradle","title":"Gradle","text":"<pre><code>implementation 'com.github.mizosoft.methanol:methanol-protobuf:1.7.0'\n</code></pre>"},{"location":"adapters/protobuf/#maven","title":"Maven","text":"<pre><code>&lt;dependency&gt;\n&lt;groupId&gt;com.github.mizosoft.methanol&lt;/groupId&gt;\n&lt;artifactId&gt;methanol-protobuf&lt;/artifactId&gt;\n&lt;version&gt;1.7.0&lt;/version&gt;\n&lt;/dependency&gt;\n</code></pre> <p>The adapters need to be registered as service providers so Methanol knows they're there. The way this is done depends on your project setup.</p>"},{"location":"adapters/protobuf/#module-path","title":"Module Path","text":"<p>Follow these steps if your project uses the Java module system.</p> <ol> <li> <p>Add this class to your module:</p> <pre><code>public class ProtobufProviders {   public static class EncoderProvider {\npublic static BodyAdapter.Encoder provider() {\nreturn ProtobufAdapterFactory.createEncoder();\n}\n}\n\npublic static class DecoderProvider {\npublic static BodyAdapter.Decoder provider() {\nreturn ProtobufAdapterFactory.createDecoder();\n}\n}\n}\n</code></pre> </li> <li> <p>Add the corresponding provider declarations in your <code>module-info.java</code> file.</p> <pre><code>requires methanol.adapter.protobuf;\n\nprovides BodyAdapter.Encoder with ProtobufProviders.EncoderProvider;\nprovides BodyAdapter.Decoder with ProtobufProviders.DecoderProvider;\n</code></pre> </li> </ol>"},{"location":"adapters/protobuf/#classpath","title":"Classpath","text":"<p>Registering adapters from the classpath requires declaring the implementation classes in provider-configuration files that are bundled with your JAR. You'll first need to implement delegating <code>Encoder</code> &amp; <code>Decoder</code> that forward to the instances created by <code>ProtobufAdapterFactory</code>. Extending from <code>ForwardingEncoder</code> &amp; <code>ForwardingDecoder</code> makes this easier.</p> <p>You can use Google's AutoService to generate the provider-configuration files automatically, so you won't bother writing them.</p>"},{"location":"adapters/protobuf/#using-autoservice","title":"Using AutoService","text":"<p>First, install AutoService.</p>"},{"location":"adapters/protobuf/#gradle_1","title":"Gradle","text":"<pre><code>implementation \"com.google.auto.service:auto-service-annotations:$autoServiceVersion\"\nannotationProcessor \"com.google.auto.service:auto-service:$autoServiceVersion\"\n</code></pre>"},{"location":"adapters/protobuf/#maven_1","title":"Maven","text":"<pre><code>&lt;dependency&gt;\n&lt;groupId&gt;com.google.auto.service&lt;/groupId&gt;\n&lt;artifactId&gt;auto-service-annotations&lt;/artifactId&gt;\n&lt;version&gt;${autoServiceVersion}&lt;/version&gt;\n&lt;/dependency&gt;\n</code></pre> <p>Configure the annotation processor with the compiler plugin.</p> <pre><code>&lt;plugin&gt;\n&lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;\n&lt;configuration&gt;\n&lt;annotationProcessorPaths&gt;\n&lt;path&gt;\n&lt;groupId&gt;com.google.auto.service&lt;/groupId&gt;\n&lt;artifactId&gt;auto-service&lt;/artifactId&gt;\n&lt;version&gt;${autoServiceVersion}&lt;/version&gt;\n&lt;/path&gt;\n&lt;/annotationProcessorPaths&gt;\n&lt;/configuration&gt;\n&lt;/plugin&gt;\n</code></pre> <p>Next, add this class to your project:</p> <pre><code>public class ProtobufAdapters {  @AutoService(BodyAdapter.Encoder.class)\npublic static class Encoder extends ForwardingEncoder {\npublic Encoder() {\nsuper(ProtobufAdapterFactory.createEncoder());\n}\n}\n\n@AutoService(BodyAdapter.Decoder.class)\npublic static class Decoder extends ForwardingDecoder {\npublic Decoder() {\nsuper(ProtobufAdapterFactory.createDecoder());\n}\n}\n}\n</code></pre>"},{"location":"adapters/protobuf/#manual-configuration","title":"Manual Configuration","text":"<p>You can also write the configuration files manually. First, add this class to your project:</p> <pre><code>public class ProtobufAdapters {\npublic static class Decoder extends ForwardingDecoder {\npublic Decoder() {\nsuper(ProtobufAdapterFactory.createDecoder());\n}\n}\n\npublic static class Encoder extends ForwardingEncoder {\npublic Encoder() {\nsuper(ProtobufAdapterFactory.createEncoder());\n}\n}\n}\n</code></pre> <p>Next, create two provider-configuration files in the resource directory: <code>META-INF/services</code>, one for the encoder and the other for the decoder. Each file must contain the fully qualified name of the implementation class.</p> <p>Let's say the above class is in a package named <code>com.example</code>. You'll want to have one file for the encoder named:</p> <pre><code>META-INF/services/com.github.mizosoft.methanol.BodyAdapter$Encoder\n</code></pre> <p>and contains the following line:</p> <pre><code>com.example.ProtobufAdapters$Encoder\n</code></pre> <p>Similarly, the decoder's file is named:</p> <pre><code>META-INF/services/com.github.mizosoft.methanol.BodyAdapter$Decoder\n</code></pre> <p>and contains:</p> <pre><code>com.example.ProtobufAdapters$Decoder\n</code></pre>"}]}